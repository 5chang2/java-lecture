# 5.3. 추상 클래스와 인터페이스

> 추상 클래스와 인터페이스의 개념을 이해하고, 다형성을 활용한 설계 방법을 학습합니다.

## 학습 목표
- 추상화(Abstraction)의 개념 이해
- 추상 클래스 작성 및 활용
- 인터페이스 작성 및 다중 구현
- 추상 클래스와 인터페이스의 차이점 이해
- default, static, private 메서드 활용

---

## 1. 추상화(Abstraction)란?

### 개념

**추상화(Abstraction)**란, **세부적인 부분은 가리고, 중요한 부분만 드러내는 것**을 의미합니다.

**일상 생활의 예:**
- 키보드를 누르면 글자가 나타나는 **방법**은 알지만, **원리**는 몰라도 됨
- `Integer.parseInt()` 사용 시 **내부 구현**은 몰라도 **기능**만 알면 됨
- 자동차 운전 시 **엔진 동작 원리**는 몰라도 **운전 방법**만 알면 됨

### 프로그래밍에서의 추상화

**문제 상황:**

```java
public class Shape {
    public int calculateArea() {
        return 0;  // ❌ "도형"의 면적은 어떻게 계산하나요?
    }
}
```

**"도형" 자체는 추상적인 개념입니다:**
- 실재하지 않는 개념
- 면적을 계산할 수 없음
- "삼각형", "사각형" 같은 구체적인 존재로만 의미가 있음

**해결책:**
- 세부 구현은 자식 클래스에 맡김
- 부모 클래스는 "면적 계산 기능이 있어야 한다"는 **명세**만 제공

---

## 2. 추상 클래스(Abstract Class)

### 개념

**추상 클래스**는 **완성되지 않은 클래스**입니다.

**특징:**
- 자체적으로 인스턴스 생성 불가
- 다형성을 위한 상위 타입 역할
- 자식 클래스의 **틀**을 제시

### 문법

```java
public abstract class 클래스명 {
    // 일반 필드
    private int field;

    // 생성자
    public 클래스명() {
    }

    // 일반 메서드
    public void normalMethod() {
    }

    // 추상 메서드
    public abstract void abstractMethod();
}
```

**키워드:**
- `abstract class`: 추상 클래스 선언
- `abstract`: 추상 메서드 선언

### 추상 메서드(Abstract Method)

**구현부가 없는 메서드**입니다.

```java
public abstract class Shape {
    // 추상 메서드 - 세미콜론으로 끝남
    public abstract int calculateArea();
    public abstract void draw();
}
```

**특징:**
- 메서드 시그니처만 정의
- 구현부(`{}`) 없음
- 자식 클래스에서 **반드시** 오버라이딩

### 추상 클래스 규칙

| 규칙 | 설명 |
|------|------|
| 인스턴스 생성 | ❌ 불가능 |
| 추상 메서드 | 자식 클래스에서 반드시 구현 |
| 일반 메서드 | 가능 (선택적) |
| 필드 | 가능 (일반 클래스와 동일) |
| 생성자 | 가능 (자식 클래스에서 super() 호출) |

### 기본 예시

```java
// 추상 클래스
public abstract class Shape {
    protected int width;
    protected int height;

    // 생성자
    protected Shape(int width, int height) {
        this.width = width;
        this.height = height;
    }

    // 일반 메서드
    public void show() {
        System.out.println("너비: " + this.width);
        System.out.println("높이: " + this.height);
    }

    // 추상 메서드
    public abstract int calculateArea();
}
```

```java
// 구체 클래스
public class Triangle extends Shape {
    public Triangle(int width, int height) {
        super(width, height);
    }

    @Override
    public int calculateArea() {
        return (this.width * this.height) / 2;
    }
}
```

```java
public class Rectangle extends Shape {
    public Rectangle(int width, int height) {
        super(width, height);
    }

    @Override
    public int calculateArea() {
        return this.width * this.height;
    }
}
```

**사용:**

```java
public class Main {
    public static void main(String[] args) {
        // Shape shape = new Shape(10, 5);  // ❌ 컴파일 에러!

        Shape triangle = new Triangle(10, 5);
        Shape rectangle = new Rectangle(15, 30);

        System.out.println(triangle.calculateArea());   // 25
        System.out.println(rectangle.calculateArea());  // 450
    }
}
```

### JavaScript와의 비교

```javascript
// JavaScript는 추상 클래스 문법 없음 (ES6+)
class Shape {
    constructor(width, height) {
        if (new.target === Shape) {
            throw new Error("추상 클래스는 인스턴스화할 수 없습니다");
        }
        this.width = width;
        this.height = height;
    }

    // 서브클래스에서 구현해야 함
    calculateArea() {
        throw new Error("서브클래스에서 구현해야 합니다");
    }
}

class Triangle extends Shape {
    calculateArea() {
        return (this.width * this.height) / 2;
    }
}
```

**차이점:**
- Java: 문법적으로 강제 (컴파일 에러)
- JavaScript: 런타임 에러로 구현 (우회 방법)

---

## 3. 추상 클래스의 활용

### 실습: 사용자 입력에 따른 다형성

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("도형의 종류를 입력하세요 (삼각형/사각형): ");
        String shapeType = scanner.nextLine();

        Shape shape = null;

        // 사용자 입력에 따라 객체 생성
        if (shapeType.equals("삼각형")) {
            shape = new Triangle(3, 5);
        } else if (shapeType.equals("사각형")) {
            shape = new Rectangle(10, 20);
        }

        // 다형성: 구체적인 타입 몰라도 면적 계산 가능
        int area = shape.calculateArea();
        System.out.println("면적: " + area);
    }
}
```

**실행:**
```
도형의 종류를 입력하세요 (삼각형/사각형): 삼각형
면적: 7
```

**핵심:**
- 면적 계산 방법은 몰라도 됨 (추상화)
- `calculateArea()` 호출만 하면 됨 (명세)
- 실제 구현은 각 클래스가 담당

---

## 4. 인터페이스(Interface)

### 개념

**인터페이스**는 **기능 명세서** 역할을 하는 추상 타입입니다.

**어원:**
- Interface = 서로 다른 대상이 맞닿은 면
- GUI (Graphical User Interface)
- CLI (Command Line Interface)

**역할:**
- 클래스가 어떤 메서드를 구현해야 하는지 정의
- 구현 클래스들을 하나의 타입으로 다루기 위한 규약

### 기본 문법

```java
public interface 인터페이스명 {
    // 상수 (public static final 생략 가능)
    int MAX_VALUE = 100;

    // 추상 메서드 (public abstract 생략 가능)
    void method1();
    void method2(int param);
}
```

**특징:**

| 구성 요소 | 기본 접근 제어자 | 설명 |
|----------|--------------|------|
| 변수 | `public static final` | 상수만 가능 |
| 메서드 | `public abstract` | 추상 메서드 |
| default 메서드 | `public` | 구현 메서드 (Java 8+) |
| static 메서드 | `public` | 정적 메서드 (Java 8+) |
| private 메서드 | `private` | 내부 메서드 (Java 9+) |

### 구현(implements)

```java
public interface Drawable {
    void draw();
}

public class Circle implements Drawable {
    @Override
    public void draw() {  // ⭐ 반드시 public
        System.out.println("원을 그립니다.");
    }
}
```

**주의:**
- 인터페이스의 메서드는 `public abstract`
- 구현 시 **반드시 public**으로 오버라이딩

### 다중 구현

Java는 다중 상속은 불가능하지만, **다중 구현은 가능**합니다.

```java
public interface Drawable {
    void draw();
}

public interface Movable {
    void move();
}

// 두 인터페이스 동시 구현
public class GameCharacter implements Drawable, Movable {
    @Override
    public void draw() {
        System.out.println("캐릭터를 그립니다.");
    }

    @Override
    public void move() {
        System.out.println("캐릭터가 이동합니다.");
    }
}
```

### 상속 + 구현 동시 사용

```java
public class Animal {
    public void eat() {
        System.out.println("먹는다");
    }
}

public interface Flyable {
    void fly();
}

// 상속 + 구현
public class Bird extends Animal implements Flyable {
    @Override
    public void fly() {
        System.out.println("날아간다");
    }
}
```

---

## 5. 인터페이스의 진화 (Java 8+)

### static 메서드 (Java 8)

**배경:**
- Java 8 이전: 인터페이스 관련 유틸리티는 별도 클래스에 작성
- 예: `Collections` 클래스 (Collection 인터페이스의 유틸리티)

**개선:**

```java
public interface Calculator {
    int calculate(int a, int b);

    // static 메서드
    static void printInfo() {
        System.out.println("계산기 인터페이스입니다.");
    }

    static int add(int a, int b) {
        return a + b;
    }
}
```

**사용:**

```java
public class Main {
    public static void main(String[] args) {
        Calculator.printInfo();  // 인터페이스명.메서드명()
        int result = Calculator.add(5, 3);
        System.out.println(result);  // 8
    }
}
```

### default 메서드 (Java 8)

**문제 상황:**

```java
public interface Parent {
    void method();
}

public class Child1 implements Parent {
    @Override
    public void method() {
        System.out.println("Child1");
    }
}

public class Child2 implements Parent {
    @Override
    public void method() {
        System.out.println("Child2");
    }
}
```

**인터페이스에 메서드 추가 시:**

```java
public interface Parent {
    void method();
    void newMethod();  // ❌ 모든 구현 클래스에 컴파일 에러!
}
```

**해결책: default 메서드**

```java
public interface Parent {
    void method();

    // default 메서드 - 구현 제공
    default void newMethod() {
        System.out.println("기본 구현");
    }
}
```

**특징:**
- 구현 클래스는 선택적으로 오버라이딩
- 기존 구현 클래스 수정 불필요

```java
public class Child1 implements Parent {
    @Override
    public void method() {
        System.out.println("Child1");
    }
    // newMethod()는 오버라이딩 안해도 됨
}

public class Child2 implements Parent {
    @Override
    public void method() {
        System.out.println("Child2");
    }

    @Override
    public void newMethod() {  // 필요하면 오버라이딩
        System.out.println("Child2의 새로운 구현");
    }
}
```

### private 메서드 (Java 9)

**문제: default/static 메서드의 코드 중복**

```java
public interface Logger {
    default void logInfo(String message) {
        System.out.println("[INFO] " + message);
        System.out.println("시간: " + System.currentTimeMillis());
    }

    default void logError(String message) {
        System.out.println("[ERROR] " + message);
        System.out.println("시간: " + System.currentTimeMillis());  // 중복!
    }
}
```

**해결: private 메서드**

```java
public interface Logger {
    default void logInfo(String message) {
        log("INFO", message);
    }

    default void logError(String message) {
        log("ERROR", message);
    }

    // private 메서드로 중복 제거
    private void log(String level, String message) {
        System.out.println("[" + level + "] " + message);
        System.out.println("시간: " + System.currentTimeMillis());
    }
}
```

---

## 6. 추상 클래스 vs 인터페이스

### 비교표

| 구분 | 추상 클래스 | 인터페이스 |
|------|----------|----------|
| **키워드** | `abstract class` | `interface` |
| **목적** | 공통 속성/메서드 제공 (일부 추상화) | 기능 명세 (완전 추상화) |
| **관계** | is-a (상속 계층) | can-do (기능 규약) |
| **필드** | 일반 필드 가능 | 상수만 가능 |
| **생성자** | 가능 | 불가능 |
| **메서드** | 추상 + 일반 메서드 | 추상 + default + static + private |
| **다중 상속/구현** | ❌ 단일 상속만 | ✅ 다중 구현 가능 |
| **접근 제어자** | 자유롭게 사용 | 기본적으로 public |

### 설계 관점 비교

**추상 클래스:**
- "미완성된 클래스"
- 상속 계층 내 **공통 구조** 제공
- 필드와 생성자로 **상태** 관리 가능

**인터페이스:**
- "기능 명세서"
- 다양한 구현체를 하나의 타입으로 다루기 위한 **규약**
- 상태 없이 **행위**만 정의

### 선택 가이드

**추상 클래스를 사용할 때:**
```java
// 공통 속성과 일부 구현이 있는 경우
public abstract class Animal {
    protected String name;  // 공통 속성
    protected int age;

    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 공통 구현
    public void sleep() {
        System.out.println(name + "이(가) 잡니다.");
    }

    // 추상 메서드
    public abstract void makeSound();
}
```

**인터페이스를 사용할 때:**
```java
// 능력/기능을 정의하는 경우
public interface Flyable {
    void fly();
}

public interface Swimmable {
    void swim();
}

// 다중 구현으로 여러 능력 조합
public class Duck extends Animal implements Flyable, Swimmable {
    public Duck(String name, int age) {
        super(name, age);
    }

    @Override
    public void makeSound() {
        System.out.println("꽥꽥!");
    }

    @Override
    public void fly() {
        System.out.println("날아갑니다.");
    }

    @Override
    public void swim() {
        System.out.println("헤엄칩니다.");
    }
}
```

### JavaScript와의 비교

```javascript
// JavaScript는 인터페이스 문법 없음
// TypeScript는 interface 지원

// TypeScript 예시
interface Drawable {
    draw(): void;
}

interface Movable {
    move(): void;
}

class GameCharacter implements Drawable, Movable {
    draw(): void {
        console.log("그립니다");
    }

    move(): void {
        console.log("이동합니다");
    }
}
```

---

## 7. 실습 문제

### 문제 1: 도형 시스템 (추상 클래스)

다음 요구사항에 맞게 추상 클래스를 활용하세요.

**요구사항:**
- `Shape` 추상 클래스:
  - 필드: name (도형 이름)
  - 생성자: name 초기화
  - 추상 메서드: `calculateArea()`, `calculatePerimeter()`
  - 일반 메서드: `printInfo()` - 이름, 면적, 둘레 출력
- `Circle`, `Rectangle` 클래스: Shape 상속

**테스트 코드:**
```java
public class Main {
    public static void main(String[] args) {
        Shape[] shapes = {
            new Circle("원", 5),
            new Rectangle("사각형", 10, 20)
        };

        for (Shape shape : shapes) {
            shape.printInfo();
        }
    }
}
```

**예상 출력:**
```
[원] 면적: 78.5, 둘레: 31.4
[사각형] 면적: 200.0, 둘레: 60.0
```

<details>
<summary>해답</summary>

**Shape.java**
```java
public abstract class Shape {
    protected String name;

    public Shape(String name) {
        this.name = name;
    }

    public abstract double calculateArea();
    public abstract double calculatePerimeter();

    public void printInfo() {
        System.out.printf("[%s] 면적: %.1f, 둘레: %.1f\n", name, calculateArea(), calculatePerimeter());
    }
}
```

**Circle.java**
```java
public class Circle extends Shape {
    private int radius;

    public Circle(String name, int radius) {
        super(name);
        this.radius = radius;
    }

    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }

    @Override
    public double calculatePerimeter() {
        return 2 * Math.PI * radius;
    }
}
```

**Rectangle.java**
```java
public class Rectangle extends Shape {
    private int width;
    private int height;

    public Rectangle(String name, int width, int height) {
        super(name);
        this.width = width;
        this.height = height;
    }

    @Override
    public double calculateArea() {
        return width * height;
    }

    @Override
    public double calculatePerimeter() {
        return 2 * (width + height);
    }
}
```
</details>

### 문제 2: 동물 시스템 (인터페이스 + 추상 클래스)

다음 요구사항에 맞게 구현하세요.

**요구사항:**
- `Flyable` 인터페이스: `fly()` 메서드
- `Swimmable` 인터페이스: `swim()` 메서드
- `Animal` 추상 클래스:
  - 필드: name
  - 추상 메서드: `makeSound()`
- 구체 클래스:
  - `Duck`: Animal 상속, Flyable + Swimmable 구현
  - `Fish`: Animal 상속, Swimmable 구현
  - `Bird`: Animal 상속, Flyable 구현

**테스트 코드:**
```java
public class Main {
    public static void main(String[] args) {
        Duck duck = new Duck("오리");
        duck.makeSound();
        duck.fly();
        duck.swim();
    }
}
```

<details>
<summary>해답</summary>

**Flyable.java**
```java
public interface Flyable {
    void fly();
}
```

**Swimmable.java**
```java
public interface Swimmable {
    void swim();
}
```

**Animal.java**
```java
public abstract class Animal {
    protected String name;

    public Animal(String name) {
        this.name = name;
    }

    public abstract void makeSound();
}
```

**Duck.java**
```java
public class Duck extends Animal implements Flyable, Swimmable {
    public Duck(String name) {
        super(name);
    }

    @Override
    public void makeSound() {
        System.out.println("꽥꽥!");
    }

    @Override
    public void fly() {
        System.out.println("오리가 날아갑니다.");
    }

    @Override
    public void swim() {
        System.out.println("오리가 헤엄칩니다.");
    }
}
```

**Fish.java**
```java
public class Fish extends Animal implements Swimmable {
    public Fish(String name) {
        super(name);
    }

    @Override
    public void makeSound() {
        System.out.println("뻐끔뻐끔");
    }

    @Override
    public void swim() {
        System.out.println("물고기가 헤엄칩니다.");
    }
}
```

**Bird.java**
```java
public class Bird extends Animal implements Flyable {
    public Bird(String name) {
        super(name);
    }

    @Override
    public void makeSound() {
        System.out.println("짹짹");
    }

    @Override
    public void fly() {
        System.out.println("새가 날아갑니다.");
    }
}
```
</details>

### 문제 3: 도서관 시스템

다음 요구사항에 맞게 인터페이스와 추상 클래스를 조합하세요.

**요구사항:**
- `Borrowable` 인터페이스:
  - `borrow()`: 대출
  - `returnItem()`: 반납
  - `isAvailable()`: 대출 가능 여부
- `Downloadable` 인터페이스:
  - `download()`: 다운로드
- `LibraryItem` 추상 클래스:
  - 필드: title, id, available
  - 생성자, getter
  - 추상 메서드: `getItemType()`
- 구체 클래스:
  - `Book`: LibraryItem 상속, Borrowable 구현
  - `DVD`: LibraryItem 상속, Borrowable 구현
  - `EBook`: LibraryItem 상속, Borrowable + Downloadable 구현

**추가 요구사항:**
- Book과 DVD는 물리적 위치(location) 필드 추가
- EBook은 파일 크기(fileSize) 필드 추가

<details>
<summary>해답</summary>

**Borrowable.java**
```java
public interface Borrowable {
    void borrow();
    void returnItem();
    boolean isAvailable();
}
```

**Downloadable.java**
```java
public interface Downloadable {
    void download();
}
```

**LibraryItem.java**
```java
public abstract class LibraryItem {
    protected String title;
    protected String id;
    protected boolean available;

    public LibraryItem(String title, String id) {
        this.title = title;
        this.id = id;
        this.available = true;
    }

    public String getTitle() {
        return title;
    }

    public String getId() {
        return id;
    }

    public abstract String getItemType();
}
```

**Book.java**
```java
public class Book extends LibraryItem implements Borrowable {
    private String location;

    public Book(String title, String id, String location) {
        super(title, id);
        this.location = location;
    }

    @Override
    public String getItemType() {
        return "도서";
    }

    @Override
    public void borrow() {
        this.available = false;
        System.out.println("\"" + title + "\"이(가) 대출되었습니다.");
    }

    @Override
    public void returnItem() {
        this.available = true;
        System.out.println("\"" + title + "\"이(가) 반납되었습니다.");
    }

    @Override
    public boolean isAvailable() {
        return available;
    }
}
```

**EBook.java**
```java
public class EBook extends LibraryItem implements Borrowable, Downloadable {
    private double fileSize;

    public EBook(String title, String id, double fileSize) {
        super(title, id);
        this.fileSize = fileSize;
    }

    @Override
    public String getItemType() {
        return "전자책";
    }

    @Override
    public void borrow() {
        this.available = false;
        System.out.println("\"" + title + "\"이(가) 대출되었습니다.");
    }

    @Override
    public void returnItem() {
        this.available = true;
        System.out.println("\"" + title + "\"이(가) 반납되었습니다.");
    }

    @Override
    public boolean isAvailable() {
        return available;
    }

    @Override
    public void download() {
        System.out.println("\"" + title + "\"을(를) 다운로드합니다.");
    }
}
```
</details>

### 문제 4: default 메서드 활용

다음 인터페이스를 작성하고 활용하세요.

**요구사항:**
- `Printable` 인터페이스:
  - 추상 메서드: `String getContent()`
  - default 메서드: `printWithBorder()` - 내용을 테두리와 함께 출력
  - static 메서드: `printSeparator()` - 구분선 출력
  - private 메서드: `createBorder(int length)` - 테두리 생성

**테스트 코드:**
```java
public class Document implements Printable {
    private String content;

    public Document(String content) {
        this.content = content;
    }

    @Override
    public String getContent() {
        return content;
    }
}

public class Main {
    public static void main(String[] args) {
        Document doc = new Document("Hello, World!");
        doc.printWithBorder();
        Printable.printSeparator();
    }
}
```

**예상 출력:**
```
====================
Hello, World!
====================
--------------------
```

<details>
<summary>해답</summary>

```java
public interface Printable {
    String getContent();

    default void printWithBorder() {
        String content = getContent();
        String border = createBorder(content.length());
        System.out.println(border);
        System.out.println(content);
        System.out.println(border);
    }

    static void printSeparator() {
        System.out.println("--------------------");
    }

    private String createBorder(int length) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < length + 4; i++) {
            sb.append("=");
        }
        return sb.toString();
    }
}
```
</details>

---

## 요약

| 개념 | 설명 |
|------|------|
| **추상화** | 세부 내용은 가리고 중요한 것만 드러냄 |
| **추상 클래스** | 미완성 클래스, 일부 구현 제공 |
| **인터페이스** | 기능 명세서, 완전 추상화 |
| **추상 메서드** | 구현부 없는 메서드 |
| **default 메서드** | 인터페이스의 구현 메서드 (Java 8+) |
| **static 메서드** | 인터페이스의 정적 메서드 (Java 8+) |
| **private 메서드** | 인터페이스 내부 메서드 (Java 9+) |

**사용 가이드:**
- **추상 클래스**: 공통 속성 + 일부 구현 필요 시
- **인터페이스**: 능력/기능 정의, 다중 구현 필요 시

**Java vs JavaScript:**
- Java: 추상 클래스, 인터페이스 문법 지원
- JavaScript: 추상 클래스 없음, TypeScript에서 interface 지원

**다음 학습:**
- 5.4장에서 컴포지션을 통한 상속의 한계 극복 학습

```