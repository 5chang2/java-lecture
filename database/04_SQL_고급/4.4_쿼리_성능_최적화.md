# 4.4. 쿼리 성능 최적화

> EXPLAIN을 활용하여 쿼리 실행 계획을 분석하고 성능을 최적화할 수 있다.

---

## 실습 준비

이 섹션에서는 **world와 sakila 데이터베이스**를 사용합니다.

```sql
USE world;
```

---

## 1. 쿼리 성능 최적화란?

**쿼리 성능 최적화**는 SQL 쿼리가 **더 빠르고 효율적으로** 실행되도록 개선하는 과정입니다.

### 1.1. 왜 최적화가 필요한가?

```
같은 결과, 다른 성능

❌ 느린 쿼리: 10초 소요 → 사용자 이탈, 서버 부하
✅ 빠른 쿼리: 0.01초 소요 → 좋은 사용자 경험
```

**최적화 대상:**
- 자주 실행되는 쿼리
- 대용량 데이터를 다루는 쿼리
- 응답 시간이 중요한 쿼리

---

## 2. EXPLAIN 상세 분석

`EXPLAIN`은 MySQL이 쿼리를 **어떻게 실행할 계획인지** 보여줍니다.

### 2.1. EXPLAIN 기본 사용

```sql
EXPLAIN SELECT * FROM city WHERE CountryCode = 'KOR';
```

**결과 컬럼:**
```
+----+-------------+-------+------+---------------+------+---------+-------+------+-------+
| id | select_type | table | type | possible_keys | key  | key_len | ref   | rows | Extra |
+----+-------------+-------+------+---------------+------+---------+-------+------+-------+
```

### 2.2. 주요 컬럼 설명

#### **id**
- 쿼리 내 SELECT 문의 순서
- 숫자가 클수록 먼저 실행
- 같은 숫자는 위에서 아래로 실행

#### **select_type**
| 값 | 의미 |
|----|------|
| SIMPLE | 단순 SELECT (서브쿼리, UNION 없음) |
| PRIMARY | 가장 바깥쪽 SELECT |
| SUBQUERY | 서브쿼리 |
| DERIVED | FROM 절의 서브쿼리 (파생 테이블) |
| UNION | UNION의 두 번째 이후 SELECT |

#### **type** ⭐ 가장 중요!
성능 순서 (좋음 → 나쁨):

| type | 설명 | 성능 |
|------|------|------|
| **system** | 테이블에 행이 1개 | ⚡⚡⚡ 최고 |
| **const** | PRIMARY KEY/UNIQUE로 조회 (1개 행) | ⚡⚡⚡ |
| **eq_ref** | JOIN에서 PRIMARY KEY/UNIQUE 사용 | ⚡⚡ |
| **ref** | 일반 인덱스로 조회 | ⚡⚡ |
| **range** | 범위 검색 (>, <, BETWEEN) | ⚡ |
| **index** | 인덱스 전체 스캔 | 🐢 |
| **ALL** | 테이블 전체 스캔 | 🐢🐢 최악 |

#### **possible_keys**
- 사용 가능한 인덱스 목록
- NULL이면 사용 가능한 인덱스 없음

#### **key**
- 실제로 사용된 인덱스
- NULL이면 인덱스 미사용

#### **key_len**
- 사용된 인덱스의 길이 (바이트)
- 복합 인덱스에서 몇 개 컬럼을 사용했는지 확인 가능

#### **ref**
- 인덱스와 비교되는 값
- const, 컬럼명, func 등

#### **rows** ⭐
- 검사할 것으로 예상되는 행 수
- 실제 결과가 아닌 **예상 값**
- 이 값이 클수록 느림

#### **Extra**
| 값 | 의미 |
|----|------|
| Using index | 커버링 인덱스 (인덱스만으로 조회) ✅ |
| Using where | WHERE 절로 필터링 |
| Using filesort | 파일 정렬 (느림) ⚠️ |
| Using temporary | 임시 테이블 사용 (느림) ⚠️ |
| Using index condition | 인덱스 조건 푸시다운 |

---

## 3. 쿼리 최적화 기법

### 3.1. SELECT *  피하기

```sql
-- ❌ 나쁨: 불필요한 컬럼까지 모두 조회
SELECT * FROM city WHERE CountryCode = 'KOR';

-- ✅ 좋음: 필요한 컬럼만 조회
SELECT Name, Population FROM city WHERE CountryCode = 'KOR';
```

**이유:**
- 네트워크 전송량 감소
- 메모리 사용량 감소
- 커버링 인덱스 활용 가능

### 3.2. WHERE 절 최적화

#### 인덱스 컬럼에 함수 사용 금지

```sql
-- ❌ 나쁨: 함수 사용 시 인덱스 무효화
SELECT * FROM city WHERE UPPER(Name) = 'SEOUL';

-- ✅ 좋음: 컬럼 그대로 사용
SELECT * FROM city WHERE Name = 'Seoul';
```

#### 데이터 타입 일치

```sql
-- ❌ 나쁨: 타입 불일치 (CountryCode는 CHAR)
SELECT * FROM city WHERE CountryCode = 100;

-- ✅ 좋음: 타입 일치
SELECT * FROM city WHERE CountryCode = 'KOR';
```

#### OR 대신 IN 사용

```sql
-- ❌ 느림: OR 여러 개
SELECT * FROM city
WHERE CountryCode = 'KOR' OR CountryCode = 'JPN' OR CountryCode = 'CHN';

-- ✅ 빠름: IN 사용
SELECT * FROM city
WHERE CountryCode IN ('KOR', 'JPN', 'CHN');
```

### 3.3. JOIN 최적화

#### 작은 테이블을 먼저

```sql
-- 작은 테이블(country)을 FROM에, 큰 테이블(city)을 JOIN에
SELECT ci.Name, co.Name
FROM country co
INNER JOIN city ci ON co.Code = ci.CountryCode
WHERE co.Continent = 'Asia'
LIMIT 100;
```

#### JOIN 조건에 인덱스

```sql
-- JOIN 조건의 컬럼에 인덱스 필수
-- city.CountryCode, country.Code에 인덱스 있어야 함
```

### 3.4. LIMIT 활용

```sql
-- ❌ 나쁨: 전체 조회 후 클라이언트에서 10개만 사용
SELECT * FROM city ORDER BY Population DESC;

-- ✅ 좋음: 데이터베이스에서 10개만 조회
SELECT * FROM city ORDER BY Population DESC LIMIT 10;
```

### 3.5. 서브쿼리 vs JOIN

```sql
-- 서브쿼리 (느릴 수 있음)
SELECT *
FROM city
WHERE CountryCode IN (
    SELECT Code FROM country WHERE Continent = 'Asia'
);

-- JOIN (일반적으로 빠름)
SELECT ci.*
FROM city ci
INNER JOIN country co ON ci.CountryCode = co.Code
WHERE co.Continent = 'Asia';
```

**권장:** 성능 테스트 후 선택

### 3.6. EXISTS vs IN

```sql
-- IN (전체 결과 생성)
SELECT *
FROM country co
WHERE co.Code IN (
    SELECT DISTINCT CountryCode FROM city
);

-- EXISTS (존재만 확인, 빠름)
SELECT *
FROM country co
WHERE EXISTS (
    SELECT 1 FROM city ci WHERE ci.CountryCode = co.Code
);
```

**권장:** 대용량 데이터에서는 EXISTS

---

## 4. 인덱스 최적화

### 4.1. 커버링 인덱스 (Covering Index)

쿼리에 필요한 모든 컬럼이 **인덱스에만** 있는 경우

```sql
-- 인덱스 생성: (CountryCode, Name, Population)
CREATE INDEX idx_covering ON city(CountryCode, Name, Population);

-- 커버링 인덱스 활용
SELECT Name, Population
FROM city
WHERE CountryCode = 'KOR';
```

**EXPLAIN 결과:**
- `Extra: Using index` ✅ (테이블 접근 없이 인덱스만 사용)

### 4.2. 복합 인덱스 순서

```sql
-- WHERE CountryCode = ? AND Population > ? 쿼리가 많다면
-- ✅ 좋음: 조건이 많은 컬럼을 앞에
CREATE INDEX idx_country_pop ON city(CountryCode, Population);

-- ❌ 나쁨: 순서가 반대
CREATE INDEX idx_pop_country ON city(Population, CountryCode);
```

**규칙:**
1. `=` 조건 컬럼을 앞에
2. 범위 조건(`>`, `<`) 컬럼을 뒤에
3. 자주 사용하는 컬럼을 앞에

### 4.3. 불필요한 인덱스 제거

```sql
-- 중복 인덱스 확인
SHOW INDEX FROM city;

-- 사용되지 않는 인덱스 삭제
DROP INDEX idx_unused ON city;
```

---

## 5. 쿼리 성능 측정

### 5.1. 실행 시간 측정

```sql
-- 프로파일링 활성화
SET profiling = 1;

-- 쿼리 실행
SELECT * FROM city WHERE CountryCode = 'KOR';

-- 결과 확인
SHOW PROFILES;
```

**결과:**
```
+----------+------------+----------------------------------------------+
| Query_ID | Duration   | Query                                        |
+----------+------------+----------------------------------------------+
|        1 | 0.00123400 | SELECT * FROM city WHERE CountryCode = 'KOR' |
+----------+------------+----------------------------------------------+
```

### 5.2. 상세 분석

```sql
-- 특정 쿼리의 상세 정보
SHOW PROFILE FOR QUERY 1;
```

---

## 6. 피해야 할 패턴

### 6.1. SELECT DISTINCT 남용

```sql
-- ❌ 나쁨: DISTINCT는 정렬 필요 (느림)
SELECT DISTINCT CountryCode FROM city;

-- ✅ 좋음: GROUP BY 사용 (인덱스 활용 가능)
SELECT CountryCode FROM city GROUP BY CountryCode;
```

### 6.2. LIKE '%keyword%'

```sql
-- ❌ 나쁨: 앞뒤 와일드카드 (인덱스 무효화)
SELECT * FROM city WHERE Name LIKE '%Seoul%';

-- ✅ 좋음: 앞쪽만 고정 (인덱스 사용 가능)
SELECT * FROM city WHERE Name LIKE 'Seoul%';
```

### 6.3. 과도한 JOIN

```sql
-- ❌ 나쁨: 5개 이상 JOIN (복잡하고 느림)
SELECT ...
FROM table1
JOIN table2 ON ...
JOIN table3 ON ...
JOIN table4 ON ...
JOIN table5 ON ...
JOIN table6 ON ...;

-- ✅ 좋음: 필요한 것만 JOIN
-- 또는 뷰(View)나 임시 테이블로 단계 분리
```

---

## 실습 문제

이제 **sakila 데이터베이스**로 실습해봅시다.

```sql
USE sakila;
```

### 문제 1: EXPLAIN 분석

다음 쿼리를 EXPLAIN으로 분석하세요.

```sql
EXPLAIN SELECT *
FROM film
WHERE title = 'ACADEMY DINOSAUR';
```

**질문:**
1. type은 무엇인가?
2. key는 무엇인가?
3. rows는 몇 개인가?

### 문제 2: 최적화 전후 비교

```sql
-- 1단계: 최적화 전 (SELECT *)
EXPLAIN SELECT *
FROM film
WHERE release_year = 2006;

-- 2단계: 최적화 후 (필요한 컬럼만)
EXPLAIN SELECT title, rental_rate
FROM film
WHERE release_year = 2006;
```

**질문:** 성능 차이가 있는가?

### 문제 3: JOIN 최적화

다음 쿼리를 최적화하세요.

```sql
-- 원본 쿼리
SELECT *
FROM film f, film_category fc, category c
WHERE f.film_id = fc.film_id
  AND fc.category_id = c.category_id
  AND c.name = 'Action';
```

**힌트:** 명시적 JOIN 사용, SELECT * 제거

**예상 답:**
```sql
SELECT f.title, f.rental_rate
FROM film f
INNER JOIN film_category fc ON f.film_id = fc.film_id
INNER JOIN category c ON fc.category_id = c.category_id
WHERE c.name = 'Action';
```

### 문제 4: 인덱스 활용

`payment` 테이블에서 고객별 총 지불 금액을 조회하는 쿼리를 작성하고 최적화하세요.

**예상 답:**
```sql
-- 인덱스 확인
SHOW INDEX FROM payment;

-- 최적화된 쿼리
SELECT
    customer_id,
    SUM(amount) AS total_amount
FROM payment
GROUP BY customer_id
ORDER BY total_amount DESC
LIMIT 10;

-- EXPLAIN으로 확인
EXPLAIN SELECT ...;
```

### 문제 5: 서브쿼리 vs JOIN

다음 두 쿼리의 성능을 비교하세요.

```sql
-- 서브쿼리 방식
EXPLAIN SELECT title
FROM film
WHERE film_id IN (
    SELECT film_id FROM film_category WHERE category_id = 1
);

-- JOIN 방식
EXPLAIN SELECT f.title
FROM film f
INNER JOIN film_category fc ON f.film_id = fc.film_id
WHERE fc.category_id = 1;
```

**질문:** 어느 것이 더 효율적인가?

---

## 강사 가이드

### 데이터베이스 활용 전략

1. **world DB (개념 설명)**
   - EXPLAIN 컬럼별 의미
   - type별 성능 차이 시연
   - 최적화 전후 비교

2. **sakila DB (실습 문제)**
   - film, payment, rental 테이블 활용
   - JOIN 최적화
   - 인덱스 활용 패턴

3. **수업 진행 흐름**
   ```
   1. 성능 최적화 필요성
   2. EXPLAIN 상세 분석
   3. 쿼리 최적화 기법
   4. 인덱스 최적화
   5. 피해야 할 패턴
   6. sakila 실습
   ```

### 핵심 포인트

1. **EXPLAIN은 필수**: 모든 중요 쿼리에 EXPLAIN 실행
2. **type 컬럼 주목**: ALL → ref로 개선이 목표
3. **rows 줄이기**: 검사 행 수가 성능의 핵심
4. **SELECT * 금지**: 필요한 컬럼만 조회
5. **인덱스 컬럼 보호**: 함수, 연산 금지
6. **커버링 인덱스**: Extra에 "Using index" 나오도록

### 자주 하는 질문

**Q: EXPLAIN과 실제 성능이 다른데요?**
A: EXPLAIN은 예상치입니다. 실제 성능은 SHOW PROFILES나 쿼리 실행 시간으로 측정하세요.

**Q: 인덱스를 만들었는데 사용 안 되는 이유는?**
A: 테이블이 너무 작거나, 조건이 많은 행을 반환하면 Full Scan이 더 빠를 수 있습니다.

**Q: 서브쿼리와 JOIN 중 어느 것이 항상 빠른가요?**
A: 상황에 따라 다릅니다. 두 방법을 모두 시도하고 EXPLAIN으로 비교하세요.

**Q: 복합 인덱스에서 두 번째 컬럼만 사용하면?**
A: 인덱스가 사용되지 않습니다. 첫 번째 컬럼부터 순서대로 사용해야 합니다.

**Q: filesort가 항상 나쁜가요?**
A: 작은 데이터에서는 괜찮지만, 대용량에서는 ORDER BY 컬럼에 인덱스를 만들어 filesort를 피해야 합니다.

### 실습 진행 팁

1. **성능 체감**: 큰 테이블에서 최적화 전후 비교
2. **EXPLAIN 해석 연습**: type, rows, Extra 중심
3. **최적화 게임**: 느린 쿼리를 빠르게 개선하는 미션
4. **실수 체험**: SELECT *, 함수 사용 등의 영향 확인
5. **실시간 비교**: 학생들이 직접 최적화 전후 측정

### 시연 예시

```sql
-- 1. 최적화 전
EXPLAIN SELECT *
FROM city
WHERE UPPER(Name) = 'SEOUL';
-- type: ALL, rows: 4079 (느림)

-- 2. 최적화 후
CREATE INDEX idx_name ON city(Name);

EXPLAIN SELECT Name, Population
FROM city
WHERE Name = 'Seoul';
-- type: ref, rows: 1, Extra: Using index (빠름)
```

---

## 요약

- **성능 최적화**: 쿼리를 더 빠르고 효율적으로 개선
- **EXPLAIN**: 쿼리 실행 계획 분석
  - **type**: 성능의 핵심 지표 (ALL → ref로 개선)
  - **rows**: 검사 예상 행 수 (작을수록 좋음)
  - **key**: 사용된 인덱스
  - **Extra**: 추가 정보 (Using index = 좋음)
- **최적화 기법**:
  - SELECT * 피하기
  - WHERE 절에 함수 사용 금지
  - 데이터 타입 일치
  - OR 대신 IN
  - LIMIT 활용
  - EXISTS > IN (대용량)
- **인덱스 최적화**:
  - 커버링 인덱스 활용
  - 복합 인덱스 순서 고려
  - 불필요한 인덱스 제거
- **피해야 할 패턴**:
  - SELECT DISTINCT 남용
  - LIKE '%...%'
  - 과도한 JOIN
  - 인덱스 컬럼에 함수 사용
- **성능 측정**:
  - SET profiling = 1
  - SHOW PROFILES
  - SHOW PROFILE FOR QUERY

**다음 단계**: 뷰(View)를 배워 복잡한 쿼리를 단순화합니다!
