# 4.7. 실습: SQL 고급 종합 프로젝트

## 학습 목표
- JOIN, 서브쿼리, 인덱스, 뷰, 저장 프로시저를 종합적으로 활용한다
- 실무 시나리오 기반의 복합 문제를 해결한다
- 성능 최적화를 고려한 쿼리를 작성한다
- 데이터베이스 설계부터 구현까지 전체 과정을 경험한다

---

## 프로젝트 개요

이번 실습에서는 **영화 대여점 관리 시스템(sakila DB)**을 활용하여 실무에서 자주 마주치는 복합적인 SQL 문제들을 해결합니다.

각 미션은 4장에서 학습한 여러 개념을 통합적으로 활용해야 하며, 단계별로 난이도가 증가합니다.

---

## Mission 1: 데이터 분석 대시보드 (난이도: ⭐⭐)

### 시나리오
경영진이 요청한 주요 KPI(핵심 성과 지표)를 한눈에 볼 수 있는 뷰를 생성하세요.

### 요구사항

**1-1. 전체 비즈니스 요약 뷰 생성**

`business_summary` 뷰를 생성하여 다음 정보를 제공하세요:
- 전체 고객 수
- 전체 영화 수
- 총 대여 건수
- 총 매출액
- 평균 대여 가격

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
CREATE VIEW business_summary AS
SELECT
    (SELECT COUNT(*) FROM customer) AS total_customers,
    (SELECT COUNT(*) FROM film) AS total_films,
    (SELECT COUNT(*) FROM rental) AS total_rentals,
    (SELECT ROUND(SUM(amount), 2) FROM payment) AS total_revenue,
    (SELECT ROUND(AVG(rental_rate), 2) FROM film) AS avg_rental_rate;

-- 확인
SELECT * FROM business_summary;
```
</details>

---

**1-2. 월별 매출 추이 뷰 생성**

`monthly_revenue` 뷰를 생성하여 월별 매출 정보를 제공하세요:
- 연도
- 월
- 해당 월 매출액
- 대여 건수

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
CREATE VIEW monthly_revenue AS
SELECT
    YEAR(payment_date) AS year,
    MONTH(payment_date) AS month,
    ROUND(SUM(amount), 2) AS revenue,
    COUNT(DISTINCT rental_id) AS rental_count
FROM payment
GROUP BY YEAR(payment_date), MONTH(payment_date)
ORDER BY year, month;

-- 확인
SELECT * FROM monthly_revenue;
```
</details>

---

**1-3. 성과 지표 조회 프로시저**

월과 연도를 입력받아 해당 월의 성과를 조회하는 프로시저 `get_monthly_performance`를 작성하세요.

**출력:**
- 해당 월 매출
- 전월 대비 증감률 (%)
- 해당 월 신규 고객 수

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
DELIMITER $$

CREATE PROCEDURE get_monthly_performance(
    IN p_year INT,
    IN p_month INT
)
BEGIN
    DECLARE current_revenue DECIMAL(10,2);
    DECLARE previous_revenue DECIMAL(10,2);
    DECLARE growth_rate DECIMAL(5,2);
    DECLARE new_customers INT;
    DECLARE prev_month INT;
    DECLARE prev_year INT;

    -- 전월 계산
    IF p_month = 1 THEN
        SET prev_month = 12;
        SET prev_year = p_year - 1;
    ELSE
        SET prev_month = p_month - 1;
        SET prev_year = p_year;
    END IF;

    -- 현재 월 매출
    SELECT COALESCE(SUM(amount), 0)
    INTO current_revenue
    FROM payment
    WHERE YEAR(payment_date) = p_year AND MONTH(payment_date) = p_month;

    -- 전월 매출
    SELECT COALESCE(SUM(amount), 0)
    INTO previous_revenue
    FROM payment
    WHERE YEAR(payment_date) = prev_year AND MONTH(payment_date) = prev_month;

    -- 증감률 계산
    IF previous_revenue > 0 THEN
        SET growth_rate = ((current_revenue - previous_revenue) / previous_revenue) * 100;
    ELSE
        SET growth_rate = 0;
    END IF;

    -- 신규 고객 수
    SELECT COUNT(*)
    INTO new_customers
    FROM customer
    WHERE YEAR(create_date) = p_year AND MONTH(create_date) = p_month;

    -- 결과 출력
    SELECT
        p_year AS '연도',
        p_month AS '월',
        current_revenue AS '매출',
        ROUND(growth_rate, 2) AS '전월대비_증감률(%)',
        new_customers AS '신규_고객수';
END$$

DELIMITER ;

-- 사용 예시
CALL get_monthly_performance(2005, 7);
```
</details>

---

## Mission 2: 고객 분석 및 세그멘테이션 (난이도: ⭐⭐⭐)

### 시나리오
마케팅 팀이 고객을 등급별로 분류하여 맞춤형 프로모션을 진행하려고 합니다.

### 요구사항

**2-1. VIP 고객 식별 뷰**

다음 조건을 만족하는 VIP 고객 목록 뷰 `vip_customers`를 생성하세요:
- 총 결제 금액이 상위 10%에 해당
- 대여 횟수가 20회 이상

**결과 컬럼:**
- customer_id
- customer_name (성 + 이름)
- email
- total_spent (총 결제 금액)
- rental_count (대여 횟수)
- avg_payment (평균 결제 금액)

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
CREATE VIEW vip_customers AS
SELECT
    c.customer_id,
    CONCAT(c.last_name, ' ', c.first_name) AS customer_name,
    c.email,
    ROUND(SUM(p.amount), 2) AS total_spent,
    COUNT(r.rental_id) AS rental_count,
    ROUND(AVG(p.amount), 2) AS avg_payment
FROM customer c
LEFT JOIN rental r ON c.customer_id = r.customer_id
LEFT JOIN payment p ON r.rental_id = p.rental_id
GROUP BY c.customer_id, c.last_name, c.first_name, c.email
HAVING
    total_spent >= (
        SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY total)
        FROM (
            SELECT SUM(amount) AS total
            FROM payment
            GROUP BY customer_id
        ) AS customer_totals
    )
    AND rental_count >= 20
ORDER BY total_spent DESC;

-- MySQL에서 PERCENTILE_CONT를 지원하지 않는 경우 대안:
CREATE VIEW vip_customers AS
WITH customer_stats AS (
    SELECT
        c.customer_id,
        CONCAT(c.last_name, ' ', c.first_name) AS customer_name,
        c.email,
        ROUND(SUM(p.amount), 2) AS total_spent,
        COUNT(r.rental_id) AS rental_count,
        ROUND(AVG(p.amount), 2) AS avg_payment
    FROM customer c
    LEFT JOIN rental r ON c.customer_id = r.customer_id
    LEFT JOIN payment p ON r.rental_id = p.rental_id
    GROUP BY c.customer_id, c.last_name, c.first_name, c.email
)
SELECT *
FROM customer_stats
WHERE total_spent >= (
    SELECT total_spent
    FROM customer_stats
    ORDER BY total_spent DESC
    LIMIT 1 OFFSET (SELECT FLOOR(COUNT(*) * 0.1) FROM customer_stats)
)
AND rental_count >= 20
ORDER BY total_spent DESC;

-- 확인
SELECT * FROM vip_customers;
```
</details>

---

**2-2. 고객 세그멘테이션 프로시저**

모든 고객을 다음 4개 등급으로 분류하는 프로시저 `segment_customers`를 작성하세요:
- **VIP**: 총 결제액 $150 이상
- **Gold**: 총 결제액 $100-$149
- **Silver**: 총 결제액 $50-$99
- **Bronze**: 총 결제액 $50 미만

**결과를 임시 테이블 `customer_segments`에 저장하고 조회**

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
DELIMITER $$

CREATE PROCEDURE segment_customers()
BEGIN
    -- 기존 임시 테이블 삭제
    DROP TEMPORARY TABLE IF EXISTS customer_segments;

    -- 임시 테이블 생성 및 데이터 삽입
    CREATE TEMPORARY TABLE customer_segments AS
    SELECT
        c.customer_id,
        CONCAT(c.last_name, ' ', c.first_name) AS customer_name,
        c.email,
        COALESCE(SUM(p.amount), 0) AS total_spent,
        CASE
            WHEN COALESCE(SUM(p.amount), 0) >= 150 THEN 'VIP'
            WHEN COALESCE(SUM(p.amount), 0) >= 100 THEN 'Gold'
            WHEN COALESCE(SUM(p.amount), 0) >= 50 THEN 'Silver'
            ELSE 'Bronze'
        END AS segment
    FROM customer c
    LEFT JOIN payment p ON c.customer_id = p.customer_id
    GROUP BY c.customer_id, c.last_name, c.first_name, c.email;

    -- 세그먼트별 통계
    SELECT
        segment,
        COUNT(*) AS customer_count,
        ROUND(AVG(total_spent), 2) AS avg_spent,
        ROUND(SUM(total_spent), 2) AS total_revenue
    FROM customer_segments
    GROUP BY segment
    ORDER BY FIELD(segment, 'VIP', 'Gold', 'Silver', 'Bronze');

    -- 전체 고객 목록
    SELECT * FROM customer_segments ORDER BY total_spent DESC;
END$$

DELIMITER ;

-- 사용
CALL segment_customers();
```
</details>

---

**2-3. 휴면 고객 재활성화 타겟 조회**

최근 6개월간 대여 이력이 없지만, 과거 총 결제액이 $100 이상인 고객을 찾는 쿼리를 작성하세요.

**힌트:** 서브쿼리와 NOT EXISTS 활용

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
SELECT
    c.customer_id,
    CONCAT(c.last_name, ' ', c.first_name) AS customer_name,
    c.email,
    ROUND(SUM(p.amount), 2) AS total_spent,
    MAX(r.rental_date) AS last_rental_date,
    DATEDIFF(NOW(), MAX(r.rental_date)) AS days_since_last_rental
FROM customer c
INNER JOIN rental r ON c.customer_id = r.customer_id
INNER JOIN payment p ON c.customer_id = p.customer_id
WHERE NOT EXISTS (
    -- 최근 6개월 대여 이력이 없음
    SELECT 1
    FROM rental r2
    WHERE r2.customer_id = c.customer_id
    AND r2.rental_date >= DATE_SUB(NOW(), INTERVAL 6 MONTH)
)
GROUP BY c.customer_id, c.last_name, c.first_name, c.email
HAVING total_spent >= 100
ORDER BY total_spent DESC;
```
</details>

---

## Mission 3: 재고 및 인기 영화 분석 (난이도: ⭐⭐⭐)

### 시나리오
영화 구매 담당자가 인기 영화의 재고를 늘리고, 인기 없는 영화는 줄이려고 합니다.

### 요구사항

**3-1. 영화별 인기도 분석 뷰**

`film_popularity` 뷰를 생성하여 다음 정보를 제공하세요:
- film_id, title
- rental_count (대여 횟수)
- revenue (총 매출)
- inventory_count (현재 재고 수)
- availability_ratio (재고 대비 수요 = rental_count / inventory_count)

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
CREATE VIEW film_popularity AS
SELECT
    f.film_id,
    f.title,
    COUNT(r.rental_id) AS rental_count,
    ROUND(SUM(p.amount), 2) AS revenue,
    (SELECT COUNT(*) FROM inventory i WHERE i.film_id = f.film_id) AS inventory_count,
    ROUND(
        COUNT(r.rental_id) / NULLIF((SELECT COUNT(*) FROM inventory i WHERE i.film_id = f.film_id), 0),
        2
    ) AS availability_ratio
FROM film f
LEFT JOIN inventory inv ON f.film_id = inv.film_id
LEFT JOIN rental r ON inv.inventory_id = r.inventory_id
LEFT JOIN payment p ON r.rental_id = p.rental_id
GROUP BY f.film_id, f.title
ORDER BY rental_count DESC;

-- 확인: 인기 영화 Top 10
SELECT * FROM film_popularity ORDER BY rental_count DESC LIMIT 10;

-- 확인: 재고 부족 영화 (availability_ratio가 높음)
SELECT * FROM film_popularity
WHERE availability_ratio > 10
ORDER BY availability_ratio DESC;
```
</details>

---

**3-2. 카테고리별 성과 분석**

각 영화 카테고리별 성과를 분석하는 쿼리를 작성하세요.

**결과 컬럼:**
- category_name
- film_count (영화 수)
- total_rentals (총 대여 횟수)
- total_revenue (총 매출)
- avg_rental_rate (평균 대여 가격)

**정렬:** 총 매출 내림차순

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
SELECT
    c.name AS category_name,
    COUNT(DISTINCT f.film_id) AS film_count,
    COUNT(r.rental_id) AS total_rentals,
    ROUND(SUM(p.amount), 2) AS total_revenue,
    ROUND(AVG(f.rental_rate), 2) AS avg_rental_rate
FROM category c
LEFT JOIN film_category fc ON c.category_id = fc.category_id
LEFT JOIN film f ON fc.film_id = f.film_id
LEFT JOIN inventory i ON f.film_id = i.film_id
LEFT JOIN rental r ON i.inventory_id = r.inventory_id
LEFT JOIN payment p ON r.rental_id = p.rental_id
GROUP BY c.category_id, c.name
ORDER BY total_revenue DESC;
```
</details>

---

**3-3. 재고 추천 프로시저**

영화 ID를 입력받아 재고 조정 추천을 제공하는 프로시저 `recommend_inventory`를 작성하세요.

**출력:**
- 현재 재고 수
- 최근 30일 대여 횟수
- 추천 재고 수 (최근 30일 대여 횟수 / 10, 최소 1)
- 조정 필요 여부 ('증가', '감소', '유지')

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
DELIMITER $$

CREATE PROCEDURE recommend_inventory(IN p_film_id INT)
BEGIN
    DECLARE current_inventory INT;
    DECLARE recent_rentals INT;
    DECLARE recommended_inventory INT;
    DECLARE adjustment VARCHAR(20);
    DECLARE film_title VARCHAR(255);

    -- 영화 제목 조회
    SELECT title INTO film_title FROM film WHERE film_id = p_film_id;

    -- 현재 재고 수
    SELECT COUNT(*)
    INTO current_inventory
    FROM inventory
    WHERE film_id = p_film_id;

    -- 최근 30일 대여 횟수
    SELECT COUNT(r.rental_id)
    INTO recent_rentals
    FROM inventory i
    LEFT JOIN rental r ON i.inventory_id = r.inventory_id
    WHERE i.film_id = p_film_id
    AND r.rental_date >= DATE_SUB(NOW(), INTERVAL 30 DAY);

    -- 추천 재고 계산 (최소 1개)
    SET recommended_inventory = GREATEST(CEIL(recent_rentals / 10.0), 1);

    -- 조정 필요 여부 판단
    IF recommended_inventory > current_inventory THEN
        SET adjustment = '증가';
    ELSEIF recommended_inventory < current_inventory THEN
        SET adjustment = '감소';
    ELSE
        SET adjustment = '유지';
    END IF;

    -- 결과 출력
    SELECT
        p_film_id AS film_id,
        film_title AS title,
        current_inventory AS '현재_재고',
        recent_rentals AS '최근30일_대여',
        recommended_inventory AS '추천_재고',
        adjustment AS '조정';
END$$

DELIMITER ;

-- 사용
CALL recommend_inventory(1);
```
</details>

---

## Mission 4: 성능 최적화 (난이도: ⭐⭐⭐⭐)

### 시나리오
데이터베이스 성능 문제로 인해 일부 쿼리가 느리게 실행되고 있습니다. 성능을 개선하세요.

### 요구사항

**4-1. 느린 쿼리 식별**

다음 쿼리의 실행 계획을 분석하고 문제점을 찾으세요:

```sql
SELECT
    c.customer_id,
    c.first_name,
    c.last_name,
    COUNT(r.rental_id) AS rental_count,
    SUM(p.amount) AS total_spent
FROM customer c
LEFT JOIN rental r ON c.customer_id = r.customer_id
LEFT JOIN payment p ON r.rental_id = p.rental_id
WHERE c.active = 1
GROUP BY c.customer_id, c.first_name, c.last_name
HAVING total_spent > 100
ORDER BY total_spent DESC;
```

**과제:**
1. EXPLAIN으로 실행 계획 확인
2. 문제점 식별
3. 인덱스 추가로 성능 개선
4. 개선 전후 비교

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
-- 1. 실행 계획 확인
EXPLAIN SELECT
    c.customer_id,
    c.first_name,
    c.last_name,
    COUNT(r.rental_id) AS rental_count,
    SUM(p.amount) AS total_spent
FROM customer c
LEFT JOIN rental r ON c.customer_id = r.customer_id
LEFT JOIN payment p ON r.rental_id = p.rental_id
WHERE c.active = 1
GROUP BY c.customer_id, c.first_name, c.last_name
HAVING total_spent > 100
ORDER BY total_spent DESC;

-- 2. 문제점 식별
-- - customer.active에 인덱스가 없어 Full Table Scan 발생 가능
-- - rental.customer_id에 인덱스 없으면 조인 성능 저하
-- - payment.rental_id에 인덱스 없으면 조인 성능 저하

-- 3. 인덱스 추가
CREATE INDEX idx_customer_active ON customer(active);
CREATE INDEX idx_rental_customer ON rental(customer_id);
CREATE INDEX idx_payment_rental ON payment(rental_id);

-- sakila DB는 이미 FK 인덱스가 있을 수 있으므로 확인:
SHOW INDEX FROM customer;
SHOW INDEX FROM rental;
SHOW INDEX FROM payment;

-- 4. 개선 후 실행 계획 재확인
EXPLAIN SELECT
    c.customer_id,
    c.first_name,
    c.last_name,
    COUNT(r.rental_id) AS rental_count,
    SUM(p.amount) AS total_spent
FROM customer c
LEFT JOIN rental r ON c.customer_id = r.customer_id
LEFT JOIN payment p ON r.rental_id = p.rental_id
WHERE c.active = 1
GROUP BY c.customer_id, c.first_name, c.last_name
HAVING total_spent > 100
ORDER BY total_spent DESC;

-- type이 ALL에서 ref나 range로 개선되었는지 확인
```
</details>

---

**4-2. 커버링 인덱스 활용**

다음 자주 실행되는 쿼리에 커버링 인덱스를 적용하세요:

```sql
SELECT film_id, title, rental_rate
FROM film
WHERE rating = 'PG-13'
ORDER BY rental_rate DESC;
```

**과제:**
1. 현재 실행 계획 확인
2. 커버링 인덱스 생성
3. 성능 개선 확인

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
-- 1. 현재 실행 계획
EXPLAIN SELECT film_id, title, rental_rate
FROM film
WHERE rating = 'PG-13'
ORDER BY rental_rate DESC;

-- 2. 커버링 인덱스 생성
-- rating, rental_rate, film_id, title을 모두 포함하는 인덱스
CREATE INDEX idx_film_covering ON film(rating, rental_rate DESC, title, film_id);

-- 또는 더 간단하게 (SELECT하는 컬럼이 적은 경우)
CREATE INDEX idx_film_rating_rate ON film(rating, rental_rate);

-- 3. 개선 후 실행 계획 확인
EXPLAIN SELECT film_id, title, rental_rate
FROM film
WHERE rating = 'PG-13'
ORDER BY rental_rate DESC;

-- Extra 컬럼에 "Using index"가 표시되면 커버링 인덱스 사용 중

-- 인덱스 제거 (실습 후 정리)
-- DROP INDEX idx_film_covering ON film;
```
</details>

---

**4-3. 쿼리 리팩토링**

다음 비효율적인 쿼리를 최적화하세요:

```sql
-- 각 고객의 가장 최근 대여 영화 제목 조회
SELECT
    c.customer_id,
    c.first_name,
    c.last_name,
    (SELECT f.title
     FROM rental r
     JOIN inventory i ON r.inventory_id = i.inventory_id
     JOIN film f ON i.film_id = f.film_id
     WHERE r.customer_id = c.customer_id
     ORDER BY r.rental_date DESC
     LIMIT 1) AS last_rented_film
FROM customer c;
```

**과제:** 서브쿼리를 JOIN으로 변경하여 성능 개선

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
-- 개선된 쿼리 (윈도우 함수 사용)
WITH ranked_rentals AS (
    SELECT
        r.customer_id,
        f.title,
        r.rental_date,
        ROW_NUMBER() OVER (PARTITION BY r.customer_id ORDER BY r.rental_date DESC) AS rn
    FROM rental r
    JOIN inventory i ON r.inventory_id = i.inventory_id
    JOIN film f ON i.film_id = f.film_id
)
SELECT
    c.customer_id,
    c.first_name,
    c.last_name,
    rr.title AS last_rented_film
FROM customer c
LEFT JOIN ranked_rentals rr ON c.customer_id = rr.customer_id AND rr.rn = 1;

-- MySQL 8.0 미만에서는 윈도우 함수를 사용할 수 없으므로 대안:
SELECT
    c.customer_id,
    c.first_name,
    c.last_name,
    f.title AS last_rented_film
FROM customer c
LEFT JOIN rental r ON c.customer_id = r.customer_id
LEFT JOIN inventory i ON r.inventory_id = i.inventory_id
LEFT JOIN film f ON i.film_id = f.film_id
LEFT JOIN rental r2 ON c.customer_id = r2.customer_id AND r.rental_date < r2.rental_date
WHERE r2.rental_id IS NULL  -- r보다 최근 대여가 없음 = r이 가장 최근
GROUP BY c.customer_id, c.first_name, c.last_name, f.title;
```
</details>

---

## Mission 5: 종합 프로젝트 (난이도: ⭐⭐⭐⭐⭐)

### 시나리오
완전한 "월간 비즈니스 리포트" 시스템을 구축하세요.

### 요구사항

**5-1. 월간 리포트 프로시저 생성**

연도와 월을 입력받아 종합 리포트를 생성하는 프로시저 `generate_monthly_report`를 작성하세요.

**리포트 내용:**
1. 전체 매출 및 대여 건수
2. Top 10 고객 (결제액 기준)
3. Top 10 인기 영화 (대여 횟수 기준)
4. 카테고리별 성과
5. 신규 고객 수
6. 전월 대비 성장률

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
DELIMITER $$

CREATE PROCEDURE generate_monthly_report(
    IN p_year INT,
    IN p_month INT
)
BEGIN
    DECLARE report_start_date DATE;
    DECLARE report_end_date DATE;
    DECLARE prev_month_revenue DECIMAL(10,2);
    DECLARE current_month_revenue DECIMAL(10,2);
    DECLARE growth_rate DECIMAL(5,2);

    -- 리포트 기간 설정
    SET report_start_date = DATE(CONCAT(p_year, '-', p_month, '-01'));
    SET report_end_date = LAST_DAY(report_start_date);

    -- ========================================
    -- 1. 전체 매출 및 대여 건수
    -- ========================================
    SELECT '=== 전체 매출 및 대여 건수 ===' AS Section;

    SELECT
        COUNT(DISTINCT r.rental_id) AS total_rentals,
        ROUND(SUM(p.amount), 2) AS total_revenue,
        ROUND(AVG(p.amount), 2) AS avg_payment
    FROM rental r
    LEFT JOIN payment p ON r.rental_id = p.rental_id
    WHERE r.rental_date BETWEEN report_start_date AND report_end_date;

    -- ========================================
    -- 2. Top 10 고객
    -- ========================================
    SELECT '=== Top 10 고객 (결제액 기준) ===' AS Section;

    SELECT
        c.customer_id,
        CONCAT(c.last_name, ' ', c.first_name) AS customer_name,
        c.email,
        COUNT(r.rental_id) AS rental_count,
        ROUND(SUM(p.amount), 2) AS total_spent
    FROM customer c
    JOIN rental r ON c.customer_id = r.customer_id
    JOIN payment p ON r.rental_id = p.rental_id
    WHERE r.rental_date BETWEEN report_start_date AND report_end_date
    GROUP BY c.customer_id, c.last_name, c.first_name, c.email
    ORDER BY total_spent DESC
    LIMIT 10;

    -- ========================================
    -- 3. Top 10 인기 영화
    -- ========================================
    SELECT '=== Top 10 인기 영화 (대여 횟수 기준) ===' AS Section;

    SELECT
        f.film_id,
        f.title,
        COUNT(r.rental_id) AS rental_count,
        ROUND(SUM(p.amount), 2) AS revenue
    FROM film f
    JOIN inventory i ON f.film_id = i.film_id
    JOIN rental r ON i.inventory_id = r.inventory_id
    LEFT JOIN payment p ON r.rental_id = p.rental_id
    WHERE r.rental_date BETWEEN report_start_date AND report_end_date
    GROUP BY f.film_id, f.title
    ORDER BY rental_count DESC
    LIMIT 10;

    -- ========================================
    -- 4. 카테고리별 성과
    -- ========================================
    SELECT '=== 카테고리별 성과 ===' AS Section;

    SELECT
        c.name AS category,
        COUNT(r.rental_id) AS rental_count,
        ROUND(SUM(p.amount), 2) AS revenue
    FROM category c
    LEFT JOIN film_category fc ON c.category_id = fc.category_id
    LEFT JOIN film f ON fc.film_id = f.film_id
    LEFT JOIN inventory i ON f.film_id = i.film_id
    LEFT JOIN rental r ON i.inventory_id = r.inventory_id AND r.rental_date BETWEEN report_start_date AND report_end_date
    LEFT JOIN payment p ON r.rental_id = p.rental_id
    GROUP BY c.category_id, c.name
    ORDER BY revenue DESC;

    -- ========================================
    -- 5. 신규 고객 수
    -- ========================================
    SELECT '=== 신규 고객 ===' AS Section;

    SELECT COUNT(*) AS new_customers
    FROM customer
    WHERE create_date BETWEEN report_start_date AND report_end_date;

    -- ========================================
    -- 6. 전월 대비 성장률
    -- ========================================
    SELECT '=== 전월 대비 성장률 ===' AS Section;

    -- 현재 월 매출
    SELECT COALESCE(SUM(amount), 0)
    INTO current_month_revenue
    FROM payment
    WHERE payment_date BETWEEN report_start_date AND report_end_date;

    -- 전월 매출
    SELECT COALESCE(SUM(amount), 0)
    INTO prev_month_revenue
    FROM payment
    WHERE payment_date BETWEEN DATE_SUB(report_start_date, INTERVAL 1 MONTH)
                           AND DATE_SUB(report_end_date, INTERVAL 1 MONTH);

    -- 성장률 계산
    IF prev_month_revenue > 0 THEN
        SET growth_rate = ((current_month_revenue - prev_month_revenue) / prev_month_revenue) * 100;
    ELSE
        SET growth_rate = 0;
    END IF;

    SELECT
        prev_month_revenue AS '전월_매출',
        current_month_revenue AS '당월_매출',
        ROUND(growth_rate, 2) AS '성장률(%)';

END$$

DELIMITER ;

-- 사용
CALL generate_monthly_report(2005, 7);
```
</details>

---

**5-2. 리포트 결과를 저장하는 테이블 및 프로시저**

월간 리포트 결과를 `monthly_report_summary` 테이블에 저장하는 개선된 버전을 작성하세요.

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
-- 리포트 요약 테이블 생성
CREATE TABLE IF NOT EXISTS monthly_report_summary (
    report_id INT AUTO_INCREMENT PRIMARY KEY,
    report_year INT NOT NULL,
    report_month INT NOT NULL,
    total_rentals INT,
    total_revenue DECIMAL(10,2),
    avg_payment DECIMAL(10,2),
    new_customers INT,
    growth_rate DECIMAL(5,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY unique_report (report_year, report_month)
);

-- 리포트 저장 프로시저
DELIMITER $$

CREATE PROCEDURE save_monthly_report(
    IN p_year INT,
    IN p_month INT
)
BEGIN
    DECLARE v_total_rentals INT;
    DECLARE v_total_revenue DECIMAL(10,2);
    DECLARE v_avg_payment DECIMAL(10,2);
    DECLARE v_new_customers INT;
    DECLARE v_growth_rate DECIMAL(5,2);
    DECLARE report_start_date DATE;
    DECLARE report_end_date DATE;
    DECLARE prev_month_revenue DECIMAL(10,2);
    DECLARE current_month_revenue DECIMAL(10,2);

    SET report_start_date = DATE(CONCAT(p_year, '-', p_month, '-01'));
    SET report_end_date = LAST_DAY(report_start_date);

    -- 전체 매출 및 대여 건수 계산
    SELECT
        COUNT(DISTINCT r.rental_id),
        ROUND(SUM(p.amount), 2),
        ROUND(AVG(p.amount), 2)
    INTO v_total_rentals, v_total_revenue, v_avg_payment
    FROM rental r
    LEFT JOIN payment p ON r.rental_id = p.rental_id
    WHERE r.rental_date BETWEEN report_start_date AND report_end_date;

    -- 신규 고객 수
    SELECT COUNT(*)
    INTO v_new_customers
    FROM customer
    WHERE create_date BETWEEN report_start_date AND report_end_date;

    -- 성장률 계산
    SELECT COALESCE(SUM(amount), 0)
    INTO current_month_revenue
    FROM payment
    WHERE payment_date BETWEEN report_start_date AND report_end_date;

    SELECT COALESCE(SUM(amount), 0)
    INTO prev_month_revenue
    FROM payment
    WHERE payment_date BETWEEN DATE_SUB(report_start_date, INTERVAL 1 MONTH)
                           AND DATE_SUB(report_end_date, INTERVAL 1 MONTH);

    IF prev_month_revenue > 0 THEN
        SET v_growth_rate = ((current_month_revenue - prev_month_revenue) / prev_month_revenue) * 100;
    ELSE
        SET v_growth_rate = 0;
    END IF;

    -- 리포트 저장 (중복 시 업데이트)
    INSERT INTO monthly_report_summary (
        report_year, report_month, total_rentals, total_revenue,
        avg_payment, new_customers, growth_rate
    ) VALUES (
        p_year, p_month, v_total_rentals, v_total_revenue,
        v_avg_payment, v_new_customers, v_growth_rate
    )
    ON DUPLICATE KEY UPDATE
        total_rentals = v_total_rentals,
        total_revenue = v_total_revenue,
        avg_payment = v_avg_payment,
        new_customers = v_new_customers,
        growth_rate = v_growth_rate,
        created_at = CURRENT_TIMESTAMP;

    SELECT '리포트 저장 완료' AS Message;
    SELECT * FROM monthly_report_summary
    WHERE report_year = p_year AND report_month = p_month;
END$$

DELIMITER ;

-- 사용
CALL save_monthly_report(2005, 7);
CALL save_monthly_report(2005, 8);

-- 저장된 리포트 조회
SELECT * FROM monthly_report_summary ORDER BY report_year, report_month;
```
</details>

---

## 강사 가이드

### 수업 진행 팁

1. **프로젝트 기반 학습 강조** (5분)
   - "실무에서는 단일 개념이 아니라 여러 기술을 조합해서 사용합니다"
   - 각 미션이 실제 업무 시나리오임을 강조
   - 학생들에게 "여러분이 데이터 분석가/DBA라고 생각하세요" 동기부여

2. **난이도 순차적 진행** (전체 180분)
   - Mission 1 (30분): 뷰와 프로시저 기본
   - Mission 2 (40분): 복잡한 분석 쿼리
   - Mission 3 (40분): 비즈니스 로직 구현
   - Mission 4 (30분): 성능 최적화
   - Mission 5 (40분): 종합 프로젝트

3. **페어 프로그래밍 권장**
   - 2인 1조로 팀을 구성
   - 한 명은 드라이버(코드 작성), 한 명은 네비게이터(방향 제시)
   - 미션마다 역할 교대

4. **단계별 검증 필수**
   - 각 미션 완료 후 반드시 결과 확인
   - EXPLAIN으로 쿼리 실행 계획 검증
   - 예상 결과와 실제 결과 비교

5. **코드 리뷰 세션** (20분)
   - 모든 미션 완료 후 우수 사례 공유
   - 여러 해결 방법 비교 (정답은 하나가 아님)
   - 성능 차이 논의

### 자주 하는 질문

**Q1: 실무에서도 이렇게 복잡한 프로시저를 작성하나요?**
> A: 상황에 따라 다릅니다. 최근 트렌드는 애플리케이션 레벨에서 로직을 처리하는 방향이지만, 배치 작업, 복잡한 집계, 데이터 정합성이 중요한 경우에는 여전히 프로시저를 사용합니다.

**Q2: 뷰를 너무 많이 만들면 관리가 어렵지 않나요?**
> A: 맞습니다. 뷰는 필요한 경우에만 만들어야 합니다. 일반적으로:
> - 자주 사용하는 복잡한 쿼리
> - 보안이 필요한 경우
> - 여러 애플리케이션에서 공통으로 사용하는 경우
> 에만 뷰를 생성하고, 명확한 명명 규칙과 문서화가 필수입니다.

**Q3: 인덱스는 많을수록 좋은가요?**
> A: 아니요. 인덱스는 조회 성능은 향상시키지만, 삽입/수정/삭제 성능은 저하시킵니다. 적절한 균형이 필요하며, 실제 쿼리 패턴을 분석하여 필요한 인덱스만 생성해야 합니다.

**Q4: 월간 리포트 같은 건 어떻게 자동화하나요?**
> A: MySQL의 이벤트 스케줄러(Event Scheduler)를 사용하거나, 외부 cron job으로 자동화할 수 있습니다.
> ```sql
> CREATE EVENT monthly_report_event
> ON SCHEDULE EVERY 1 MONTH
> STARTS '2025-01-01 00:00:00'
> DO CALL save_monthly_report(YEAR(NOW()), MONTH(NOW()));
> ```

**Q5: 이 프로젝트를 포트폴리오에 넣어도 되나요?**
> A: 네! 다만 sakila는 샘플 DB이므로:
> 1. 본인만의 비즈니스 시나리오 추가
> 2. 더 복잡한 분석 로직 구현
> 3. GitHub에 README와 함께 문서화
> 4. 성능 측정 결과 포함
> 하면 훌륭한 포트폴리오가 됩니다.

### 평가 기준

각 미션을 평가할 때 다음 기준을 사용하세요:

| 항목 | 배점 | 평가 기준 |
|-----|------|---------|
| **기능 정확성** | 40% | 요구사항을 정확히 구현했는가? |
| **코드 품질** | 30% | 가독성, 명명 규칙, 주석 |
| **성능** | 20% | 인덱스 활용, 쿼리 최적화 |
| **창의성** | 10% | 추가 기능, 개선 아이디어 |

### 추가 도전 과제

시간이 남는 학생들을 위한 추가 과제:

1. **대시보드 뷰 확장**: 실시간 KPI 대시보드 뷰 추가 생성
2. **A/B 테스트 분석**: 프로모션 효과 분석 프로시저 작성
3. **추천 시스템**: 고객별 영화 추천 알고리즘 구현
4. **이상 거래 탐지**: 비정상적인 대여 패턴 감지 쿼리

---

## 요약

### 핵심 학습 내용

이번 종합 실습을 통해 다음을 학습했습니다:

1. **통합적 SQL 활용**
   - JOIN, 서브쿼리, 집계 함수를 조합한 복잡한 쿼리
   - 비즈니스 로직을 SQL로 구현하는 방법

2. **뷰를 통한 데이터 추상화**
   - 복잡한 쿼리를 뷰로 캡슐화
   - 재사용 가능한 데이터 인터페이스 제공

3. **저장 프로시저로 로직 구현**
   - 변수, 제어문, 커서를 활용한 복잡한 로직
   - 트랜잭션과 오류 처리

4. **성능 최적화**
   - EXPLAIN으로 쿼리 분석
   - 인덱스 전략 수립
   - 쿼리 리팩토링

5. **실무 시나리오 해결**
   - 고객 분석 및 세그멘테이션
   - 재고 관리 및 추천
   - 월간 비즈니스 리포트 자동화

### 다음 단계

**5장: 트랜잭션과 동시성**에서 학습할 내용:
- 트랜잭션(Transaction)의 개념과 ACID 속성
- COMMIT, ROLLBACK, SAVEPOINT
- 트랜잭션 격리 수준 (Isolation Level)
- 락(Lock)과 동시성 제어
- 데드락(Deadlock) 이해와 예방

---

**축하합니다!** 4장 SQL 고급을 완료했습니다. 이제 여러분은 복잡한 SQL 문제를 해결할 수 있는 능력을 갖추었습니다.

**연습 권장사항:**
- 본인만의 비즈니스 시나리오로 프로젝트 확장
- 실제 데이터를 사용한 성능 테스트
- GitHub에 포트폴리오로 정리
- 다른 학생들과 코드 리뷰 교환
