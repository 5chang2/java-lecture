# 4.3. 인덱스 (Index)

> 인덱스를 사용하여 쿼리 성능을 극적으로 향상시킬 수 있다.

---

## 실습 준비

이 섹션에서는 **world와 sakila 데이터베이스**를 사용합니다.

```sql
USE world;
```

---

## 1. 인덱스란?

**인덱스(Index)**는 데이터베이스 테이블의 **검색 속도를 향상**시키기 위한 자료구조입니다.

### 1.1. 책의 색인에 비유

```
책에서 "데이터베이스"라는 단어를 찾는다면?

❌ 인덱스 없음: 1페이지부터 끝까지 모두 읽어야 함 (느림)
✅ 인덱스 있음: 색인에서 "데이터베이스" → 123페이지 (빠름)
```

**데이터베이스도 마찬가지:**
- 인덱스 없이: 테이블 전체를 순차적으로 검색 (Full Table Scan)
- 인덱스 사용: 인덱스에서 위치를 빠르게 찾아 접근

### 1.2. 왜 인덱스가 필요한가?

**문제 상황:**
```sql
-- 1억 개의 행이 있는 테이블에서 특정 사용자 찾기
SELECT * FROM users WHERE email = 'user@email.com';
-- 인덱스 없으면: 1억 개 모두 확인 (매우 느림)
-- 인덱스 있으면: 몇 번의 비교만으로 찾기 (매우 빠름)
```

**성능 차이:**
- 인덱스 없음: 수 초 ~ 수 분
- 인덱스 있음: 0.001초 이하

---

## 2. 인덱스 확인

### 2.1. 기존 인덱스 조회

```sql
-- world 데이터베이스의 city 테이블 인덱스 확인
SHOW INDEX FROM city;
```

**결과 예시:**
```
+-------+------------+-------------+--------------+-------------+
| Table | Non_unique | Key_name    | Seq_in_index | Column_name |
+-------+------------+-------------+--------------+-------------+
| city  |          0 | PRIMARY     |            1 | ID          |
| city  |          1 | CountryCode |            1 | CountryCode |
+-------+------------+-------------+--------------+-------------+
```

**해석:**
- `PRIMARY`: 기본 키 인덱스 (ID 컬럼)
- `CountryCode`: 외래 키 인덱스 (CountryCode 컬럼)
- `Non_unique = 0`: 유일 인덱스 (중복 불가)
- `Non_unique = 1`: 일반 인덱스 (중복 가능)

### 2.2. 테이블 구조로 확인

```sql
DESCRIBE city;
```

**Key 컬럼:**
- `PRI`: Primary Key 인덱스
- `MUL`: Multiple (일반 인덱스)
- `UNI`: Unique 인덱스

---

## 3. 인덱스 생성

### 3.1. 단일 컬럼 인덱스

```sql
-- city 테이블의 Name 컬럼에 인덱스 생성
CREATE INDEX idx_city_name ON city(Name);

-- 확인
SHOW INDEX FROM city;
```

### 3.2. 복합 인덱스 (다중 컬럼)

```sql
-- CountryCode와 Population 조합으로 인덱스 생성
CREATE INDEX idx_country_pop ON city(CountryCode, Population);
```

**복합 인덱스 사용 규칙:**
- 왼쪽 컬럼부터 순서대로 사용
- `WHERE CountryCode = 'KOR'`: 인덱스 사용 ✅
- `WHERE Population > 1000000`: 인덱스 사용 ❌ (두 번째 컬럼만 사용)

### 3.3. UNIQUE 인덱스

```sql
-- 이메일 중복 방지 + 인덱스
CREATE UNIQUE INDEX idx_unique_email ON users(email);
```

### 3.4. 테이블 생성 시 인덱스 지정

```sql
CREATE TABLE products (
    product_id INT PRIMARY KEY,           -- 자동으로 인덱스 생성
    product_name VARCHAR(100) NOT NULL,
    price DECIMAL(10, 2),
    INDEX idx_name (product_name),        -- 인덱스 생성
    INDEX idx_price (price)               -- 인덱스 생성
);
```

---

## 4. 인덱스 삭제

```sql
-- 인덱스 삭제
DROP INDEX idx_city_name ON city;

-- 또는
ALTER TABLE city DROP INDEX idx_city_name;
```

⚠️ **주의:** PRIMARY KEY와 FOREIGN KEY 인덱스는 직접 삭제할 수 없습니다.

---

## 5. EXPLAIN으로 실행 계획 확인

`EXPLAIN`은 쿼리가 **어떻게 실행되는지** 보여줍니다.

### 5.1. 인덱스 없을 때

```sql
-- Name 컬럼에 인덱스가 없다고 가정
EXPLAIN SELECT * FROM city WHERE Name = 'Seoul';
```

**결과:**
```
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
|  1 | SIMPLE      | city  | ALL  | NULL          | NULL | NULL    | NULL | 4079 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
```

**해석:**
- `type: ALL`: Full Table Scan (테이블 전체 검색) ❌
- `rows: 4079`: 4,079개 행 모두 확인
- `key: NULL`: 인덱스 사용 안 함

### 5.2. 인덱스 사용할 때

```sql
-- Name 컬럼에 인덱스 생성 후
CREATE INDEX idx_city_name ON city(Name);

EXPLAIN SELECT * FROM city WHERE Name = 'Seoul';
```

**결과:**
```
+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------+
| id | select_type | table | type | possible_keys | key           | key_len | ref   | rows | Extra |
+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------+
|  1 | SIMPLE      | city  | ref  | idx_city_name | idx_city_name | 35      | const |    1 | NULL  |
+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------+
```

**해석:**
- `type: ref`: 인덱스를 사용한 검색 ✅
- `key: idx_city_name`: idx_city_name 인덱스 사용
- `rows: 1`: 1개 행만 확인 (4,079개 → 1개)

### 5.3. type 컬럼 의미

성능 순서 (좋음 → 나쁨):
1. **system/const**: 상수 조회 (가장 빠름)
2. **eq_ref**: 유일 인덱스 조회 (JOIN에서 PRIMARY KEY)
3. **ref**: 일반 인덱스 조회
4. **range**: 범위 검색 (`>`, `<`, `BETWEEN`)
5. **index**: 인덱스 전체 스캔
6. **ALL**: 테이블 전체 스캔 (가장 느림) ❌

---

## 6. 인덱스 종류

### 6.1. B-Tree 인덱스 (기본)

MySQL의 기본 인덱스 방식입니다.

**특징:**
- 정렬된 상태로 저장
- 범위 검색에 효율적
- `=`, `>`, `<`, `BETWEEN`, `LIKE 'prefix%'` 모두 효과적

**구조:**
```
        [50]
       /    \
   [25]      [75]
   /  \      /  \
 [10][30] [60][80]
```

### 6.2. Hash 인덱스

**특징:**
- 해시 함수 사용
- `=` 비교만 빠름
- 범위 검색, 정렬에는 사용 불가
- Memory 스토리지 엔진에서 사용

```sql
-- Hash 인덱스 (Memory 테이블)
CREATE TABLE temp_data (
    id INT,
    value VARCHAR(100),
    INDEX USING HASH (id)
) ENGINE=MEMORY;
```

---

## 7. 인덱스 사용 시 주의사항

### 7.1. 인덱스가 사용되지 않는 경우

#### 경우 1: 함수 사용
```sql
-- ❌ 인덱스 사용 안 됨
SELECT * FROM city WHERE UPPER(Name) = 'SEOUL';

-- ✅ 인덱스 사용
SELECT * FROM city WHERE Name = 'Seoul';
```

#### 경우 2: LIKE의 와일드카드
```sql
-- ❌ 인덱스 사용 안 됨 (앞에 %)
SELECT * FROM city WHERE Name LIKE '%Seoul%';

-- ✅ 인덱스 사용 (앞에 % 없음)
SELECT * FROM city WHERE Name LIKE 'Seoul%';
```

#### 경우 3: 데이터 타입 불일치
```sql
-- CountryCode가 CHAR(3)인데 숫자로 비교
-- ❌ 인덱스 사용 안 됨
SELECT * FROM city WHERE CountryCode = 100;

-- ✅ 인덱스 사용
SELECT * FROM city WHERE CountryCode = 'KOR';
```

### 7.2. 인덱스의 장단점

**장점:**
- ✅ SELECT 성능 향상 (특히 대용량 데이터)
- ✅ ORDER BY, GROUP BY 성능 향상
- ✅ MIN, MAX 빠른 조회

**단점:**
- ❌ 추가 저장 공간 필요 (테이블 크기의 10-20%)
- ❌ INSERT, UPDATE, DELETE 성능 저하 (인덱스도 함께 수정)
- ❌ 잘못 설계하면 오히려 느려질 수 있음

### 7.3. 인덱스 생성 기준

**인덱스를 만들면 좋은 경우:**
- WHERE, JOIN, ORDER BY에 자주 사용되는 컬럼
- 카디널리티(중복도)가 높은 컬럼 (예: 이메일, 주민번호)
- 대용량 테이블

**인덱스를 만들지 않는 것이 좋은 경우:**
- 데이터가 적은 테이블 (수백 개 이하)
- 카디널리티가 낮은 컬럼 (예: 성별, 참/거짓)
- INSERT/UPDATE/DELETE가 빈번한 테이블

---

## 실습 문제

이제 **sakila 데이터베이스**로 실습해봅시다.

```sql
USE sakila;
```

### 문제 1: 인덱스 확인

`film` 테이블에 어떤 인덱스가 있는지 확인하세요.

**예상 답:**
```sql
SHOW INDEX FROM film;
-- 또는
DESCRIBE film;
```

### 문제 2: EXPLAIN으로 성능 분석

다음 쿼리의 실행 계획을 확인하세요.

```sql
EXPLAIN SELECT * FROM film WHERE title = 'ACADEMY DINOSAUR';
```

**분석:**
- `type`이 무엇인가?
- 인덱스를 사용하는가?
- 몇 개의 행을 검사하는가?

### 문제 3: 인덱스 생성

`film` 테이블의 `release_year` 컬럼에 인덱스를 생성하세요.

**예상 답:**
```sql
CREATE INDEX idx_release_year ON film(release_year);

-- 확인
SHOW INDEX FROM film;
```

### 문제 4: 성능 비교

인덱스 생성 전후 성능을 비교하세요.

```sql
-- 인덱스 생성 전
EXPLAIN SELECT * FROM film WHERE release_year = 2006;

-- 인덱스 생성
CREATE INDEX idx_release_year ON film(release_year);

-- 인덱스 생성 후
EXPLAIN SELECT * FROM film WHERE release_year = 2006;
```

**질문:**
- `type`이 어떻게 변했는가?
- `rows` 값이 어떻게 변했는가?

### 문제 5: 복합 인덱스

`payment` 테이블에 `customer_id`와 `amount`를 조합한 복합 인덱스를 생성하세요.

**예상 답:**
```sql
CREATE INDEX idx_customer_amount ON payment(customer_id, amount);

-- 사용 예시
EXPLAIN SELECT *
FROM payment
WHERE customer_id = 1 AND amount > 5.00;
```

### 문제 6: 인덱스 삭제

문제 3에서 생성한 `idx_release_year` 인덱스를 삭제하세요.

**예상 답:**
```sql
DROP INDEX idx_release_year ON film;

-- 확인
SHOW INDEX FROM film;
```

---

## 강사 가이드

### 데이터베이스 활용 전략

1. **world DB (개념 설명)**
   - city 테이블로 인덱스 기본 개념
   - EXPLAIN으로 성능 차이 시각화
   - 4,079개 행으로 Full Scan vs Index Scan 비교

2. **sakila DB (실습 문제)**
   - film, payment 테이블로 실습
   - 인덱스 생성/삭제/분석
   - 실무 패턴 경험

3. **수업 진행 흐름**
   ```
   1. 인덱스 개념 (책의 색인 비유)
   2. EXPLAIN으로 차이 시연
   3. 인덱스 생성/삭제 실습
   4. 인덱스 종류 (B-Tree, Hash)
   5. 주의사항 및 best practice
   6. sakila 실습
   ```

### 핵심 포인트

1. **EXPLAIN 습관화**: 모든 쿼리에 EXPLAIN 붙여보기
2. **type 컬럼 이해**: ALL(느림) → ref(빠름) 차이
3. **인덱스는 양날의 검**: SELECT ↑, INSERT/UPDATE/DELETE ↓
4. **함수 사용 주의**: `WHERE UPPER(col)` → 인덱스 무효화
5. **LIKE 와일드카드**: 앞에 `%` 있으면 인덱스 안 씀
6. **카디널리티**: 중복 적으면 인덱스 효과적

### 자주 하는 질문

**Q: 인덱스는 많을수록 좋은가요?**
A: 아닙니다. 인덱스가 많으면 INSERT/UPDATE/DELETE 성능이 저하됩니다. 필요한 것만 생성하세요.

**Q: PRIMARY KEY도 인덱스인가요?**
A: 네, PRIMARY KEY는 자동으로 UNIQUE 인덱스가 생성됩니다.

**Q: 복합 인덱스의 컬럼 순서가 중요한가요?**
A: 매우 중요합니다. WHERE 절에서 자주 사용되는 순서로 정의하세요.

**Q: 인덱스를 만들었는데 사용되지 않는 이유는?**
A: 함수 사용, 데이터 타입 불일치, LIKE의 앞쪽 와일드카드, 테이블이 너무 작은 경우 등이 있습니다.

**Q: B-Tree와 Hash 인덱스 중 어느 것이 좋나요?**
A: 대부분의 경우 B-Tree가 적합합니다. Hash는 `=` 비교만 빠르고 범위 검색에는 사용할 수 없습니다.

**Q: EXPLAIN의 rows가 실제 결과 개수와 다른데요?**
A: rows는 **예상 검사 행 수**입니다. 실제 결과는 WHERE 조건에 따라 달라집니다.

### 실습 진행 팁

1. **성능 체감**: 큰 테이블에서 인덱스 전후 비교
2. **EXPLAIN 분석**: type, key, rows 컬럼 중심으로
3. **잘못된 쿼리 체험**: 함수 사용, LIKE '%...%' 등
4. **복합 인덱스 실험**: 컬럼 순서에 따른 차이
5. **실시간 생성/삭제**: 학생들이 직접 인덱스 관리

### 시연 예시

```sql
-- 1. 인덱스 없이 검색 (느림)
EXPLAIN SELECT * FROM city WHERE Name = 'Seoul';
-- type: ALL, rows: 4079

-- 2. 인덱스 생성
CREATE INDEX idx_city_name ON city(Name);

-- 3. 인덱스로 검색 (빠름)
EXPLAIN SELECT * FROM city WHERE Name = 'Seoul';
-- type: ref, rows: 1

-- 4. 성능 차이 강조
-- "4,079개 → 1개만 확인!"
```

---

## 요약

- **인덱스**: 검색 속도를 향상시키는 자료구조 (책의 색인)
- **생성**: `CREATE INDEX 인덱스명 ON 테이블(컬럼)`
- **삭제**: `DROP INDEX 인덱스명 ON 테이블`
- **확인**: `SHOW INDEX FROM 테이블` 또는 `DESCRIBE 테이블`
- **실행 계획**: `EXPLAIN SELECT ...`
- **type 컬럼**:
  - `ALL`: Full Table Scan (느림) ❌
  - `ref`: 인덱스 사용 (빠름) ✅
  - `const`: 상수 조회 (가장 빠름) ✅✅
- **인덱스 종류**:
  - **B-Tree**: 기본, 범위 검색 효율적
  - **Hash**: `=` 비교만 빠름
- **장점**: SELECT, ORDER BY, GROUP BY 성능 향상
- **단점**: 저장 공간, INSERT/UPDATE/DELETE 느려짐
- **주의사항**:
  - 함수 사용 시 인덱스 무효화
  - LIKE '%...%' 인덱스 안 씀
  - 카디널리티 낮으면 비효율적
- **생성 기준**:
  - WHERE, JOIN, ORDER BY에 자주 사용
  - 카디널리티 높은 컬럼
  - 대용량 테이블

**다음 단계**: 쿼리 성능 최적화 기법을 배워 EXPLAIN을 더 깊이 분석합니다!
