# 4.1. JOIN (조인)

> JOIN을 사용하여 여러 테이블의 데이터를 연결하고 조회할 수 있다.

---

## 실습 준비

이 섹션에서는 **world 데이터베이스**를 사용합니다.

```sql
USE world;
```

---

## 1. JOIN이란?

**JOIN**은 관계형 데이터베이스의 핵심 기능으로, **여러 테이블의 데이터를 연결**하여 조회합니다.

### 왜 JOIN이 필요한가?

데이터베이스 설계 시 데이터를 **정규화**하면 중복을 줄이지만 데이터가 여러 테이블로 흩어집니다.

**예시: world 데이터베이스**
```
country 테이블: 국가 정보 (Code, Name, Continent, Population)
city 테이블: 도시 정보 (ID, Name, CountryCode, Population)
```

도시와 그 국가 정보를 함께 보려면 JOIN이 필요합니다!

---

## 2. INNER JOIN

`INNER JOIN`은 **두 테이블에서 조건이 일치하는 행만** 조회합니다.

### 2.1. 기본 문법

```sql
SELECT
    컬럼목록
FROM
    테이블1
INNER JOIN
    테이블2 ON 테이블1.공통컬럼 = 테이블2.공통컬럼;
```

**핵심 키워드:**
- `INNER JOIN`: 조인할 테이블 지정
- `ON`: 조인 조건 (어떤 컬럼을 기준으로 연결할지)

### 2.2. 첫 번째 예제

```sql
-- 도시와 해당 국가명 함께 조회
SELECT
    city.Name AS 도시명,
    country.Name AS 국가명
FROM
    city
INNER JOIN
    country ON city.CountryCode = country.Code
LIMIT 10;
```

**결과 예시:**
```
+---------------+----------------+
| 도시명        | 국가명         |
+---------------+----------------+
| Kabul         | Afghanistan    |
| Qandahar      | Afghanistan    |
| Herat         | Afghanistan    |
| Mazar-e-Sharif| Afghanistan    |
| Amsterdam     | Netherlands    |
+---------------+----------------+
```

---

## 3. 테이블 별칭 (Alias)

테이블 이름이 길 때 **별칭**을 사용하면 쿼리가 간결해집니다.

```sql
-- 별칭 사용
SELECT
    ci.Name AS 도시명,
    co.Name AS 국가명,
    ci.Population AS 도시인구
FROM
    city ci
INNER JOIN
    country co ON ci.CountryCode = co.Code
LIMIT 10;
```

**권장 사항:**
- 짧고 의미있는 별칭 사용 (ci, co, c1, c2 등)
- 복잡한 쿼리에서는 필수

---

## 4. 다중 컬럼 조회

### 4.1. 여러 컬럼 선택

```sql
SELECT
    ci.Name AS 도시명,
    co.Name AS 국가명,
    co.Continent AS 대륙,
    ci.Population AS 도시인구,
    co.Population AS 국가인구
FROM
    city ci
INNER JOIN
    country co ON ci.CountryCode = co.Code
ORDER BY ci.Population DESC
LIMIT 10;
```

### 4.2. 계산된 컬럼

```sql
-- 도시 인구가 국가 인구에서 차지하는 비율
SELECT
    ci.Name AS 도시명,
    co.Name AS 국가명,
    ci.Population AS 도시인구,
    co.Population AS 국가인구,
    ROUND(ci.Population / co.Population * 100, 2) AS 인구비율
FROM
    city ci
INNER JOIN
    country co ON ci.CountryCode = co.Code
ORDER BY 인구비율 DESC
LIMIT 10;
```

---

## 5. WHERE 절과 함께 사용

JOIN 후 조건으로 필터링할 수 있습니다.

### 5.1. 특정 대륙의 도시

```sql
-- 아시아 국가의 대도시
SELECT
    ci.Name AS 도시명,
    co.Name AS 국가명,
    ci.Population AS 인구
FROM
    city ci
INNER JOIN
    country co ON ci.CountryCode = co.Code
WHERE
    co.Continent = 'Asia'
    AND ci.Population >= 5000000
ORDER BY ci.Population DESC;
```

### 5.2. 특정 국가의 도시

```sql
-- 대한민국의 모든 도시
SELECT
    ci.Name AS 도시명,
    ci.Population AS 인구
FROM
    city ci
INNER JOIN
    country co ON ci.CountryCode = co.Code
WHERE
    co.Name = 'South Korea'
ORDER BY ci.Population DESC;
```

---

## 6. 집계 함수와 JOIN

### 6.1. 국가별 도시 개수

```sql
SELECT
    co.Name AS 국가명,
    COUNT(ci.ID) AS 도시개수
FROM
    country co
INNER JOIN
    city ci ON co.Code = ci.CountryCode
GROUP BY co.Code, co.Name
ORDER BY 도시개수 DESC
LIMIT 10;
```

### 6.2. 대륙별 도시 통계

```sql
SELECT
    co.Continent AS 대륙,
    COUNT(ci.ID) AS 총도시수,
    SUM(ci.Population) AS 도시인구합계,
    ROUND(AVG(ci.Population), 0) AS 평균도시인구
FROM
    country co
INNER JOIN
    city ci ON co.Code = ci.CountryCode
GROUP BY co.Continent
ORDER BY 총도시수 DESC;
```

---

## 7. INNER JOIN의 특징

### 7.1. 교집합만 반환

```sql
-- 도시가 하나도 없는 국가는 결과에 포함되지 않음
SELECT
    COUNT(DISTINCT co.Code) AS JOIN결과_국가수,
    (SELECT COUNT(*) FROM country) AS 전체_국가수
FROM
    country co
INNER JOIN
    city ci ON co.Code = ci.CountryCode;
```

**결과:**
- INNER JOIN은 city 테이블에 데이터가 있는 국가만 포함
- 도시 데이터가 없는 국가는 제외됨

### 7.2. 명시적 vs 암묵적 INNER JOIN

```sql
-- 명시적 (권장)
SELECT ci.Name, co.Name
FROM city ci
INNER JOIN country co ON ci.CountryCode = co.Code
LIMIT 5;

-- 암묵적 (비권장)
SELECT ci.Name, co.Name
FROM city ci, country co
WHERE ci.CountryCode = co.Code
LIMIT 5;
```

**권장:** 명시적 `INNER JOIN` 문법이 가독성이 좋고 의도가 명확합니다.

---

## 8. LEFT JOIN (LEFT OUTER JOIN)

`LEFT JOIN`은 **왼쪽 테이블(FROM 절의 테이블)의 모든 행**을 포함합니다.

### 8.1. 기본 문법

```sql
SELECT
    컬럼목록
FROM
    테이블1  -- 왼쪽 테이블 (모든 행 포함)
LEFT JOIN
    테이블2 ON 조인조건;
```

### 8.2. 기본 예제

```sql
-- 모든 국가와 해당 국가의 도시 (도시가 없어도 국가는 표시)
SELECT
    co.Name AS 국가명,
    ci.Name AS 도시명
FROM
    country co
LEFT JOIN
    city ci ON co.Code = ci.CountryCode
ORDER BY co.Name
LIMIT 20;
```

**결과:**
- 도시 데이터가 있는 국가: 국가명과 도시명 표시
- 도시 데이터가 없는 국가: 국가명만 표시, 도시명은 NULL

### 8.3. NULL 체크

```sql
-- 도시 데이터가 없는 국가 찾기
SELECT
    co.Name AS 국가명,
    co.Population AS 인구
FROM
    country co
LEFT JOIN
    city ci ON co.Code = ci.CountryCode
WHERE
    ci.ID IS NULL
ORDER BY co.Population DESC;
```

**활용:** 관계가 설정되지 않은 데이터 찾기 (데이터 검증)

---

## 9. RIGHT JOIN (RIGHT OUTER JOIN)

`RIGHT JOIN`은 **오른쪽 테이블(JOIN 절의 테이블)의 모든 행**을 포함합니다.

### 9.1. 기본 문법

```sql
SELECT
    컬럼목록
FROM
    테이블1
RIGHT JOIN
    테이블2 ON 조인조건;  -- 오른쪽 테이블 (모든 행 포함)
```

### 9.2. 예제

```sql
-- 모든 도시와 해당 국가 (국가 정보가 없어도 도시는 표시)
SELECT
    ci.Name AS 도시명,
    co.Name AS 국가명
FROM
    country co
RIGHT JOIN
    city ci ON co.Code = ci.CountryCode
LIMIT 20;
```

**참고:** 이 예제에서는 외래 키 제약이 있어 모든 도시에 국가가 있으므로, INNER JOIN과 결과가 같습니다.

### 9.3. LEFT JOIN vs RIGHT JOIN

```sql
-- 이 두 쿼리는 같은 결과
-- LEFT JOIN
SELECT ci.Name, co.Name
FROM city ci
LEFT JOIN country co ON ci.CountryCode = co.Code
LIMIT 10;

-- RIGHT JOIN (테이블 순서 바꿈)
SELECT ci.Name, co.Name
FROM country co
RIGHT JOIN city ci ON co.Code = ci.CountryCode
LIMIT 10;
```

**실무 팁:** LEFT JOIN이 더 직관적이어서 많이 사용됩니다.

---

## 10. FULL OUTER JOIN

`FULL OUTER JOIN`은 **양쪽 테이블의 모든 행**을 포함합니다.

### 10.1. MySQL에서의 FULL OUTER JOIN

**주의:** MySQL은 FULL OUTER JOIN을 직접 지원하지 않습니다.
LEFT JOIN + RIGHT JOIN + UNION으로 구현해야 합니다.

```sql
-- FULL OUTER JOIN 시뮬레이션
SELECT
    co.Name AS 국가명,
    ci.Name AS 도시명
FROM
    country co
LEFT JOIN
    city ci ON co.Code = ci.CountryCode

UNION

SELECT
    co.Name AS 국가명,
    ci.Name AS 도시명
FROM
    country co
RIGHT JOIN
    city ci ON co.Code = ci.CountryCode
LIMIT 50;
```

**실무에서는:** PostgreSQL, Oracle 등은 FULL OUTER JOIN을 지원합니다.

---

## 11. OUTER JOIN 활용 패턴

### 11.1. 데이터 존재 여부 확인

```sql
-- 도시가 등록되지 않은 국가 (인구 순)
SELECT
    co.Name AS 국가명,
    co.Continent AS 대륙,
    co.Population AS 인구
FROM
    country co
LEFT JOIN
    city ci ON co.Code = ci.CountryCode
WHERE
    ci.ID IS NULL
ORDER BY co.Population DESC
LIMIT 20;
```

### 11.2. 집계와 함께 사용

```sql
-- 국가별 등록된 도시 수 (도시가 없으면 0)
SELECT
    co.Name AS 국가명,
    co.Continent AS 대륙,
    COUNT(ci.ID) AS 도시수
FROM
    country co
LEFT JOIN
    city ci ON co.Code = ci.CountryCode
GROUP BY co.Code, co.Name, co.Continent
HAVING COUNT(ci.ID) = 0
ORDER BY co.Population DESC
LIMIT 10;
```

### 11.3. COALESCE로 NULL 처리

```sql
-- NULL을 기본값으로 대체
SELECT
    co.Name AS 국가명,
    COALESCE(ci.Name, '도시 없음') AS 도시명,
    COALESCE(ci.Population, 0) AS 도시인구
FROM
    country co
LEFT JOIN
    city ci ON co.Code = ci.CountryCode
ORDER BY co.Name
LIMIT 20;
```

---

## 12. CROSS JOIN

`CROSS JOIN`은 **두 테이블의 모든 행을 조합**합니다 (카티시안 곱, Cartesian Product).

### 12.1. 기본 개념

```sql
SELECT *
FROM 테이블1
CROSS JOIN 테이블2;
```

**결과:** 테이블1의 각 행과 테이블2의 모든 행이 조합됨
- 테이블1: 3행, 테이블2: 4행 → 결과: 12행 (3 × 4)

### 12.2. 예제

```sql
-- 대륙과 지역의 모든 조합
SELECT
    co1.Continent AS 대륙,
    co2.Region AS 지역
FROM
    (SELECT DISTINCT Continent FROM country) co1
CROSS JOIN
    (SELECT DISTINCT Region FROM country LIMIT 5) co2
LIMIT 20;
```

### 12.3. 실무 활용

**사용 예시:**
- 모든 제품과 모든 색상의 조합
- 날짜 테이블과 카테고리의 조합 (빈 데이터 채우기)
- 테스트 데이터 생성

**주의:**
- 결과 행 수가 매우 많아질 수 있음
- 일반적으로 WHERE 절과 함께 사용하여 필터링

```sql
-- CROSS JOIN + WHERE (INNER JOIN과 유사)
SELECT
    ci.Name AS 도시명,
    co.Name AS 국가명
FROM
    city ci
CROSS JOIN
    country co
WHERE
    ci.CountryCode = co.Code
LIMIT 10;
```

---

## 13. SELF JOIN

`SELF JOIN`은 **같은 테이블을 자기 자신과 조인**하는 기법입니다.

### 13.1. 기본 개념

```sql
SELECT
    컬럼목록
FROM
    테이블 별칭1
INNER JOIN
    테이블 별칭2 ON 조건;
```

**핵심:** 반드시 **별칭을 다르게** 지정하여 구분해야 합니다.

### 13.2. 예제 1: 같은 인구를 가진 도시 찾기

```sql
-- 인구가 같은 다른 도시 쌍 찾기
SELECT
    c1.Name AS 도시1,
    c2.Name AS 도시2,
    c1.Population AS 인구
FROM
    city c1
INNER JOIN
    city c2 ON c1.Population = c2.Population
    AND c1.ID < c2.ID  -- 중복 방지: ID가 작은 것만
ORDER BY c1.Population DESC
LIMIT 10;
```

**`c1.ID < c2.ID` 설명:**
- `c1.ID != c2.ID`: 자기 자신 제외
- `c1.ID < c2.ID`: (도시A, 도시B)와 (도시B, 도시A) 중복 제거

### 13.3. 예제 2: 같은 국가의 도시 쌍

```sql
-- 같은 국가에 속한 도시 쌍
SELECT
    c1.Name AS 도시1,
    c2.Name AS 도시2,
    c1.CountryCode AS 국가코드
FROM
    city c1
INNER JOIN
    city c2 ON c1.CountryCode = c2.CountryCode
    AND c1.ID < c2.ID
WHERE
    c1.CountryCode = 'KOR'  -- 대한민국만
ORDER BY c1.Population DESC;
```

### 13.4. 실무 활용

**사용 예시:**
- 조직도에서 상사-부하 관계 찾기
- 같은 카테고리의 상품 비교
- 친구 관계 (A와 B가 친구)
- 같은 속성을 가진 레코드 찾기

---

## 14. 다중 JOIN

여러 테이블을 연속해서 JOIN할 수 있습니다.

```sql
-- 국가 → 도시 → 국가언어 (countrylanguage 테이블)
SELECT
    co.Name AS 국가명,
    ci.Name AS 도시명,
    cl.Language AS 언어,
    cl.Percentage AS 사용비율
FROM
    country co
LEFT JOIN
    city ci ON co.Code = ci.CountryCode
LEFT JOIN
    countrylanguage cl ON co.Code = cl.CountryCode
WHERE
    co.Name = 'South Korea'
ORDER BY cl.Percentage DESC
LIMIT 20;
```

---

## 실습 문제

이제 **sakila 데이터베이스**로 실습해봅시다.

```sql
USE sakila;
```

### 문제 1: INNER JOIN 기본

영화(`film`)와 언어(`language`) 테이블을 조인하여 다음을 조회하세요:
- 영화 제목 (`film.title`)
- 언어 이름 (`language.name`)
- 상위 10개

**힌트:** `film.language_id = language.language_id`

**예상 답:**
```sql
SELECT
    f.title AS 영화제목,
    l.name AS 언어
FROM
    film f
INNER JOIN
    language l ON f.language_id = l.language_id
LIMIT 10;
```

### 문제 2: 다중 JOIN

영화와 카테고리를 조인하여 다음을 조회하세요:
- 영화 제목
- 카테고리 이름
- 대여료
- 상위 15개

**힌트:** `film` ← `film_category` → `category` (2개의 JOIN 필요)

**예상 답:**
```sql
SELECT
    f.title AS 영화제목,
    c.name AS 카테고리,
    f.rental_rate AS 대여료
FROM
    film f
INNER JOIN
    film_category fc ON f.film_id = fc.film_id
INNER JOIN
    category c ON fc.category_id = c.category_id
LIMIT 15;
```

### 문제 3: LEFT JOIN

모든 고객(`customer`)과 그들의 대여 내역(`rental`)을 조회하세요.
- 고객 이름 (first_name, last_name)
- 대여 ID (rental_id)
- 대여 날짜 (rental_date)
- 상위 20개

**힌트:** `customer.customer_id = rental.customer_id`

**예상 답:**
```sql
SELECT
    c.first_name,
    c.last_name,
    r.rental_id,
    r.rental_date
FROM
    customer c
LEFT JOIN
    rental r ON c.customer_id = r.customer_id
ORDER BY c.last_name, c.first_name
LIMIT 20;
```

### 문제 4: LEFT JOIN + NULL 체크

대여 기록이 없는 고객을 찾으세요.

**예상 답:**
```sql
SELECT
    c.customer_id,
    c.first_name,
    c.last_name,
    c.email
FROM
    customer c
LEFT JOIN
    rental r ON c.customer_id = r.customer_id
WHERE
    r.rental_id IS NULL;
```

### 문제 5: 집계와 LEFT JOIN

고객별 대여 횟수를 조회하세요. (대여 횟수 0인 고객도 포함)
- 고객 이름
- 대여 횟수
- 대여 횟수가 많은 순서

**예상 답:**
```sql
SELECT
    c.first_name,
    c.last_name,
    COUNT(r.rental_id) AS 대여횟수
FROM
    customer c
LEFT JOIN
    rental r ON c.customer_id = r.customer_id
GROUP BY c.customer_id, c.first_name, c.last_name
ORDER BY 대여횟수 DESC
LIMIT 20;
```

### 문제 6: SELF JOIN

같은 상영 시간(`length`)을 가진 영화 쌍을 찾으세요.
- 영화1 제목
- 영화2 제목
- 상영 시간
- 상위 10개

**예상 답:**
```sql
SELECT
    f1.title AS 영화1,
    f2.title AS 영화2,
    f1.length AS 상영시간
FROM
    film f1
INNER JOIN
    film f2 ON f1.length = f2.length
    AND f1.film_id < f2.film_id
ORDER BY f1.length DESC
LIMIT 10;
```

---

## 강사 가이드

### 데이터베이스 활용 전략

1. **world DB (강의 설명 및 예제)**
   - city ↔ country 관계는 직관적 (도시-국가)
   - INNER JOIN: 교집합 개념 명확
   - LEFT JOIN: "도시 없는 국가" 찾기로 NULL 이해
   - SELF JOIN: 같은 인구, 같은 국가의 도시 쌍

2. **sakila DB (실습 문제)**
   - 복잡한 N:M 관계 (film ↔ film_category ↔ category)
   - 중간 테이블(junction table) 경험
   - 실무에 가까운 다중 JOIN 연습

3. **수업 진행 흐름**
   ```
   1. world DB로 INNER JOIN 기본 개념
   2. LEFT/RIGHT JOIN과 NULL 처리
   3. CROSS JOIN (카티시안 곱 주의)
   4. SELF JOIN (별칭 필수)
   5. sakila DB로 복잡한 JOIN 실습
   ```

### 핵심 포인트

1. **ON 절 이해**: 어떤 컬럼으로 연결하는지가 핵심
2. **FK 관계 파악**: ERD나 테이블 구조 먼저 확인
3. **INNER vs OUTER**: 교집합 vs 한쪽 기준 전체
4. **별칭 사용 습관**: 쿼리 가독성 향상
5. **NULL 처리**: LEFT JOIN 후 IS NULL 체크 패턴
6. **CROSS JOIN 주의**: 행 수 폭발 가능성
7. **SELF JOIN 별칭**: 반드시 다른 별칭 사용

### 자주 하는 질문

**Q: INNER JOIN과 WHERE의 차이는?**
A: JOIN은 테이블 연결, WHERE는 결과 필터링. JOIN 후 WHERE로 조건 추가.

**Q: ON과 WHERE에 조건을 쓰는 차이는?**
A: INNER JOIN에서는 결과가 같지만, OUTER JOIN에서는 다름. ON은 조인 조건, WHERE는 결과 필터링.

**Q: LEFT JOIN과 INNER JOIN 중 어느 것이 빠른가요?**
A: 데이터와 인덱스에 따라 다르지만, 일반적으로 INNER JOIN이 약간 빠름. 하지만 **필요에 따라 선택**해야 함.

**Q: CROSS JOIN은 언제 사용하나요?**
A: 모든 조합이 필요할 때 (제품×색상, 날짜×카테고리). 일반적으로 드물게 사용.

**Q: SELF JOIN은 언제 사용하나요?**
A: 같은 테이블 내 행 간 관계를 찾을 때 (조직도, 같은 속성 비교).

**Q: 여러 테이블을 한 번에 JOIN할 수 있나요?**
A: 네, 필요한 만큼 JOIN을 연결하여 사용 가능합니다.

### 실습 진행 팁

1. **ERD 먼저 확인**: 테이블 관계 파악
2. **작은 단위부터**: 2개 테이블 JOIN → 확장
3. **결과 확인 습관**: LIMIT으로 먼저 확인 후 전체 실행
4. **실수 체험**: ON 조건 없으면 Cartesian Product 발생
5. **INNER vs LEFT 비교**: 같은 쿼리를 두 방식으로 실행해서 결과 비교
6. **NULL 체험**: LEFT JOIN 후 WHERE IS NULL로 누락 데이터 찾기

---

## 요약

### INNER JOIN
- **개념**: 두 테이블에서 조건이 일치하는 행만 조회 (교집합)
- **문법**: `FROM 테이블1 INNER JOIN 테이블2 ON 조인조건`
- **특징**: 양쪽 테이블 모두 데이터가 있는 행만 반환

### LEFT JOIN
- **개념**: 왼쪽 테이블의 모든 행 포함, 오른쪽은 일치하면 연결, 없으면 NULL
- **활용**: 데이터 존재 여부 확인 (WHERE IS NULL), 집계 시 0 포함

### RIGHT JOIN
- **개념**: 오른쪽 테이블의 모든 행 포함 (LEFT JOIN의 반대)
- **실무**: LEFT JOIN으로 대체 가능하여 사용 빈도 낮음

### FULL OUTER JOIN
- **개념**: 양쪽 테이블의 모든 행 포함
- **MySQL**: 직접 지원 안 함, UNION으로 구현

### CROSS JOIN
- **개념**: 두 테이블의 모든 행을 조합 (카티시안 곱)
- **주의**: 결과 행 수 = 테이블1 행 수 × 테이블2 행 수
- **활용**: 모든 조합 생성, 테스트 데이터

### SELF JOIN
- **개념**: 같은 테이블을 자기 자신과 조인
- **핵심**: 반드시 다른 별칭 사용
- **활용**: 같은 테이블 내 행 간 관계 찾기

### 공통 원칙
- **별칭 사용**: `city ci`, `country co` 형태로 간결하게
- **ON 절**: 어떤 컬럼을 기준으로 연결할지 지정 (보통 FK = PK)
- **WHERE 절**: JOIN 후 결과를 조건으로 필터링
- **집계 함수**: JOIN 후 GROUP BY로 그룹별 통계 가능
- **COUNT 주의**: `COUNT(컬럼)`은 NULL 제외, `COUNT(*)`는 모든 행

**다음 단계**: 서브쿼리를 배워 더 복잡한 데이터 조회를 수행합니다!
