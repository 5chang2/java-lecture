# 4.6. 저장 프로시저 (Stored Procedure)

## 학습 목표
- 저장 프로시저의 개념과 필요성을 이해한다
- CREATE PROCEDURE로 프로시저를 생성하고 실행한다
- 매개변수(IN, OUT, INOUT)를 활용한 프로시저를 작성한다
- 변수, 제어문, 커서를 사용하여 복잡한 로직을 구현한다

---

## 1. 저장 프로시저란?

**저장 프로시저(Stored Procedure)**는 데이터베이스에 저장되어 있는 **SQL 문의 집합**입니다. 여러 SQL 문을 하나의 프로그램처럼 묶어서 필요할 때 호출하여 실행할 수 있습니다.

### 저장 프로시저 vs 일반 SQL

```sql
-- 일반 SQL: 매번 작성해야 함
SELECT COUNT(*) FROM city WHERE CountryCode = 'KOR';
SELECT AVG(Population) FROM city WHERE CountryCode = 'KOR';
-- ... 반복적인 쿼리

-- 저장 프로시저: 한 번 정의하고 계속 재사용
CALL get_country_city_stats('KOR');
```

### 저장 프로시저의 특징

| 특징 | 설명 |
|-----|-----|
| **재사용성** | 한 번 작성하면 여러 곳에서 호출 가능 |
| **성능** | 파싱과 최적화를 한 번만 수행 (캐싱) |
| **보안** | 테이블 직접 접근 대신 프로시저를 통한 간접 접근 |
| **유지보수** | 비즈니스 로직을 DB에 중앙화하여 관리 |
| **네트워크 트래픽 감소** | 여러 SQL을 한 번의 호출로 실행 |

---

## 2. 저장 프로시저의 장단점

### 장점

1. **성능 향상**
   - 첫 실행 시 컴파일되어 캐싱됨
   - 반복 실행 시 파싱 과정 생략

2. **네트워크 부하 감소**
   - 여러 SQL을 한 번의 호출로 처리
   - 클라이언트-서버 간 통신 횟수 감소

3. **보안 강화**
   - 테이블 직접 접근 권한 없이 프로시저만 실행 권한 부여
   - SQL Injection 공격 방어

4. **중앙화된 비즈니스 로직**
   - 여러 애플리케이션에서 동일한 로직 사용
   - 로직 변경 시 한 곳만 수정

### 단점

1. **디버깅 어려움**
   - 일반 프로그래밍 언어보다 디버깅 도구 부족

2. **이식성 낮음**
   - DBMS마다 문법이 다름 (MySQL, PostgreSQL, Oracle 등)

3. **버전 관리 어려움**
   - 코드 저장소와 별도로 관리 필요

4. **애플리케이션 로직 분산**
   - DB와 애플리케이션에 로직이 나뉘어 복잡도 증가

---

## 3. 저장 프로시저 생성

### 3.1. 기본 구문

```sql
DELIMITER $$

CREATE PROCEDURE 프로시저명(매개변수)
BEGIN
    -- SQL 문장들
END$$

DELIMITER ;
```

**DELIMITER 설명:**
- MySQL은 기본적으로 `;`를 문장 종료 기호로 인식
- 프로시저 내부에서도 `;`를 사용하므로 충돌 방지를 위해 구분자 변경
- `$$`로 변경 후 프로시저 작성, 완료 후 다시 `;`로 복구

### 3.2. 간단한 예제

```sql
-- DELIMITER 변경
DELIMITER $$

-- 프로시저 생성
CREATE PROCEDURE hello_world()
BEGIN
    SELECT 'Hello, World!' AS message;
END$$

-- DELIMITER 복구
DELIMITER ;

-- 프로시저 실행
CALL hello_world();
```

**실행 결과:**
```
+---------------+
| message       |
+---------------+
| Hello, World! |
+---------------+
```

---

## 4. 매개변수 사용

저장 프로시저는 세 가지 유형의 매개변수를 사용할 수 있습니다.

### 4.1. IN 매개변수 (입력)

프로시저로 값을 전달할 때 사용합니다.

```sql
DELIMITER $$

CREATE PROCEDURE get_city_count(IN country_code CHAR(3))
BEGIN
    SELECT COUNT(*) AS city_count
    FROM city
    WHERE CountryCode = country_code;
END$$

DELIMITER ;

-- 사용
CALL get_city_count('KOR');  -- 한국 도시 수
CALL get_city_count('USA');  -- 미국 도시 수
```

### 4.2. OUT 매개변수 (출력)

프로시저에서 값을 반환할 때 사용합니다.

```sql
DELIMITER $$

CREATE PROCEDURE get_country_population(
    IN country_code CHAR(3),
    OUT total_population INT
)
BEGIN
    SELECT Population INTO total_population
    FROM country
    WHERE Code = country_code;
END$$

DELIMITER ;

-- 사용
CALL get_country_population('KOR', @pop);
SELECT @pop AS '한국 인구';
```

**실행 결과:**
```
+-----------+
| 한국 인구  |
+-----------+
|  46844000 |
+-----------+
```

### 4.3. INOUT 매개변수 (입출력)

입력과 출력을 동시에 사용합니다.

```sql
DELIMITER $$

CREATE PROCEDURE double_value(INOUT num INT)
BEGIN
    SET num = num * 2;
END$$

DELIMITER ;

-- 사용
SET @value = 10;
CALL double_value(@value);
SELECT @value;  -- 20
```

---

## 5. 변수 사용

### 5.1. 지역 변수 선언

```sql
DELIMITER $$

CREATE PROCEDURE calculate_stats(IN country_code CHAR(3))
BEGIN
    -- 변수 선언
    DECLARE city_count INT;
    DECLARE total_pop INT;
    DECLARE avg_pop DECIMAL(10, 2);

    -- 변수에 값 할당
    SELECT COUNT(*), SUM(Population), AVG(Population)
    INTO city_count, total_pop, avg_pop
    FROM city
    WHERE CountryCode = country_code;

    -- 결과 출력
    SELECT
        country_code AS '국가코드',
        city_count AS '도시수',
        total_pop AS '총인구',
        avg_pop AS '평균인구';
END$$

DELIMITER ;

-- 사용
CALL calculate_stats('KOR');
```

### 5.2. 사용자 변수 vs 지역 변수

```sql
-- 사용자 변수: @ 시작, 세션 전체에서 유효
SET @user_var = 100;
SELECT @user_var;

-- 지역 변수: DECLARE로 선언, 프로시저 내에서만 유효
DELIMITER $$
CREATE PROCEDURE local_var_example()
BEGIN
    DECLARE local_var INT DEFAULT 200;
    SELECT local_var;
END$$
DELIMITER ;
```

---

## 6. 제어문

### 6.1. IF 문

```sql
DELIMITER $$

CREATE PROCEDURE classify_city_size(IN city_name VARCHAR(50))
BEGIN
    DECLARE city_pop INT;
    DECLARE size_class VARCHAR(20);

    -- 도시 인구 조회
    SELECT Population INTO city_pop
    FROM city
    WHERE Name = city_name
    LIMIT 1;

    -- 인구에 따른 분류
    IF city_pop >= 10000000 THEN
        SET size_class = '초대형';
    ELSEIF city_pop >= 1000000 THEN
        SET size_class = '대형';
    ELSEIF city_pop >= 100000 THEN
        SET size_class = '중형';
    ELSE
        SET size_class = '소형';
    END IF;

    -- 결과 출력
    SELECT city_name, city_pop, size_class;
END$$

DELIMITER ;

-- 사용
CALL classify_city_size('Seoul');
```

### 6.2. CASE 문

```sql
DELIMITER $$

CREATE PROCEDURE get_continent_description(IN cont_name VARCHAR(50))
BEGIN
    DECLARE description VARCHAR(100);

    SET description = CASE cont_name
        WHEN 'Asia' THEN '아시아 대륙'
        WHEN 'Europe' THEN '유럽 대륙'
        WHEN 'Africa' THEN '아프리카 대륙'
        WHEN 'North America' THEN '북아메리카 대륙'
        WHEN 'South America' THEN '남아메리카 대륙'
        WHEN 'Oceania' THEN '오세아니아 대륙'
        WHEN 'Antarctica' THEN '남극 대륙'
        ELSE '알 수 없는 대륙'
    END;

    SELECT cont_name AS Continent, description AS Description;
END$$

DELIMITER ;

-- 사용
CALL get_continent_description('Asia');
```

### 6.3. LOOP, WHILE, REPEAT

#### LOOP (무한 루프)

```sql
DELIMITER $$

CREATE PROCEDURE print_numbers(IN max_num INT)
BEGIN
    DECLARE counter INT DEFAULT 1;

    my_loop: LOOP
        SELECT counter;
        SET counter = counter + 1;

        IF counter > max_num THEN
            LEAVE my_loop;  -- 루프 탈출
        END IF;
    END LOOP;
END$$

DELIMITER ;
```

#### WHILE

```sql
DELIMITER $$

CREATE PROCEDURE sum_to_n(IN n INT, OUT result INT)
BEGIN
    DECLARE counter INT DEFAULT 1;
    SET result = 0;

    WHILE counter <= n DO
        SET result = result + counter;
        SET counter = counter + 1;
    END WHILE;
END$$

DELIMITER ;

-- 사용: 1부터 100까지의 합
CALL sum_to_n(100, @total);
SELECT @total;  -- 5050
```

#### REPEAT (do-while과 유사)

```sql
DELIMITER $$

CREATE PROCEDURE factorial(IN n INT, OUT result BIGINT)
BEGIN
    DECLARE counter INT DEFAULT 1;
    SET result = 1;

    REPEAT
        SET result = result * counter;
        SET counter = counter + 1;
    UNTIL counter > n
    END REPEAT;
END$$

DELIMITER ;

-- 사용: 5! = 120
CALL factorial(5, @fact);
SELECT @fact;
```

---

## 7. 커서 (Cursor)

커서는 쿼리 결과를 한 행씩 처리할 때 사용합니다.

```sql
DELIMITER $$

CREATE PROCEDURE process_large_cities()
BEGIN
    -- 변수 선언
    DECLARE done INT DEFAULT FALSE;
    DECLARE city_name VARCHAR(50);
    DECLARE city_pop INT;

    -- 커서 선언
    DECLARE city_cursor CURSOR FOR
        SELECT Name, Population
        FROM city
        WHERE Population >= 5000000
        ORDER BY Population DESC;

    -- 핸들러 선언 (더 이상 행이 없을 때)
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    -- 임시 결과 테이블 생성
    CREATE TEMPORARY TABLE IF NOT EXISTS city_results (
        city_name VARCHAR(50),
        population INT,
        category VARCHAR(20)
    );

    -- 커서 열기
    OPEN city_cursor;

    -- 루프 시작
    read_loop: LOOP
        -- 한 행씩 읽기
        FETCH city_cursor INTO city_name, city_pop;

        IF done THEN
            LEAVE read_loop;
        END IF;

        -- 데이터 처리 및 삽입
        INSERT INTO city_results VALUES (
            city_name,
            city_pop,
            IF(city_pop >= 10000000, '초대형', '대형')
        );
    END LOOP;

    -- 커서 닫기
    CLOSE city_cursor;

    -- 결과 조회
    SELECT * FROM city_results;

    -- 임시 테이블 삭제
    DROP TEMPORARY TABLE IF EXISTS city_results;
END$$

DELIMITER ;

-- 사용
CALL process_large_cities();
```

---

## 8. 오류 처리

### 8.1. DECLARE HANDLER

```sql
DELIMITER $$

CREATE PROCEDURE safe_divide(IN numerator INT, IN denominator INT, OUT result DECIMAL(10,2))
BEGIN
    -- 오류 핸들러 선언
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        SET result = NULL;
        SELECT 'Error: Division failed' AS ErrorMessage;
    END;

    -- 0으로 나누기 시도
    IF denominator = 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Cannot divide by zero';
    ELSE
        SET result = numerator / denominator;
    END IF;
END$$

DELIMITER ;

-- 정상 케이스
CALL safe_divide(10, 2, @res);
SELECT @res;  -- 5.00

-- 오류 케이스
CALL safe_divide(10, 0, @res);
SELECT @res;  -- NULL
```

### 8.2. 트랜잭션과 함께 사용

```sql
DELIMITER $$

CREATE PROCEDURE transfer_balance(
    IN from_account INT,
    IN to_account INT,
    IN amount DECIMAL(10,2)
)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SELECT 'Transaction failed, rolled back' AS Message;
    END;

    START TRANSACTION;

    -- 출금 계좌에서 차감
    UPDATE accounts SET balance = balance - amount
    WHERE account_id = from_account;

    -- 입금 계좌에 추가
    UPDATE accounts SET balance = balance + amount
    WHERE account_id = to_account;

    COMMIT;
    SELECT 'Transaction successful' AS Message;
END$$

DELIMITER ;
```

---

## 9. 프로시저 관리

### 9.1. 프로시저 목록 조회

```sql
-- 현재 데이터베이스의 모든 프로시저 조회
SHOW PROCEDURE STATUS WHERE Db = 'world';

-- 특정 프로시저의 정의 확인
SHOW CREATE PROCEDURE get_city_count;
```

### 9.2. 프로시저 수정

```sql
-- MySQL은 ALTER PROCEDURE로 특성만 변경 가능 (본문 수정 불가)
-- 본문 수정은 DROP 후 재생성 필요

DROP PROCEDURE IF EXISTS get_city_count;

DELIMITER $$
CREATE PROCEDURE get_city_count(IN country_code CHAR(3))
BEGIN
    -- 수정된 내용
    SELECT COUNT(*) AS total_cities
    FROM city
    WHERE CountryCode = country_code;
END$$
DELIMITER ;
```

### 9.3. 프로시저 삭제

```sql
DROP PROCEDURE IF EXISTS get_city_count;
```

---

## 10. 실습 문제

sakila 데이터베이스를 사용하여 다음 프로시저를 작성하세요.

### 문제 1: 배우 영화 수 조회 (난이도: ⭐)

배우 ID를 입력받아 해당 배우가 출연한 영화 수를 반환하는 프로시저 `get_actor_film_count`를 작성하세요.

**매개변수:**
- IN: actor_id (INT)
- OUT: film_count (INT)

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
DELIMITER $$

CREATE PROCEDURE get_actor_film_count(
    IN p_actor_id INT,
    OUT p_film_count INT
)
BEGIN
    SELECT COUNT(*)
    INTO p_film_count
    FROM film_actor
    WHERE actor_id = p_actor_id;
END$$

DELIMITER ;

-- 사용
CALL get_actor_film_count(1, @count);
SELECT @count AS '출연 영화 수';
```
</details>

---

### 문제 2: 영화 대여 가능 여부 확인 (난이도: ⭐⭐)

영화 ID를 입력받아 대여 가능 여부를 확인하는 프로시저 `check_film_availability`를 작성하세요.

**매개변수:**
- IN: film_id (INT)
- OUT: is_available (VARCHAR) - 'Available' 또는 'Not Available'

**조건:** inventory 테이블에서 해당 영화의 재고가 1개 이상이면 'Available'

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
DELIMITER $$

CREATE PROCEDURE check_film_availability(
    IN p_film_id INT,
    OUT p_is_available VARCHAR(20)
)
BEGIN
    DECLARE inventory_count INT;

    SELECT COUNT(*)
    INTO inventory_count
    FROM inventory
    WHERE film_id = p_film_id;

    IF inventory_count > 0 THEN
        SET p_is_available = 'Available';
    ELSE
        SET p_is_available = 'Not Available';
    END IF;
END$$

DELIMITER ;

-- 사용
CALL check_film_availability(1, @status);
SELECT @status;
```
</details>

---

### 문제 3: 고객 등급 분류 (난이도: ⭐⭐⭐)

고객 ID를 입력받아 총 결제 금액에 따라 등급을 분류하는 프로시저 `classify_customer_tier`를 작성하세요.

**매개변수:**
- IN: customer_id (INT)
- OUT: total_amount (DECIMAL)
- OUT: tier (VARCHAR)

**등급 기준:**
- $200 이상: 'VIP'
- $100 이상: 'Gold'
- $50 이상: 'Silver'
- 그 외: 'Bronze'

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
DELIMITER $$

CREATE PROCEDURE classify_customer_tier(
    IN p_customer_id INT,
    OUT p_total_amount DECIMAL(10,2),
    OUT p_tier VARCHAR(10)
)
BEGIN
    -- 총 결제 금액 조회
    SELECT COALESCE(SUM(amount), 0)
    INTO p_total_amount
    FROM payment
    WHERE customer_id = p_customer_id;

    -- 등급 분류
    IF p_total_amount >= 200 THEN
        SET p_tier = 'VIP';
    ELSEIF p_total_amount >= 100 THEN
        SET p_tier = 'Gold';
    ELSEIF p_total_amount >= 50 THEN
        SET p_tier = 'Silver';
    ELSE
        SET p_tier = 'Bronze';
    END IF;
END$$

DELIMITER ;

-- 사용
CALL classify_customer_tier(1, @amount, @tier);
SELECT @amount AS '총 결제액', @tier AS '등급';
```
</details>

---

### 문제 4: 영화 카테고리별 통계 (난이도: ⭐⭐⭐)

모든 영화 카테고리를 순회하며 각 카테고리의 영화 수와 평균 대여 가격을 출력하는 프로시저 `category_statistics`를 작성하세요.

**힌트:** 커서를 사용하여 category 테이블을 순회

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
DELIMITER $$

CREATE PROCEDURE category_statistics()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE cat_id INT;
    DECLARE cat_name VARCHAR(50);
    DECLARE film_count INT;
    DECLARE avg_rate DECIMAL(4,2);

    -- 커서 선언
    DECLARE cat_cursor CURSOR FOR
        SELECT category_id, name FROM category;

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    -- 임시 결과 테이블
    CREATE TEMPORARY TABLE IF NOT EXISTS temp_stats (
        category_name VARCHAR(50),
        film_count INT,
        avg_rental_rate DECIMAL(4,2)
    );

    OPEN cat_cursor;

    read_loop: LOOP
        FETCH cat_cursor INTO cat_id, cat_name;

        IF done THEN
            LEAVE read_loop;
        END IF;

        -- 카테고리별 통계 계산
        SELECT COUNT(fc.film_id), COALESCE(AVG(f.rental_rate), 0)
        INTO film_count, avg_rate
        FROM film_category fc
        LEFT JOIN film f ON fc.film_id = f.film_id
        WHERE fc.category_id = cat_id;

        INSERT INTO temp_stats VALUES (cat_name, film_count, avg_rate);
    END LOOP;

    CLOSE cat_cursor;

    SELECT * FROM temp_stats ORDER BY film_count DESC;

    DROP TEMPORARY TABLE IF EXISTS temp_stats;
END$$

DELIMITER ;

-- 사용
CALL category_statistics();
```
</details>

---

### 문제 5: 영화 대여 처리 (난이도: ⭐⭐⭐⭐)

영화 대여를 처리하는 프로시저 `rent_film`을 작성하세요. 재고 확인, 대여 기록 생성, 오류 처리를 포함해야 합니다.

**매개변수:**
- IN: p_customer_id (INT)
- IN: p_film_id (INT)
- IN: p_staff_id (INT)
- OUT: p_result (VARCHAR) - 성공/실패 메시지

**조건:**
- 재고가 있는지 확인
- 재고가 있으면 rental 테이블에 기록
- 트랜잭션 사용
- 오류 시 롤백

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
DELIMITER $$

CREATE PROCEDURE rent_film(
    IN p_customer_id INT,
    IN p_film_id INT,
    IN p_staff_id INT,
    OUT p_result VARCHAR(100)
)
BEGIN
    DECLARE v_inventory_id INT;
    DECLARE v_store_id INT;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_result = 'Error: Rental failed';
    END;

    START TRANSACTION;

    -- 재고 확인 (대여 가능한 것 중 첫 번째)
    SELECT inventory_id, store_id
    INTO v_inventory_id, v_store_id
    FROM inventory
    WHERE film_id = p_film_id
    AND inventory_id NOT IN (
        SELECT inventory_id FROM rental WHERE return_date IS NULL
    )
    LIMIT 1;

    -- 재고가 없으면 에러
    IF v_inventory_id IS NULL THEN
        SET p_result = 'Error: No available inventory';
        ROLLBACK;
    ELSE
        -- 대여 기록 생성
        INSERT INTO rental (rental_date, inventory_id, customer_id, staff_id)
        VALUES (NOW(), v_inventory_id, p_customer_id, p_staff_id);

        SET p_result = CONCAT('Success: Rental ID ', LAST_INSERT_ID());
        COMMIT;
    END IF;
END$$

DELIMITER ;

-- 사용
CALL rent_film(1, 1, 1, @result);
SELECT @result;
```
</details>

---

## 강사 가이드

### 수업 진행 팁

1. **저장 프로시저의 필요성부터 설명** (10분)
   - "같은 쿼리를 100번 작성해본 적 있나요?" 질문으로 시작
   - 반복 작업의 불편함 → 프로시저의 재사용성 강조
   - 네트워크 트래픽 감소, 보안 향상 등 실무적 이점 설명

2. **DELIMITER 개념 명확히** (5분)
   - 왜 DELIMITER를 바꿔야 하는지 설명
   - `;` 충돌 문제를 간단한 예제로 시연
   - `$$` 대신 `//`나 다른 기호도 가능하다는 점 언급

3. **간단한 예제부터 시작** (15분)
   - hello_world() 부터 실습
   - IN 매개변수 → OUT 매개변수 → INOUT 순서로 진행
   - 각 단계마다 실습 시간 충분히 제공

4. **제어문과 커서는 점진적으로** (25분)
   - IF 문 → CASE → LOOP 순서로 난이도 증가
   - 커서는 마지막에 다루되, "꼭 필요할 때만 사용" 강조
   - 대부분의 경우 JOIN이나 서브쿼리로 해결 가능함을 설명

5. **실무 활용 사례 소개** (10분)
   - 배치 작업 (일일 통계 계산)
   - 복잡한 비즈니스 로직 (주문 처리, 재고 관리)
   - 데이터 검증 및 정제
   - 오류 처리 및 로깅

6. **주의사항 강조** (5분)
   - 프로시저 남용 금지 (모든 로직을 DB에 넣지 말 것)
   - 디버깅 어려움 → 충분한 로깅 필요
   - DBMS 종속성 → 이식성 고려

### 자주 하는 질문

**Q1: 저장 프로시저와 함수(Function)의 차이는?**
> A:
> - **저장 프로시저**: CALL로 호출, 여러 결과 반환 가능, 트랜잭션 사용 가능
> - **함수**: SELECT 문에서 사용, 단일 값 반환, 트랜잭션 사용 불가
> ```sql
> CALL my_procedure(1, @result);  -- 프로시저
> SELECT my_function(1);          -- 함수
> ```

**Q2: 프로시저 안에서 또 다른 프로시저를 호출할 수 있나요?**
> A: 네, 가능합니다. CALL 문으로 다른 프로시저를 호출할 수 있습니다. 단, 무한 재귀 호출에 주의해야 합니다.

**Q3: 커서를 꼭 사용해야 하나요?**
> A: 대부분의 경우 커서 대신 JOIN이나 서브쿼리로 해결할 수 있습니다. 커서는 성능이 떨어지므로 정말 필요할 때만 사용하세요. 일반적으로 집합 기반(set-based) 접근이 더 효율적입니다.

**Q4: 프로시저에서 동적 SQL을 사용할 수 있나요?**
> A: 네, PREPARE와 EXECUTE를 사용하여 동적 SQL을 실행할 수 있습니다.
> ```sql
> SET @sql = CONCAT('SELECT * FROM ', table_name);
> PREPARE stmt FROM @sql;
> EXECUTE stmt;
> DEALLOCATE PREPARE stmt;
> ```

**Q5: 프로시저 디버깅은 어떻게 하나요?**
> A:
> - SELECT 문으로 중간 값 출력
> - 임시 테이블에 로그 기록
> - MySQL Workbench의 디버거 사용
> - 단계별로 작은 프로시저로 나눠서 테스트

### 실습 중 흔한 실수

1. **DELIMITER 설정 누락**
```sql
-- ❌ 에러 발생 (DELIMITER 설정 안 함)
CREATE PROCEDURE test()
BEGIN
    SELECT 1;
END;

-- ✅ 올바른 방법
DELIMITER $$
CREATE PROCEDURE test()
BEGIN
    SELECT 1;
END$$
DELIMITER ;
```

2. **변수 이름 충돌**
```sql
-- ❌ 매개변수 이름과 컬럼 이름이 같음
CREATE PROCEDURE get_user(IN user_id INT)
BEGIN
    SELECT * FROM users WHERE user_id = user_id;  -- 항상 참
END

-- ✅ 접두사 사용
CREATE PROCEDURE get_user(IN p_user_id INT)
BEGIN
    SELECT * FROM users WHERE user_id = p_user_id;
END
```

3. **커서 핸들러 순서**
```sql
-- ❌ 핸들러를 커서보다 먼저 선언
DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
DECLARE cur CURSOR FOR SELECT * FROM table;

-- ✅ 커서 선언 후 핸들러 선언
DECLARE cur CURSOR FOR SELECT * FROM table;
DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
```

4. **OUT 매개변수 사용법**
```sql
-- ❌ 직접 값을 전달
CALL get_count('KOR', 100);  -- 에러

-- ✅ 변수를 전달
CALL get_count('KOR', @result);
SELECT @result;
```

### 추가 실습 아이디어

1. **일괄 처리**: 여러 도시의 인구를 한 번에 업데이트하는 프로시저
2. **데이터 검증**: 삽입 전 데이터 유효성 검사 프로시저
3. **통계 생성**: 일일/월간 통계를 계산하여 별도 테이블에 저장
4. **재귀 프로시저**: 조직도 계층 구조 조회

---

## 요약

### 핵심 개념

1. **저장 프로시저는 SQL 문의 집합**
   - 재사용 가능, 성능 향상, 보안 강화
   - DELIMITER 변경 후 작성, 작성 후 복구

2. **매개변수 종류**
   - IN: 입력 (값 전달)
   - OUT: 출력 (값 반환)
   - INOUT: 입출력 (값 전달 및 반환)

3. **제어문 활용**
   - 조건: IF, CASE
   - 반복: LOOP, WHILE, REPEAT
   - 커서: 행 단위 처리 (가급적 회피)

4. **오류 처리**
   - DECLARE HANDLER로 예외 처리
   - 트랜잭션과 함께 사용하여 데이터 일관성 보장

5. **프로시저 관리**
   ```sql
   SHOW PROCEDURE STATUS;
   SHOW CREATE PROCEDURE 프로시저명;
   DROP PROCEDURE 프로시저명;
   ```

### 다음 단계

다음 시간에는 **4장 종합 실습 프로젝트**를 진행합니다:
- JOIN, 서브쿼리, 인덱스, 뷰, 프로시저를 종합적으로 활용
- 실무 시나리오 기반의 복합 문제 해결
- 성능 최적화를 고려한 쿼리 작성

---

**연습 권장사항:**
- sakila DB로 다양한 프로시저 작성해보기
- 기존 복잡한 쿼리를 프로시저로 리팩토링
- 트랜잭션과 오류 처리를 반드시 포함하여 작성
- 실무에서 자주 사용할 만한 유틸리티 프로시저 만들어보기
