# 4.5. 뷰 (View)

## 학습 목표
- 뷰(View)의 개념과 용도를 이해한다
- CREATE VIEW로 뷰를 생성하고 활용한다
- 복잡한 쿼리를 뷰로 단순화하는 방법을 학습한다
- 뷰를 활용한 보안 및 권한 관리 방법을 이해한다

---

## 1. 뷰란?

**뷰(View)**는 하나 이상의 테이블로부터 유도된 **가상 테이블(Virtual Table)**입니다. 실제 데이터를 저장하지 않고, SELECT 쿼리의 결과를 마치 테이블처럼 사용할 수 있게 해줍니다.

### 뷰의 특징

| 특징 | 설명 |
|-----|-----|
| **가상 테이블** | 실제 데이터를 저장하지 않음 (쿼리 정의만 저장) |
| **동적 결과** | 뷰를 조회할 때마다 기본 테이블에서 데이터를 가져옴 |
| **재사용성** | 복잡한 쿼리를 뷰로 만들어 반복 사용 |
| **보안** | 특정 컬럼/행만 노출하여 데이터 접근 제어 |
| **독립성** | 기본 테이블 구조 변경 시 뷰가 변경 영향 완화 |

### 뷰 vs 테이블

```sql
-- 일반 테이블: 실제 데이터 저장
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    salary INT,
    department VARCHAR(50)
);

-- 뷰: 쿼리 정의만 저장 (데이터는 users 테이블에서 가져옴)
CREATE VIEW public_users AS
SELECT id, name, department
FROM users;  -- salary는 제외 (보안)
```

---

## 2. 뷰의 장점

### 2.1. 복잡한 쿼리 단순화

```sql
-- 복잡한 JOIN 쿼리를 매번 작성하는 대신...
SELECT c.Name AS Country, ci.Name AS City, ci.Population
FROM country c
JOIN city ci ON c.Code = ci.CountryCode
WHERE c.Continent = 'Asia'
ORDER BY ci.Population DESC;

-- 뷰로 만들어 간단하게 사용
CREATE VIEW asian_cities AS
SELECT c.Name AS Country, ci.Name AS City, ci.Population
FROM country c
JOIN city ci ON c.Code = ci.CountryCode
WHERE c.Continent = 'Asia';

-- 사용
SELECT * FROM asian_cities ORDER BY Population DESC LIMIT 10;
```

### 2.2. 보안 및 권한 관리

```sql
-- 급여 정보를 제외한 뷰 생성
CREATE VIEW employee_public AS
SELECT employee_id, name, department, hire_date
FROM employees;
-- salary 컬럼은 제외

-- 일반 사용자에게는 뷰만 접근 권한 부여
GRANT SELECT ON employee_public TO general_user;
-- 실제 employees 테이블 접근은 제한
```

### 2.3. 데이터 독립성

```sql
-- 테이블 구조가 변경되어도 뷰를 통해 일관된 인터페이스 제공
CREATE VIEW customer_summary AS
SELECT
    customer_id,
    CONCAT(first_name, ' ', last_name) AS full_name,
    email
FROM customers;

-- 나중에 customers 테이블에 middle_name 추가되어도
-- 뷰는 그대로 사용 가능
```

---

## 3. 뷰 생성

### 3.1. 기본 구문

```sql
CREATE VIEW 뷰이름 AS
SELECT 쿼리;
```

### 3.2. world DB 예제

#### 예제 1: 인구 많은 국가 뷰

```sql
-- 인구 5000만 이상 국가만 보여주는 뷰
CREATE VIEW large_countries AS
SELECT Code, Name, Continent, Population, GNP
FROM country
WHERE Population >= 50000000
ORDER BY Population DESC;

-- 사용
SELECT * FROM large_countries;
```

**결과:**
```
+------+--------------------+-----------+------------+-----------+
| Code | Name               | Continent | Population | GNP       |
+------+--------------------+-----------+------------+-----------+
| CHN  | China              | Asia      | 1277558000 | 982268.00 |
| IND  | India              | Asia      | 1013662000 | 447114.00 |
| USA  | United States      | America   |  278357000 | 8510700.00|
+------+--------------------+-----------+------------+-----------+
```

#### 예제 2: JOIN을 포함한 뷰

```sql
-- 국가와 수도 정보를 함께 보여주는 뷰
CREATE VIEW country_with_capital AS
SELECT
    c.Code,
    c.Name AS CountryName,
    c.Continent,
    ci.Name AS Capital,
    ci.Population AS CapitalPopulation
FROM country c
LEFT JOIN city ci ON c.Capital = ci.ID;

-- 사용
SELECT * FROM country_with_capital WHERE Continent = 'Europe' LIMIT 5;
```

#### 예제 3: 집계 함수를 포함한 뷰

```sql
-- 대륙별 국가 통계 뷰
CREATE VIEW continent_stats AS
SELECT
    Continent,
    COUNT(*) AS CountryCount,
    SUM(Population) AS TotalPopulation,
    AVG(LifeExpectancy) AS AvgLifeExpectancy,
    SUM(GNP) AS TotalGNP
FROM country
GROUP BY Continent;

-- 사용
SELECT * FROM continent_stats ORDER BY TotalPopulation DESC;
```

**결과:**
```
+-----------+--------------+-----------------+--------------------+-------------+
| Continent | CountryCount | TotalPopulation | AvgLifeExpectancy  | TotalGNP    |
+-----------+--------------+-----------------+--------------------+-------------+
| Asia      |           51 |      3705025700 |              67.44 |  9722539.00 |
| Europe    |           46 |       730074600 |              75.14 | 10263472.00 |
+-----------+--------------+-----------------+--------------------+-------------+
```

---

## 4. 뷰 조회

뷰를 생성한 후에는 일반 테이블처럼 SELECT 문으로 조회할 수 있습니다.

```sql
-- 뷰 조회
SELECT * FROM large_countries;

-- WHERE 조건 추가
SELECT * FROM large_countries WHERE Continent = 'Asia';

-- JOIN도 가능
SELECT lc.Name, cl.Language
FROM large_countries lc
JOIN countrylanguage cl ON lc.Code = cl.CountryCode
WHERE cl.IsOfficial = 'T';
```

---

## 5. 뷰 목록 확인

```sql
-- 현재 데이터베이스의 모든 뷰 확인
SHOW FULL TABLES WHERE Table_type = 'VIEW';

-- 특정 뷰의 정의 확인
SHOW CREATE VIEW large_countries;

-- information_schema를 통한 확인
SELECT TABLE_NAME, VIEW_DEFINITION
FROM information_schema.VIEWS
WHERE TABLE_SCHEMA = 'world';
```

---

## 6. 뷰 수정

### 6.1. CREATE OR REPLACE VIEW

```sql
-- 기존 뷰를 수정 (없으면 생성, 있으면 교체)
CREATE OR REPLACE VIEW large_countries AS
SELECT Code, Name, Continent, Population, GNP, LifeExpectancy
FROM country
WHERE Population >= 50000000;  -- LifeExpectancy 컬럼 추가
```

### 6.2. ALTER VIEW

```sql
-- ALTER VIEW는 MySQL에서 제한적으로 지원
-- 대부분 CREATE OR REPLACE VIEW 사용 권장
```

---

## 7. 뷰 삭제

```sql
-- 뷰 삭제
DROP VIEW large_countries;

-- 존재할 경우에만 삭제 (에러 방지)
DROP VIEW IF EXISTS large_countries;

-- 여러 뷰 한 번에 삭제
DROP VIEW IF EXISTS large_countries, continent_stats, country_with_capital;
```

---

## 8. 뷰 활용 패턴

### 8.1. 복잡한 비즈니스 로직 캡슐화

```sql
-- 고객 등급 계산 로직을 뷰로 캡슐화
CREATE VIEW customer_tier AS
SELECT
    customer_id,
    total_spent,
    CASE
        WHEN total_spent >= 10000 THEN 'VIP'
        WHEN total_spent >= 5000 THEN 'Gold'
        WHEN total_spent >= 1000 THEN 'Silver'
        ELSE 'Bronze'
    END AS tier
FROM (
    SELECT customer_id, SUM(amount) AS total_spent
    FROM payments
    GROUP BY customer_id
) AS customer_totals;
```

### 8.2. 데이터 필터링

```sql
-- 현재 활성 사용자만 보여주는 뷰
CREATE VIEW active_users AS
SELECT user_id, username, email, created_at
FROM users
WHERE status = 'active' AND deleted_at IS NULL;
```

### 8.3. 컬럼 이름 변경 및 계산

```sql
-- 가독성 좋은 컬럼명으로 변경
CREATE VIEW country_info AS
SELECT
    Name AS '국가명',
    Continent AS '대륙',
    Population AS '인구',
    ROUND(SurfaceArea, 2) AS '면적(km²)',
    ROUND(Population / SurfaceArea, 2) AS '인구밀도'
FROM country;
```

---

## 9. 뷰 사용 시 주의사항

### 9.1. 성능 고려사항

```sql
-- ❌ 나쁜 예: 뷰 위에 뷰를 중첩하면 성능 저하
CREATE VIEW view1 AS SELECT * FROM large_table WHERE condition1;
CREATE VIEW view2 AS SELECT * FROM view1 WHERE condition2;
CREATE VIEW view3 AS SELECT * FROM view2 WHERE condition3;

-- ✅ 좋은 예: 직접 기본 테이블에서 조회
CREATE VIEW optimized_view AS
SELECT * FROM large_table
WHERE condition1 AND condition2 AND condition3;
```

### 9.2. 업데이트 가능한 뷰

단순한 뷰는 INSERT, UPDATE, DELETE가 가능하지만, 다음 경우는 불가능합니다:

```sql
-- ❌ 업데이트 불가능한 뷰 (집계 함수 사용)
CREATE VIEW continent_stats AS
SELECT Continent, COUNT(*) AS cnt, AVG(Population) AS avg_pop
FROM country
GROUP BY Continent;

-- UPDATE continent_stats SET cnt = 100;  -- 에러 발생

-- ✅ 업데이트 가능한 뷰 (단순 SELECT)
CREATE VIEW simple_country AS
SELECT Code, Name, Population FROM country;

-- 가능
UPDATE simple_country SET Population = 100000 WHERE Code = 'KOR';
```

**업데이트 불가능한 뷰의 조건:**
- 집계 함수 (COUNT, SUM, AVG 등) 사용
- DISTINCT, GROUP BY, HAVING 사용
- UNION 사용
- JOIN (일부 경우 가능)
- 서브쿼리 포함

---

## 10. 실습 문제

sakila 데이터베이스를 사용하여 다음 뷰를 생성하세요.

### 문제 1: 영화 정보 뷰 (난이도: ⭐)

film 테이블에서 다음 컬럼만 포함하는 `film_basic_info` 뷰를 생성하세요:
- film_id
- title (영화 제목)
- release_year (개봉년도)
- rating (등급)
- rental_rate (대여 가격)
- length (상영 시간, 분)

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
CREATE VIEW film_basic_info AS
SELECT
    film_id,
    title,
    release_year,
    rating,
    rental_rate,
    length
FROM film;

-- 확인
SELECT * FROM film_basic_info LIMIT 10;
```
</details>

---

### 문제 2: 배우별 영화 수 뷰 (난이도: ⭐⭐)

배우별로 출연한 영화 수를 집계하는 `actor_film_count` 뷰를 생성하세요.

**결과 컬럼:**
- actor_id
- actor_name (first_name과 last_name을 합쳐서)
- film_count (출연 영화 수)

**힌트:** actor, film_actor 테이블 JOIN 필요

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
CREATE VIEW actor_film_count AS
SELECT
    a.actor_id,
    CONCAT(a.first_name, ' ', a.last_name) AS actor_name,
    COUNT(fa.film_id) AS film_count
FROM actor a
LEFT JOIN film_actor fa ON a.actor_id = fa.actor_id
GROUP BY a.actor_id, a.first_name, a.last_name;

-- 확인: 출연 영화 많은 배우 Top 10
SELECT * FROM actor_film_count ORDER BY film_count DESC LIMIT 10;
```
</details>

---

### 문제 3: 카테고리별 영화 통계 뷰 (난이도: ⭐⭐⭐)

영화 카테고리별 통계를 보여주는 `category_film_stats` 뷰를 생성하세요.

**결과 컬럼:**
- category_name (카테고리 이름)
- film_count (영화 수)
- avg_rental_rate (평균 대여 가격)
- avg_length (평균 상영 시간)
- total_films (전체 영화 대비 비율 계산용)

**힌트:** category, film_category, film 테이블 JOIN 필요

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
CREATE VIEW category_film_stats AS
SELECT
    c.name AS category_name,
    COUNT(fc.film_id) AS film_count,
    ROUND(AVG(f.rental_rate), 2) AS avg_rental_rate,
    ROUND(AVG(f.length), 0) AS avg_length
FROM category c
LEFT JOIN film_category fc ON c.category_id = fc.category_id
LEFT JOIN film f ON fc.film_id = f.film_id
GROUP BY c.category_id, c.name;

-- 확인
SELECT * FROM category_film_stats ORDER BY film_count DESC;
```
</details>

---

### 문제 4: 고객 대여 요약 뷰 (난이도: ⭐⭐⭐)

각 고객의 대여 요약 정보를 보여주는 `customer_rental_summary` 뷰를 생성하세요.

**결과 컬럼:**
- customer_id
- customer_name (first_name + last_name)
- email
- total_rentals (총 대여 횟수)
- total_payments (총 결제 금액)
- avg_payment (평균 결제 금액)

**힌트:** customer, rental, payment 테이블 JOIN 필요

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
CREATE VIEW customer_rental_summary AS
SELECT
    c.customer_id,
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    c.email,
    COUNT(DISTINCT r.rental_id) AS total_rentals,
    COALESCE(SUM(p.amount), 0) AS total_payments,
    COALESCE(ROUND(AVG(p.amount), 2), 0) AS avg_payment
FROM customer c
LEFT JOIN rental r ON c.customer_id = r.customer_id
LEFT JOIN payment p ON r.rental_id = p.rental_id
GROUP BY c.customer_id, c.first_name, c.last_name, c.email;

-- 확인: 가장 많이 결제한 고객 Top 10
SELECT * FROM customer_rental_summary
ORDER BY total_payments DESC
LIMIT 10;
```
</details>

---

### 문제 5: 매장별 수익 뷰 (난이도: ⭐⭐⭐)

각 매장(store)의 수익 정보를 보여주는 `store_revenue` 뷰를 생성하세요.

**결과 컬럼:**
- store_id
- manager_name (매니저 이름)
- total_customers (고객 수)
- total_revenue (총 수익)
- avg_customer_value (고객당 평균 수익)

**힌트:** store, staff, customer, payment 테이블 JOIN 필요

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
CREATE VIEW store_revenue AS
SELECT
    s.store_id,
    CONCAT(st.first_name, ' ', st.last_name) AS manager_name,
    COUNT(DISTINCT c.customer_id) AS total_customers,
    COALESCE(SUM(p.amount), 0) AS total_revenue,
    COALESCE(ROUND(SUM(p.amount) / COUNT(DISTINCT c.customer_id), 2), 0) AS avg_customer_value
FROM store s
LEFT JOIN staff st ON s.manager_staff_id = st.staff_id
LEFT JOIN customer c ON s.store_id = c.store_id
LEFT JOIN payment p ON c.customer_id = p.customer_id
GROUP BY s.store_id, st.first_name, st.last_name;

-- 확인
SELECT * FROM store_revenue;
```
</details>

---

## 강사 가이드

### 수업 진행 팁

1. **뷰의 필요성 강조** (10분)
   - 실제 프로젝트에서 복잡한 쿼리를 반복 작성하는 불편함 설명
   - "이 쿼리를 100번 써야 한다면?" 질문으로 동기 부여
   - 보안 측면에서 뷰의 중요성 강조 (급여 정보 예시)

2. **간단한 예제부터 시작** (15분)
   - world DB의 large_countries 뷰부터 실습
   - CREATE VIEW → SELECT FROM view 순서로 진행
   - "뷰는 저장된 쿼리다" 개념 반복 강조

3. **점진적 복잡도 증가** (20분)
   - 단순 SELECT → JOIN 포함 → 집계 함수 포함 순서로 진행
   - 각 단계마다 실습 시간 충분히 제공
   - SHOW CREATE VIEW로 뷰 정의 확인하는 습관 들이기

4. **실무 활용 사례 소개** (10분)
   - 보안: 특정 컬럼 숨기기
   - 재사용: 대시보드용 통계 뷰
   - 추상화: 복잡한 비즈니스 로직 캡슐화

5. **주의사항 강조** (10분)
   - 뷰 중첩 시 성능 저하 설명
   - 업데이트 가능한 뷰 vs 불가능한 뷰 차이
   - EXPLAIN으로 뷰의 실행 계획 확인하는 방법

### 자주 하는 질문

**Q1: 뷰는 실제 데이터를 저장하나요?**
> A: 아니요. 뷰는 쿼리 정의만 저장합니다. 뷰를 조회할 때마다 기본 테이블에서 데이터를 가져옵니다. 따라서 기본 테이블이 변경되면 뷰의 결과도 자동으로 변경됩니다.

**Q2: 뷰와 Materialized View의 차이는?**
> A: 일반 뷰는 쿼리 정의만 저장하지만, Materialized View는 쿼리 결과를 실제로 저장합니다. MySQL은 기본적으로 Materialized View를 지원하지 않습니다 (PostgreSQL, Oracle은 지원).

**Q3: 뷰를 너무 많이 만들면 성능이 떨어지나요?**
> A: 뷰 자체는 쿼리 정의만 저장하므로 많이 만들어도 저장 공간 문제는 없습니다. 하지만 복잡한 뷰를 자주 조회하거나 뷰 위에 뷰를 중첩하면 성능이 저하될 수 있습니다.

**Q4: 뷰를 인덱싱할 수 있나요?**
> A: 일반 뷰는 인덱스를 만들 수 없습니다. 기본 테이블에 인덱스를 만들어야 합니다. (Materialized View는 인덱싱 가능)

**Q5: 뷰에서 INSERT/UPDATE/DELETE를 할 수 있나요?**
> A: 단순한 뷰는 가능하지만, 집계 함수, GROUP BY, JOIN 등이 포함된 복잡한 뷰는 대부분 불가능합니다. 일반적으로 뷰는 조회(SELECT) 용도로만 사용합니다.

### 실습 중 흔한 실수

1. **뷰 이름과 테이블 이름 충돌**
```sql
-- ❌ 이미 country 테이블이 있는데 같은 이름으로 뷰 생성
CREATE VIEW country AS SELECT * FROM country WHERE Population > 1000000;
-- 에러 발생

-- ✅ 명확한 뷰 이름 사용
CREATE VIEW large_population_countries AS ...
```

2. **뷰 정의에서 SELECT * 사용**
```sql
-- ❌ SELECT * 사용 (테이블 구조 변경 시 문제 발생 가능)
CREATE VIEW all_customers AS SELECT * FROM customers;

-- ✅ 명시적 컬럼 지정
CREATE VIEW all_customers AS
SELECT customer_id, name, email, created_at FROM customers;
```

3. **뷰 수정 시 DROP 후 CREATE**
```sql
-- ❌ 매번 DROP 후 CREATE (권한 설정이 사라질 수 있음)
DROP VIEW customer_summary;
CREATE VIEW customer_summary AS ...

-- ✅ CREATE OR REPLACE 사용
CREATE OR REPLACE VIEW customer_summary AS ...
```

### 추가 실습 아이디어

1. **보안 실습**: 급여 정보가 포함된 employee 테이블에서 급여를 제외한 뷰 만들기
2. **통계 대시보드**: sakila DB로 일별/월별 매출 통계 뷰 만들기
3. **뷰 중첩 성능 테스트**: 뷰 위에 뷰를 만들어 EXPLAIN으로 성능 비교
4. **업데이트 가능 뷰**: 단순 뷰에서 INSERT/UPDATE 실습

---

## 요약

### 핵심 개념

1. **뷰는 가상 테이블**
   - 실제 데이터를 저장하지 않고 쿼리 정의만 저장
   - 조회 시마다 기본 테이블에서 데이터를 가져옴

2. **뷰의 주요 용도**
   - 복잡한 쿼리 단순화 및 재사용
   - 보안 및 권한 관리 (특정 컬럼/행만 노출)
   - 데이터 독립성 제공

3. **뷰 생성 및 관리**
   ```sql
   CREATE VIEW 뷰이름 AS SELECT ...;
   CREATE OR REPLACE VIEW 뷰이름 AS SELECT ...;
   DROP VIEW 뷰이름;
   ```

4. **주의사항**
   - 뷰 중첩 시 성능 저하 주의
   - 복잡한 뷰는 업데이트 불가능
   - 기본 테이블의 인덱스가 뷰 성능에 영향

### 다음 단계

다음 시간에는 **저장 프로시저(Stored Procedure)**를 학습합니다:
- 저장 프로시저의 개념과 장점
- CREATE PROCEDURE로 프로시저 생성
- 매개변수와 변수 사용
- 제어문 (IF, LOOP, CURSOR)
- 실무 활용 사례

---

**연습 권장사항:**
- sakila 데이터베이스로 다양한 뷰 만들어보기
- 복잡한 쿼리를 뷰로 리팩토링하는 연습
- SHOW CREATE VIEW로 뷰 정의 확인하는 습관 들이기
- EXPLAIN으로 뷰의 실행 계획 확인해보기
