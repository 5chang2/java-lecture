# 4.2. 서브쿼리 (Subquery)

> 서브쿼리를 사용하여 복잡한 조건과 계산을 단계적으로 해결할 수 있다.

---

## 실습 준비

이 섹션에서는 **world 데이터베이스**를 사용합니다.

```sql
USE world;
```

---

## 1. 서브쿼리란?

**서브쿼리(Subquery)**는 **쿼리 안에 포함된 또 다른 쿼리**입니다.

### 왜 서브쿼리가 필요한가?

복잡한 문제를 단계적으로 해결하거나, 다른 쿼리의 결과를 조건으로 사용할 때 유용합니다.

**예시 상황:**
- "서울과 인구가 같은 다른 도시를 찾아라"
- "평균보다 인구가 많은 국가를 조회하라"
- "도시가 10개 이상인 국가만 보여라"

이런 문제는 **서브쿼리**로 해결할 수 있습니다!

### 서브쿼리의 구조

```sql
SELECT 컬럼
FROM 테이블
WHERE 조건 = (SELECT 컬럼 FROM 테이블 WHERE 조건);
              -- ↑ 안쪽 쿼리 (서브쿼리)
-- ↑ 바깥쪽 쿼리 (메인쿼리)
```

**실행 순서:**
1. 서브쿼리(안쪽) 먼저 실행
2. 그 결과를 메인쿼리(바깥쪽)에서 사용

---

## 2. WHERE 절의 서브쿼리

### 2.1. 단일 행 서브쿼리 (Single-Row)

서브쿼리가 **하나의 값만** 반환하는 경우입니다.

**비교 연산자 사용:** `=`, `>`, `<`, `>=`, `<=`, `!=`

#### 예제 1: 특정 도시와 같은 인구

```sql
-- Seoul과 인구가 같은 다른 도시 찾기
SELECT
    Name AS 도시명,
    CountryCode AS 국가코드,
    Population AS 인구
FROM
    city
WHERE
    Population = (
        -- 1단계: Seoul의 인구를 먼저 찾는다
        SELECT Population FROM city WHERE Name = 'Seoul'
    )
    AND Name != 'Seoul'  -- Seoul 자신은 제외
ORDER BY Name;
```

**설명:**
1. 서브쿼리: Seoul의 인구(9,981,619) 조회
2. 메인쿼리: 해당 인구와 같은 도시 조회

#### 예제 2: 평균보다 큰 값

```sql
-- 세계 평균보다 인구가 많은 국가
SELECT
    Name AS 국가명,
    Population AS 인구,
    ROUND(Population / 1000000, 1) AS '인구(백만)'
FROM
    country
WHERE
    Population > (
        SELECT AVG(Population) FROM country
    )
ORDER BY Population DESC
LIMIT 10;
```

### 2.2. 다중 행 서브쿼리 (Multi-Row)

서브쿼리가 **여러 개의 값**을 반환하는 경우입니다.

**연산자:** `IN`, `NOT IN`, `ANY`, `ALL`, `EXISTS`

#### 예제 1: IN 연산자

```sql
-- 아시아 국가의 모든 도시
SELECT
    Name AS 도시명,
    CountryCode AS 국가코드,
    Population AS 인구
FROM
    city
WHERE
    CountryCode IN (
        -- 아시아 국가들의 코드를 먼저 찾는다
        SELECT Code FROM country WHERE Continent = 'Asia'
    )
ORDER BY Population DESC
LIMIT 20;
```

#### 예제 2: NOT IN 연산자

```sql
-- 도시가 하나도 없는 국가
SELECT
    Name AS 국가명,
    Continent AS 대륙,
    Population AS 인구
FROM
    country
WHERE
    Code NOT IN (
        -- city 테이블에 등록된 국가 코드 목록
        SELECT DISTINCT CountryCode FROM city
    )
ORDER BY Population DESC
LIMIT 10;
```

#### 예제 3: ANY 연산자

```sql
-- 유럽의 어떤 국가보다 인구가 많은 아시아 국가
SELECT
    Name AS 국가명,
    Population AS 인구
FROM
    country
WHERE
    Continent = 'Asia'
    AND Population > ANY (
        -- 유럽 국가들의 인구 목록
        SELECT Population FROM country WHERE Continent = 'Europe'
    )
ORDER BY Population DESC
LIMIT 10;
```

**ANY 의미:** 서브쿼리 결과 중 **하나라도** 조건을 만족하면 TRUE

#### 예제 4: ALL 연산자

```sql
-- 유럽의 모든 국가보다 인구가 많은 아시아 국가
SELECT
    Name AS 국가명,
    Population AS 인구
FROM
    country
WHERE
    Continent = 'Asia'
    AND Population > ALL (
        -- 유럽 국가들의 인구 목록
        SELECT Population FROM country WHERE Continent = 'Europe'
    )
ORDER BY Population DESC;
```

**ALL 의미:** 서브쿼리 결과의 **모든 값**에 대해 조건을 만족하면 TRUE

#### 예제 5: EXISTS 연산자

```sql
-- 도시가 등록된 국가만 조회
SELECT
    Name AS 국가명,
    Continent AS 대륙,
    Population AS 인구
FROM
    country co
WHERE
    EXISTS (
        -- 해당 국가의 도시가 존재하는지 확인
        SELECT 1 FROM city ci WHERE ci.CountryCode = co.Code
    )
ORDER BY Population DESC
LIMIT 10;
```

**EXISTS 의미:** 서브쿼리 결과가 **존재하면** TRUE (행의 존재 여부만 확인)

**성능 팁:** `EXISTS`는 결과를 찾으면 즉시 중단하므로 `IN`보다 빠를 수 있습니다.

---

## 3. FROM 절의 서브쿼리 (인라인 뷰)

`FROM` 절의 서브쿼리는 **가상 테이블**처럼 동작합니다.

### 3.1. 기본 개념

```sql
SELECT 컬럼
FROM (
    SELECT ... FROM ... -- 서브쿼리
) AS 별칭;  -- 반드시 별칭 필요!
```

⚠️ **중요:** `FROM` 절의 서브쿼리는 **반드시 별칭(Alias)을 지정**해야 합니다.

### 3.2. 집계 결과 필터링

```sql
-- 국가 수가 20개 이상인 대륙만 조회
SELECT
    Continent AS 대륙,
    국가수,
    총인구
FROM (
    -- 1단계: 대륙별 집계 (가상 테이블 생성)
    SELECT
        Continent,
        COUNT(*) AS 국가수,
        SUM(Population) AS 총인구
    FROM
        country
    GROUP BY Continent
) AS continent_summary
WHERE
    국가수 >= 20
ORDER BY 국가수 DESC;
```

**활용:** `HAVING` 대신 더 직관적인 필터링 가능

### 3.3. 복잡한 계산

```sql
-- 각 대륙의 평균 국가 인구보다 많은 국가
SELECT
    co.Name AS 국가명,
    co.Continent AS 대륙,
    co.Population AS 인구,
    avg_pop.평균인구
FROM
    country co
INNER JOIN (
    -- 각 대륙의 평균 인구
    SELECT
        Continent,
        ROUND(AVG(Population), 0) AS 평균인구
    FROM
        country
    GROUP BY Continent
) AS avg_pop ON co.Continent = avg_pop.Continent
WHERE
    co.Population > avg_pop.평균인구
ORDER BY co.Continent, co.Population DESC
LIMIT 20;
```

---

## 4. SELECT 절의 서브쿼리 (스칼라 서브쿼리)

`SELECT` 절의 서브쿼리는 **하나의 값만** 반환해야 합니다.

### 4.1. 기본 사용

```sql
-- 각 국가와 도시 개수
SELECT
    Name AS 국가명,
    Continent AS 대륙,
    Population AS 인구,
    (
        -- 각 국가의 도시 개수
        SELECT COUNT(*)
        FROM city ci
        WHERE ci.CountryCode = co.Code
    ) AS 도시수
FROM
    country co
ORDER BY 도시수 DESC
LIMIT 20;
```

**설명:** 메인 쿼리의 각 행마다 서브쿼리가 실행됩니다.

### 4.2. 상관 서브쿼리 (Correlated Subquery)

위 예제처럼 서브쿼리가 **메인 쿼리의 컬럼(`co.Code`)을 참조**하는 경우를 **상관 서브쿼리**라고 합니다.

```sql
-- 각 대륙에서 가장 인구가 많은 국가 찾기
SELECT
    Name AS 국가명,
    Continent AS 대륙,
    Population AS 인구
FROM
    country co
WHERE
    Population = (
        -- 같은 대륙에서 최대 인구
        SELECT MAX(Population)
        FROM country
        WHERE Continent = co.Continent
    )
ORDER BY Continent;
```

⚠️ **성능 주의:** 상관 서브쿼리는 메인 쿼리의 각 행마다 실행되므로 데이터가 많으면 느릴 수 있습니다.

---

## 5. JOIN vs 서브쿼리

많은 경우 `JOIN`과 서브쿼리는 같은 결과를 낼 수 있습니다.

### 5.1. 같은 결과, 다른 방법

```sql
-- 서브쿼리 방식: 아시아 국가의 도시
SELECT Name
FROM city
WHERE CountryCode IN (
    SELECT Code FROM country WHERE Continent = 'Asia'
)
LIMIT 10;

-- JOIN 방식
SELECT ci.Name
FROM city ci
INNER JOIN country co ON ci.CountryCode = co.Code
WHERE co.Continent = 'Asia'
LIMIT 10;
```

### 5.2. 언제 무엇을 쓸까?

| 기준 | JOIN | 서브쿼리 |
|------|------|---------|
| **가독성** | 직관적, 명확함 | 논리적 단계 분리 |
| **성능** | 일반적으로 빠름 | 상관 서브쿼리는 느릴 수 있음 |
| **유연성** | 제한적 | GROUP BY 결과 필터링 등 |
| **추천 상황** | 테이블 연결 | 집계 후 조건, EXISTS 체크 |

**실무 팁:**
- **성능이 중요하다면:** JOIN 우선
- **복잡한 논리라면:** 서브쿼리로 단계 분리
- **EXISTS 체크라면:** 서브쿼리 (더 명확함)

---

## 실습 문제

이제 **sakila 데이터베이스**로 실습해봅시다.

```sql
USE sakila;
```

### 문제 1: 단일 행 서브쿼리

평균 대여료(`rental_rate`)보다 비싼 영화를 조회하세요.
- 영화 제목
- 대여료
- 대여료 내림차순 정렬
- 상위 10개

**힌트:** `SELECT AVG(rental_rate) FROM film`을 서브쿼리로 사용

**예상 답:**
```sql
SELECT
    title AS 영화제목,
    rental_rate AS 대여료
FROM
    film
WHERE
    rental_rate > (
        SELECT AVG(rental_rate) FROM film
    )
ORDER BY rental_rate DESC
LIMIT 10;
```

### 문제 2: IN 연산자

'Action' 카테고리에 속한 영화를 조회하세요.
- 영화 제목
- 상위 15개

**힌트:** `film` ← `film_category` ← `category`

**예상 답:**
```sql
SELECT
    title AS 영화제목
FROM
    film
WHERE
    film_id IN (
        SELECT film_id
        FROM film_category
        WHERE category_id = (
            SELECT category_id FROM category WHERE name = 'Action'
        )
    )
LIMIT 15;
```

### 문제 3: EXISTS 연산자

대여 기록이 있는 고객만 조회하세요.
- 고객 이름 (first_name, last_name)
- 이메일
- 상위 20개

**예상 답:**
```sql
SELECT
    first_name,
    last_name,
    email
FROM
    customer c
WHERE
    EXISTS (
        SELECT 1 FROM rental r WHERE r.customer_id = c.customer_id
    )
LIMIT 20;
```

### 문제 4: FROM 절 서브쿼리

고객별 대여 횟수를 구한 뒤, 대여 횟수가 30회 이상인 고객만 조회하세요.
- 고객 이름
- 대여 횟수
- 대여 횟수 내림차순

**예상 답:**
```sql
SELECT
    고객명,
    대여횟수
FROM (
    SELECT
        CONCAT(c.first_name, ' ', c.last_name) AS 고객명,
        COUNT(r.rental_id) AS 대여횟수
    FROM
        customer c
    LEFT JOIN
        rental r ON c.customer_id = r.customer_id
    GROUP BY c.customer_id, c.first_name, c.last_name
) AS customer_rentals
WHERE
    대여횟수 >= 30
ORDER BY 대여횟수 DESC;
```

### 문제 5: SELECT 절 서브쿼리 (스칼라)

각 영화와 해당 영화의 재고 개수를 조회하세요.
- 영화 제목
- 재고 개수
- 상위 15개

**힌트:** `inventory` 테이블에서 `COUNT(*)`

**예상 답:**
```sql
SELECT
    title AS 영화제목,
    (
        SELECT COUNT(*)
        FROM inventory i
        WHERE i.film_id = f.film_id
    ) AS 재고수
FROM
    film f
ORDER BY 재고수 DESC
LIMIT 15;
```

---

## 강사 가이드

### 데이터베이스 활용 전략

1. **world DB (강의 설명 및 예제)**
   - 서브쿼리 개념 설명에 직관적
   - city ↔ country 관계로 단계적 사고 연습
   - "서울과 같은 인구", "평균보다 많은" 등 실생활 질문
   - ANY, ALL, EXISTS 개념 명확히 전달

2. **sakila DB (실습 문제)**
   - film, rental, customer 관계로 실무 패턴
   - "평균보다 비싼 영화", "대여 이력 있는 고객" 등
   - 상관 서브쿼리 연습 (inventory 개수 등)

3. **수업 진행 흐름**
   ```
   1. 서브쿼리 개념 (러시아 인형 비유)
   2. WHERE 절 서브쿼리 (단일/다중 행)
   3. FROM 절 서브쿼리 (인라인 뷰)
   4. SELECT 절 서브쿼리 (스칼라, 상관)
   5. JOIN vs 서브쿼리 비교
   6. sakila 실습 (실무 패턴)
   ```

### 핵심 포인트

1. **실행 순서**: 안쪽(서브쿼리) → 바깥쪽(메인쿼리)
2. **단일 vs 다중**: 단일 행은 `=`, 다중 행은 `IN`
3. **FROM 절 별칭 필수**: 가상 테이블에는 항상 별칭
4. **상관 서브쿼리 주의**: 성능 문제 가능성
5. **EXISTS vs IN**: EXISTS가 성능상 유리한 경우 많음
6. **JOIN vs 서브쿼리**: 상황에 따라 선택

### 자주 하는 질문

**Q: 서브쿼리와 JOIN 중 어느 것이 더 좋나요?**
A: 일반적으로 JOIN이 성능상 유리하지만, 서브쿼리가 더 직관적인 경우도 많습니다. 상황에 따라 선택하세요.

**Q: 서브쿼리가 여러 행을 반환하는데 `=`를 쓰면 에러가 나는 이유는?**
A: `=`는 단일 값 비교 연산자입니다. 다중 행에는 `IN`, `ANY`, `ALL`을 사용해야 합니다.

**Q: FROM 절의 서브쿼리에 왜 별칭이 필수인가요?**
A: MySQL은 FROM 절의 모든 테이블(가상 테이블 포함)에 참조 가능한 이름이 필요하기 때문입니다.

**Q: EXISTS와 IN의 차이는?**
A: EXISTS는 존재 여부만 확인(TRUE/FALSE), IN은 값 목록과 일치 여부를 확인합니다. EXISTS가 대량 데이터에서 더 빠른 경우가 많습니다.

**Q: 서브쿼리를 여러 번 중첩할 수 있나요?**
A: 가능하지만 가독성과 성능이 크게 저하됩니다. 2-3단계 이상은 피하는 것이 좋습니다.

### 실습 진행 팁

1. **단계별 실행**: 서브쿼리를 먼저 따로 실행해서 결과 확인
2. **성능 비교**: 같은 결과를 JOIN과 서브쿼리로 작성 후 속도 비교
3. **에러 체험**: 다중 행 서브쿼리에 `=` 사용해서 에러 경험
4. **EXPLAIN 활용**: 쿼리 실행 계획 확인 (`EXPLAIN SELECT ...`)
5. **실무 시나리오**: "평균보다 높은", "이력이 있는" 등 실생활 질문

---

## 요약

- **서브쿼리**: 쿼리 안에 포함된 또 다른 쿼리
- **실행 순서**: 안쪽(서브쿼리) 먼저 → 바깥쪽(메인쿼리)
- **WHERE 절 서브쿼리**:
  - 단일 행: `=`, `>`, `<` 등
  - 다중 행: `IN`, `NOT IN`, `ANY`, `ALL`, `EXISTS`
- **FROM 절 서브쿼리**: 가상 테이블(인라인 뷰), 별칭 필수
- **SELECT 절 서브쿼리**: 스칼라 서브쿼리, 하나의 값만 반환
- **상관 서브쿼리**: 메인 쿼리 컬럼 참조, 성능 주의
- **JOIN vs 서브쿼리**:
  - JOIN: 성능 우수, 직관적
  - 서브쿼리: 복잡한 논리, 단계적 분리
- **활용 패턴**:
  - 집계 후 조건 필터링 (FROM 절)
  - 존재 여부 확인 (EXISTS)
  - 평균, 최대값과 비교 (WHERE 절)

**다음 단계**: 실습 프로젝트로 JOIN과 서브쿼리를 종합적으로 활용합니다!
