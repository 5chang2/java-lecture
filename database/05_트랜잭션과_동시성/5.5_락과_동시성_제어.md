# 5.5. 락(Lock)과 동시성 제어

## 학습 목표
- 락(Lock)의 개념과 필요성을 이해한다
- 공유 락과 배타적 락의 차이를 학습한다
- 행 수준 락과 테이블 수준 락을 이해한다
- 락 대기와 타임아웃을 처리하는 방법을 익힌다
- 락 모니터링 방법을 학습한다

---

## 1. 락(Lock)이란?

**락(Lock)**은 여러 트랜잭션이 동시에 같은 데이터에 접근할 때 **데이터 일관성을 보장**하기 위한 메커니즘입니다.

```
락 = 데이터를 보호하는 "자물쇠"

목적:
- 동시에 같은 데이터를 수정하는 것을 방지
- 읽는 중에 수정되는 것을 방지
- 수정하는 중에 읽히는 것을 방지 (경우에 따라)
```

### 1.1. 왜 락이 필요한가?

```
시나리오: 좌석 예매 시스템

사용자 A: 좌석 1번 조회 → "예약 가능" 확인 → 예약 버튼 클릭
사용자 B: 좌석 1번 조회 → "예약 가능" 확인 → 예약 버튼 클릭 (동시에!)

락이 없으면:
- A와 B 모두 "예약 가능"으로 확인
- 두 사람 모두 예약 성공
- 같은 좌석을 두 사람이 예약! ❌

락이 있으면:
- A가 좌석 1번에 락 획득
- B는 A의 락이 해제될 때까지 대기
- A 예약 완료 후 B는 "이미 예약됨" 확인 ✅
```

---

## 2. 락의 종류

### 2.1. 공유 락 (Shared Lock, S Lock)

**읽기 락**이라고도 하며, **여러 트랜잭션이 동시에 읽을 수 있지만 쓸 수는 없음**을 의미합니다.

```sql
-- 공유 락 획득
SELECT * FROM accounts WHERE account_id = 'A001' LOCK IN SHARE MODE;
-- 또는 (MySQL 8.0+)
SELECT * FROM accounts WHERE account_id = 'A001' FOR SHARE;
```

**특징:**
- 여러 트랜잭션이 동시에 공유 락 획득 가능
- 공유 락이 있으면 배타적 락 획득 불가
- 읽기는 허용, 쓰기는 차단

```
트랜잭션 A: SELECT ... FOR SHARE  (공유 락 획득)
트랜잭션 B: SELECT ... FOR SHARE  (공유 락 획득 가능 ✅)
트랜잭션 C: UPDATE ...             (배타적 락 필요 → 대기 ⏳)
```

### 2.2. 배타적 락 (Exclusive Lock, X Lock)

**쓰기 락**이라고도 하며, **하나의 트랜잭션만 데이터에 접근 가능**함을 의미합니다.

```sql
-- 배타적 락 획득
SELECT * FROM accounts WHERE account_id = 'A001' FOR UPDATE;
```

**특징:**
- 하나의 트랜잭션만 배타적 락 획득 가능
- 배타적 락이 있으면 다른 모든 락 획득 불가
- 읽기와 쓰기 모두 차단

```
트랜잭션 A: SELECT ... FOR UPDATE  (배타적 락 획득)
트랜잭션 B: SELECT ... FOR SHARE   (대기 ⏳)
트랜잭션 C: SELECT ... FOR UPDATE  (대기 ⏳)
트랜잭션 D: UPDATE ...             (대기 ⏳)
```

### 2.3. 락 호환성 매트릭스

|  | 공유 락 (S) | 배타적 락 (X) |
|--|------------|--------------|
| **공유 락 (S)** | ✅ 호환 | ❌ 비호환 |
| **배타적 락 (X)** | ❌ 비호환 | ❌ 비호환 |

---

## 3. 락의 범위 (Granularity)

### 3.1. 행 수준 락 (Row-Level Lock)

**특정 행(row)에만 락**을 걸어 동시성을 최대화합니다.

```sql
-- 세션 1
START TRANSACTION;
SELECT * FROM accounts WHERE account_id = 'A001' FOR UPDATE;
-- A001 행에만 락

-- 세션 2
START TRANSACTION;
SELECT * FROM accounts WHERE account_id = 'B001' FOR UPDATE;
-- B001 행에 락 (A001과 다른 행이므로 가능 ✅)
```

**장점:**
- 높은 동시성 (다른 행은 자유롭게 접근)
- 성능 향상

**단점:**
- 많은 행을 잠글 때 오버헤드
- 복잡한 관리

### 3.2. 테이블 수준 락 (Table-Level Lock)

**전체 테이블에 락**을 걸어 단순하지만 동시성이 낮습니다.

```sql
-- 테이블 전체에 읽기 락
LOCK TABLES accounts READ;

-- 다른 세션에서 읽기 가능, 쓰기 불가

UNLOCK TABLES;

-- 테이블 전체에 쓰기 락
LOCK TABLES accounts WRITE;

-- 다른 세션에서 읽기/쓰기 모두 불가

UNLOCK TABLES;
```

**장점:**
- 단순한 관리
- 오버헤드 적음

**단점:**
- 낮은 동시성
- 전체 테이블을 막아버림

### 3.3. MySQL InnoDB의 락

**InnoDB는 기본적으로 행 수준 락을 사용**합니다.

```sql
-- InnoDB는 자동으로 행 수준 락 사용
UPDATE accounts SET balance = balance + 100 WHERE account_id = 'A001';
-- A001 행에만 배타적 락
```

---

## 4. 명시적 락 사용

### 4.1. SELECT ... FOR UPDATE

**읽으면서 배타적 락**을 획득합니다.

```sql
-- 좌석 예매 시나리오
START TRANSACTION;

-- 좌석 상태 확인 및 락 획득
SELECT status FROM seats WHERE seat_id = 101 FOR UPDATE;

-- 예약 가능 확인
IF status = 'available' THEN
    -- 예약 처리
    UPDATE seats SET status = 'reserved', customer_id = 1001 WHERE seat_id = 101;
    COMMIT;
ELSE
    ROLLBACK;
END IF;
```

**사용 사례:**
- 재고 확인 후 주문 처리
- 좌석/티켓 예매
- 계좌 잔액 확인 후 이체

### 4.2. SELECT ... FOR SHARE (LOCK IN SHARE MODE)

**읽으면서 공유 락**을 획득합니다.

```sql
-- 주문 조회 시나리오
START TRANSACTION;

-- 주문 정보 읽기 (다른 트랜잭션의 읽기는 허용, 수정은 차단)
SELECT * FROM orders WHERE order_id = 12345 FOR SHARE;

-- 관련 데이터 조회
SELECT * FROM order_items WHERE order_id = 12345;

COMMIT;
```

**사용 사례:**
- 일관된 읽기가 필요한 경우
- 읽는 동안 데이터가 변경되면 안 되는 경우
- 여러 테이블을 참조하는 복잡한 쿼리

### 4.3. 락 대기 시간 설정

```sql
-- 락 대기 시간 설정 (초 단위)
SET innodb_lock_wait_timeout = 10;  -- 10초

-- 이제 락 대기 시 10초 후 타임아웃
START TRANSACTION;
SELECT * FROM accounts WHERE account_id = 'A001' FOR UPDATE;
-- 다른 세션이 락을 보유 중이면 10초 대기 후 에러
```

**기본값:** 50초

---

## 5. 암묵적 락 (Implicit Locking)

MySQL InnoDB는 많은 경우 **자동으로 락을 획득**합니다.

### 5.1. INSERT 시 락

```sql
INSERT INTO accounts VALUES ('C001', 'Charlie', 1000000);
-- 새 행에 배타적 락 자동 획득
```

### 5.2. UPDATE/DELETE 시 락

```sql
UPDATE accounts SET balance = balance + 100 WHERE account_id = 'A001';
-- A001 행에 배타적 락 자동 획득

DELETE FROM accounts WHERE account_id = 'B001';
-- B001 행에 배타적 락 자동 획득
```

### 5.3. 범위 검색 시 락

```sql
-- 범위에 해당하는 모든 행에 락
UPDATE accounts SET balance = balance * 1.1 WHERE balance > 1000000;
-- balance > 1000000인 모든 행에 배타적 락
```

---

## 6. Next-Key Lock (MySQL InnoDB)

MySQL InnoDB는 **Next-Key Lock**을 사용하여 **Phantom Read를 방지**합니다.

### 6.1. 개념

```
Next-Key Lock = Record Lock + Gap Lock

Record Lock: 실제 행에 대한 락
Gap Lock: 행과 행 사이의 "간격"에 대한 락
```

### 6.2. 동작 방식

```sql
-- 세션 1
START TRANSACTION;
SELECT * FROM accounts WHERE balance BETWEEN 1000000 AND 2000000 FOR UPDATE;

-- 잠기는 것:
-- 1. balance가 1000000~2000000인 모든 행 (Record Lock)
-- 2. 그 범위의 "간격" (Gap Lock)

-- 세션 2에서 범위 내에 새 행 INSERT 시도
INSERT INTO accounts VALUES ('D001', 'David', 1500000);
-- 대기... (Gap Lock 때문에)

-- 세션 1
COMMIT;  -- 이제 세션 2가 실행됨
```

**목적:** Phantom Read 방지

---

## 7. 락 대기와 타임아웃

### 7.1. 락 대기 상황

```sql
-- 세션 1
START TRANSACTION;
UPDATE accounts SET balance = 2000000 WHERE account_id = 'A001';
-- A001에 배타적 락

-- 세션 2
START TRANSACTION;
UPDATE accounts SET balance = 3000000 WHERE account_id = 'A001';
-- 대기... ⏳
-- ERROR 1205: Lock wait timeout exceeded
```

### 7.2. 타임아웃 설정

```sql
-- 현재 설정 확인
SHOW VARIABLES LIKE 'innodb_lock_wait_timeout';  -- 기본 50초

-- 세션별 설정
SET innodb_lock_wait_timeout = 10;  -- 10초로 변경

-- 글로벌 설정 (my.cnf)
[mysqld]
innodb_lock_wait_timeout = 30
```

### 7.3. NOWAIT와 SKIP LOCKED (MySQL 8.0+)

```sql
-- NOWAIT: 락을 즉시 획득하지 못하면 에러
SELECT * FROM accounts WHERE account_id = 'A001' FOR UPDATE NOWAIT;
-- 대기 없이 즉시 에러 반환

-- SKIP LOCKED: 락이 걸린 행은 건너뛰기
SELECT * FROM accounts FOR UPDATE SKIP LOCKED;
-- 락이 없는 행만 반환 (큐 시스템에 유용)
```

---

## 8. 락 모니터링

### 8.1. 현재 락 상태 확인

```sql
-- InnoDB 락 정보 조회
SELECT * FROM performance_schema.data_locks;

-- 락 대기 정보 조회
SELECT * FROM performance_schema.data_lock_waits;

-- 실행 중인 트랜잭션 확인
SELECT * FROM information_schema.INNODB_TRX;
```

### 8.2. 락 충돌 확인

```sql
-- 어떤 트랜잭션이 어떤 트랜잭션을 막고 있는지 확인
SELECT
    r.trx_id AS waiting_trx_id,
    r.trx_mysql_thread_id AS waiting_thread,
    r.trx_query AS waiting_query,
    b.trx_id AS blocking_trx_id,
    b.trx_mysql_thread_id AS blocking_thread,
    b.trx_query AS blocking_query
FROM information_schema.INNODB_LOCK_WAITS w
JOIN information_schema.INNODB_TRX b ON b.trx_id = w.blocking_trx_id
JOIN information_schema.INNODB_TRX r ON r.trx_id = w.requesting_trx_id;
```

### 8.3. 프로세스 강제 종료

```sql
-- 프로세스 ID 확인
SHOW PROCESSLIST;

-- 특정 프로세스 강제 종료 (주의!)
KILL 123;  -- 프로세스 ID
```

---

## 9. 실습 문제

### 문제 1: 공유 락 vs 배타적 락 (난이도: ⭐⭐)

두 세션을 열어 공유 락과 배타적 락의 동작을 확인하세요.

```sql
-- 세션 1
-- 여기에 SQL 작성

-- 세션 2
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
-- 세션 1: 공유 락 획득
START TRANSACTION;
SELECT * FROM accounts WHERE account_id = 'A001' FOR SHARE;

-- 세션 2: 공유 락 획득 시도 (성공)
START TRANSACTION;
SELECT * FROM accounts WHERE account_id = 'A001' FOR SHARE;
-- 성공! 공유 락끼리는 호환 ✅

-- 세션 2: 배타적 락 획득 시도 (대기)
UPDATE accounts SET balance = 5000000 WHERE account_id = 'A001';
-- 대기... ⏳

-- 세션 1: COMMIT
COMMIT;

-- 세션 2: 이제 UPDATE 실행됨
COMMIT;
```
</details>

---

### 문제 2: 좌석 예매 시스템 (난이도: ⭐⭐⭐)

FOR UPDATE를 사용하여 안전한 좌석 예매 로직을 구현하세요.

**요구사항:**
- 좌석 상태 확인 후 예매
- 동시 예매 방지

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
-- 테이블 생성
CREATE TABLE seats (
    seat_id INT PRIMARY KEY,
    status ENUM('available', 'reserved') DEFAULT 'available',
    customer_id INT NULL,
    reserved_at TIMESTAMP NULL
);

INSERT INTO seats (seat_id) VALUES (1), (2), (3), (4), (5);

-- 예매 프로시저
DELIMITER $$

CREATE PROCEDURE reserve_seat(
    IN p_seat_id INT,
    IN p_customer_id INT,
    OUT p_result VARCHAR(50)
)
BEGIN
    DECLARE seat_status VARCHAR(20);

    START TRANSACTION;

    -- 좌석 상태 확인 및 락 획득
    SELECT status INTO seat_status
    FROM seats
    WHERE seat_id = p_seat_id
    FOR UPDATE;

    -- 예약 가능 여부 확인
    IF seat_status = 'available' THEN
        -- 예약 처리
        UPDATE seats
        SET status = 'reserved',
            customer_id = p_customer_id,
            reserved_at = NOW()
        WHERE seat_id = p_seat_id;

        SET p_result = 'Reservation successful';
        COMMIT;
    ELSE
        SET p_result = 'Seat already reserved';
        ROLLBACK;
    END IF;
END$$

DELIMITER ;

-- 사용
CALL reserve_seat(1, 1001, @result);
SELECT @result;

-- 동시 예매 테스트 (두 세션에서 동시 실행)
-- 한 세션만 성공, 다른 세션은 대기 후 실패

-- 정리
DROP PROCEDURE reserve_seat;
DROP TABLE seats;
```
</details>

---

### 문제 3: 락 타임아웃 처리 (난이도: ⭐⭐⭐)

락 타임아웃 시 재시도 로직을 구현하세요.

<details>
<summary>정답 보기</summary>

```sql
DELIMITER $$

CREATE PROCEDURE transfer_with_retry(
    IN from_account VARCHAR(10),
    IN to_account VARCHAR(10),
    IN amount DECIMAL(15,2),
    IN max_retries INT,
    OUT result VARCHAR(100)
)
BEGIN
    DECLARE retry_count INT DEFAULT 0;
    DECLARE success BOOLEAN DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR 1205  -- Lock wait timeout
    BEGIN
        ROLLBACK;
        SET retry_count = retry_count + 1;
    END;

    retry_loop: WHILE retry_count < max_retries AND NOT success DO
        START TRANSACTION;

        -- 계좌 잔액 확인 및 락 획득
        SELECT balance FROM accounts WHERE account_id = from_account FOR UPDATE;

        -- 이체 실행
        UPDATE accounts SET balance = balance - amount WHERE account_id = from_account;
        UPDATE accounts SET balance = balance + amount WHERE account_id = to_account;

        COMMIT;
        SET success = TRUE;
        SET result = CONCAT('Transfer successful after ', retry_count, ' retries');
    END WHILE retry_loop;

    IF NOT success THEN
        SET result = CONCAT('Transfer failed after ', max_retries, ' retries');
    END IF;
END$$

DELIMITER ;

-- 사용
CALL transfer_with_retry('A001', 'B001', 100000, 3, @result);
SELECT @result;
```
</details>

---

## 강사 가이드

### 수업 진행 팁

1. **실생활 비유로 시작** (10분)
   - 화장실 자물쇠 비유
   - 도서관 열람실 예약 비유
   - 학생들이 경험한 "대기" 상황 공유

2. **공유 락 vs 배타적 락 시연** (20분)
   - 두 세션으로 실습
   - 호환성 매트릭스 강조
   - "읽기는 같이, 쓰기는 혼자"

3. **FOR UPDATE 실습** (20분)
   - 좌석 예매 시나리오
   - 재고 관리 시나리오
   - 실수로 락을 안 걸었을 때의 문제 시연

4. **락 대기와 타임아웃** (15분)
   - 의도적으로 락 대기 상황 만들기
   - 타임아웃 에러 경험
   - SHOW PROCESSLIST로 대기 중인 쿼리 확인

5. **실무 팁 공유** (10분)
   - 트랜잭션은 짧게 유지
   - 락 획득 순서 일관성 유지 (데드락 방지)
   - 모니터링의 중요성

### 자주 하는 질문

**Q1: SELECT 문도 락을 걸 수 있나요?**
> A: 기본 SELECT는 락을 걸지 않습니다(MVCC 사용). 명시적으로 FOR UPDATE 또는 FOR SHARE를 사용해야 락이 걸립니다.

**Q2: FOR UPDATE를 사용하면 항상 대기하나요?**
> A: 다른 트랜잭션이 같은 행에 락을 보유 중일 때만 대기합니다. 락이 없으면 즉시 획득합니다.

**Q3: 행 수준 락이 테이블 수준 락으로 에스컬레이션되나요?**
> A: InnoDB는 락 에스컬레이션이 없습니다. 항상 행 수준 락을 유지합니다.

**Q4: 인덱스가 없으면 어떻게 되나요?**
> A: WHERE 조건에 인덱스가 없으면 풀 테이블 스캔을 하면서 모든 행에 락을 걸 수 있습니다. 성능 저하와 과도한 락 발생 가능.

**Q5: 락을 수동으로 해제할 수 있나요?**
> A: COMMIT 또는 ROLLBACK으로 트랜잭션을 종료하면 자동으로 모든 락이 해제됩니다. 수동 해제는 불가능합니다.

### 실습 중 흔한 실수

1. **FOR UPDATE 없이 예매 로직 구현**
```sql
-- ❌ 잘못된 예
SELECT status FROM seats WHERE seat_id = 1;  -- 락 없음
-- 동시 접근 가능!
UPDATE seats SET status = 'reserved' WHERE seat_id = 1;

-- ✅ 올바른 예
SELECT status FROM seats WHERE seat_id = 1 FOR UPDATE;  -- 락 획득
UPDATE seats SET status = 'reserved' WHERE seat_id = 1;
```

2. **긴 트랜잭션**
```sql
-- ❌ 나쁜 예
START TRANSACTION;
SELECT * FROM large_table FOR UPDATE;  -- 많은 행에 락
-- 복잡한 계산... (오래 걸림)
UPDATE ...;
COMMIT;

-- ✅ 좋은 예
-- 복잡한 계산 먼저 (트랜잭션 밖에서)
START TRANSACTION;
SELECT * FROM specific_rows FOR UPDATE;  -- 최소한의 락
UPDATE ...;
COMMIT;  -- 빠르게 종료
```

---

## 요약

### 핵심 개념

1. **락의 종류**
   - **공유 락 (S Lock)**: 읽기만 허용, 여러 트랜잭션 동시 획득 가능
   - **배타적 락 (X Lock)**: 읽기/쓰기 모두 차단, 하나만 획득 가능

2. **명시적 락**
   ```sql
   SELECT ... FOR UPDATE;       -- 배타적 락
   SELECT ... FOR SHARE;        -- 공유 락 (LOCK IN SHARE MODE)
   SELECT ... FOR UPDATE NOWAIT;  -- 즉시 에러
   SELECT ... FOR UPDATE SKIP LOCKED;  -- 락 건너뛰기
   ```

3. **락의 범위**
   - 행 수준 락 (Row-Level): InnoDB 기본, 높은 동시성
   - 테이블 수준 락 (Table-Level): 낮은 동시성

4. **Next-Key Lock**
   - Record Lock + Gap Lock
   - Phantom Read 방지

### 명령어

```sql
-- 락 타임아웃 설정
SET innodb_lock_wait_timeout = 10;

-- 락 정보 조회
SELECT * FROM performance_schema.data_locks;
SELECT * FROM performance_schema.data_lock_waits;

-- 트랜잭션 정보
SELECT * FROM information_schema.INNODB_TRX;

-- 프로세스 확인 및 종료
SHOW PROCESSLIST;
KILL {process_id};
```

### 다음 단계

다음 시간에는 **데드락(Deadlock)**을 학습합니다:
- 데드락의 원인과 발생 조건
- 데드락 탐지 및 해결
- 데드락 예방 전략
- 실무에서의 데드락 처리 방법

---

**연습 권장사항:**
- 두 세션으로 락 대기 상황 만들어보기
- FOR UPDATE를 사용한 안전한 로직 구현
- 락 모니터링 쿼리 실행해보기
- 의도적으로 타임아웃 발생시켜보기
