# 5.4. 트랜잭션 격리 수준 (Isolation Level)

## 학습 목표
- 트랜잭션 격리 수준의 개념을 이해한다
- 4가지 격리 수준(READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE)을 학습한다
- 각 격리 수준에서 발생하는 문제(Dirty Read, Non-Repeatable Read, Phantom Read)를 이해한다
- 격리 수준을 설정하고 테스트하는 방법을 익힌다

---

## 1. 트랜잭션 격리 수준이란?

**격리 수준(Isolation Level)**은 **동시에 실행되는 여러 트랜잭션이 서로 얼마나 격리되어 있는지**를 정의합니다.

```
격리 수준 = 동시성 vs 일관성의 균형

높은 격리 수준:
- 일관성 ↑ (데이터 정확도 높음)
- 동시성 ↓ (성능 낮음, 대기 시간 증가)

낮은 격리 수준:
- 동시성 ↑ (성능 높음, 여러 트랜잭션 동시 처리)
- 일관성 ↓ (데이터 부정확 가능성)
```

### 1.1. 왜 격리 수준이 필요한가?

```
시나리오: 은행 계좌 조회

트랜잭션 A: 계좌 잔액을 100만원에서 150만원으로 변경 중
트랜잭션 B: 같은 계좌의 잔액을 조회

격리가 없다면:
- B가 A의 변경 중인(커밋 안 된) 150만원을 봄
- A가 ROLLBACK하면 B는 잘못된 데이터를 읽은 것!

격리가 있다면:
- B는 A의 COMMIT 전까지 원래 값(100만원)을 봄
- A가 COMMIT하면 그때부터 150만원을 봄
```

---

## 2. 4가지 격리 수준

SQL 표준은 4가지 격리 수준을 정의합니다:

| 격리 수준 | Dirty Read | Non-Repeatable Read | Phantom Read | 성능 |
|----------|------------|---------------------|--------------|------|
| **READ UNCOMMITTED** | ⭕ 발생 | ⭕ 발생 | ⭕ 발생 | 최고 |
| **READ COMMITTED** | ❌ 방지 | ⭕ 발생 | ⭕ 발생 | 높음 |
| **REPEATABLE READ** | ❌ 방지 | ❌ 방지 | ⭕ 발생* | 중간 |
| **SERIALIZABLE** | ❌ 방지 | ❌ 방지 | ❌ 방지 | 낮음 |

\* MySQL InnoDB는 REPEATABLE READ에서 Phantom Read도 방지합니다.

### 2.1. MySQL 기본 격리 수준

```sql
-- 현재 격리 수준 확인
SELECT @@transaction_isolation;  -- REPEATABLE-READ (MySQL 기본값)

-- 또는
SHOW VARIABLES LIKE 'transaction_isolation';
```

---

## 3. READ UNCOMMITTED (레벨 0)

### 3.1. 특징

- **가장 낮은 격리 수준**
- 커밋되지 않은 데이터도 읽을 수 있음 (**Dirty Read**)
- 성능은 가장 좋지만 데이터 정확도가 낮음

### 3.2. Dirty Read 시연

**세션 1 (사용자 A):**
```sql
-- 격리 수준 설정
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

-- 트랜잭션 시작
START TRANSACTION;

-- 잔액 조회
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 1,000,000
```

**세션 2 (사용자 B):**
```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

START TRANSACTION;

-- 잔액 변경 (아직 COMMIT 안 함!)
UPDATE accounts SET balance = 999999 WHERE account_id = 'A001';

-- COMMIT하지 않은 상태
```

**세션 1 (다시):**
```sql
-- 같은 트랜잭션 내에서 다시 조회
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 999999 (Dirty Read!)

-- 세션 2가 COMMIT하지 않은 데이터를 읽음!
```

**세션 2 (계속):**
```sql
ROLLBACK;  -- 변경사항 취소
```

**세션 1 (다시):**
```sql
-- 세션 2가 ROLLBACK했으므로 존재하지 않는 데이터를 읽은 것!
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 1,000,000 (원래 값)

COMMIT;
```

### 3.3. 사용 사례

거의 사용하지 않지만, 다음 경우에만 고려:
- 대략적인 통계 (정확도가 중요하지 않음)
- 실시간 모니터링 대시보드
- 읽기만 하고 데이터 정확도가 중요하지 않은 경우

---

## 4. READ COMMITTED (레벨 1)

### 4.1. 특징

- **커밋된 데이터만 읽을 수 있음**
- Dirty Read 방지
- Oracle, PostgreSQL의 기본 격리 수준
- Non-Repeatable Read 발생 가능

### 4.2. Non-Repeatable Read 시연

**세션 1 (사용자 A):**
```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

START TRANSACTION;

-- 첫 번째 조회
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 1,000,000
```

**세션 2 (사용자 B):**
```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

START TRANSACTION;

-- 잔액 변경 및 COMMIT
UPDATE accounts SET balance = 1500000 WHERE account_id = 'A001';
COMMIT;  -- 확정!
```

**세션 1 (다시):**
```sql
-- 같은 트랜잭션 내에서 다시 조회
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 1,500,000 (값이 바뀜!)

-- Non-Repeatable Read: 같은 트랜잭션 내에서 같은 데이터를 읽었는데 값이 달라짐

COMMIT;
```

### 4.3. 장단점

**장점:**
- Dirty Read 방지 (커밋된 데이터만 읽음)
- 성능이 좋음 (잠금이 적음)

**단점:**
- Non-Repeatable Read 발생
- 일관된 스냅샷을 보장하지 않음

### 4.4. 사용 사례

- 대부분의 웹 애플리케이션
- 각 쿼리가 최신 데이터를 봐야 하는 경우
- Oracle, PostgreSQL 사용 시 (기본값)

---

## 5. REPEATABLE READ (레벨 2)

### 5.1. 특징

- **MySQL InnoDB의 기본 격리 수준**
- 트랜잭션 내에서 **같은 데이터를 여러 번 읽어도 항상 같은 값** 보장
- Non-Repeatable Read 방지
- MySQL InnoDB는 Phantom Read도 방지 (MVCC 사용)

### 5.2. MVCC (Multi-Version Concurrency Control)

```
MVCC: 각 트랜잭션이 데이터의 특정 시점 스냅샷을 봄

트랜잭션 A 시작 (시각 T1)
  ↓
데이터 변경 (시각 T2)
  ↓
트랜잭션 A는 여전히 T1 시점의 데이터를 봄 (일관성 유지)
```

### 5.3. Repeatable Read 시연

**세션 1 (사용자 A):**
```sql
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

START TRANSACTION;

-- 첫 번째 조회
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 1,000,000
```

**세션 2 (사용자 B):**
```sql
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

START TRANSACTION;

-- 잔액 변경 및 COMMIT
UPDATE accounts SET balance = 2000000 WHERE account_id = 'A001';
COMMIT;
```

**세션 1 (다시):**
```sql
-- 같은 트랜잭션 내에서 다시 조회
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 여전히 1,000,000!

-- Repeatable Read: 트랜잭션 시작 시점의 스냅샷을 유지

COMMIT;

-- COMMIT 후 새 트랜잭션에서 조회
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 2,000,000
```

### 5.4. Phantom Read (MySQL에서는 방지됨)

**일반적인 REPEATABLE READ (다른 DBMS):**
- 같은 행을 읽으면 같은 값 보장
- 하지만 새로운 행이 추가되는 것은 방지 못함 (Phantom Read)

**MySQL InnoDB:**
- **Next-Key Lock**으로 Phantom Read도 방지
- 범위 검색 시 범위 자체를 잠금

```sql
-- 세션 1
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;

-- 범위 조회
SELECT COUNT(*) FROM accounts WHERE balance > 1000000;  -- 예: 5개

-- 세션 2에서 새 행 추가 시도
-- INSERT INTO accounts VALUES ('E001', 'Eve', 1500000);
-- 대기... (세션 1이 범위를 잠금)

-- 세션 1에서 다시 조회
SELECT COUNT(*) FROM accounts WHERE balance > 1000000;  -- 여전히 5개 (Phantom Read 방지)

COMMIT;
```

### 5.5. 사용 사례

- MySQL/MariaDB 애플리케이션 (기본값)
- 보고서 생성 (일관된 스냅샷 필요)
- 금융 트랜잭션 (정확한 일관성 필요)

---

## 6. SERIALIZABLE (레벨 3)

### 6.1. 특징

- **가장 높은 격리 수준**
- 트랜잭션을 **순차적으로 실행하는 것처럼** 동작
- 모든 읽기 문제 방지 (Dirty, Non-Repeatable, Phantom)
- 성능이 가장 낮음 (동시성 거의 없음)

### 6.2. 동작 방식

```sql
-- 세션 1
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;

-- 단순 SELECT도 공유 락(Shared Lock) 획득
SELECT * FROM accounts WHERE account_id = 'A001';

-- 세션 2에서 이 행을 UPDATE하려고 하면 대기...
```

**세션 2:**
```sql
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;

-- 세션 1이 SELECT한 행을 UPDATE 시도
UPDATE accounts SET balance = 3000000 WHERE account_id = 'A001';
-- 대기... (세션 1이 COMMIT할 때까지)
```

**세션 1:**
```sql
COMMIT;  -- 이제 세션 2가 실행됨
```

### 6.3. 사용 사례

거의 사용하지 않지만, 다음 경우에만:
- 데이터 정확도가 절대적으로 중요한 경우
- 동시 사용자가 적은 경우
- 배치 작업 (단독 실행)

---

## 7. 격리 수준별 문제 비교

### 7.1. Dirty Read (더티 리드)

**정의:** 커밋되지 않은 데이터를 읽음

```sql
-- 트랜잭션 A
UPDATE accounts SET balance = 999 WHERE account_id = 'A001';
-- COMMIT 안 함

-- 트랜잭션 B (READ UNCOMMITTED)
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 999 (Dirty Read)

-- 트랜잭션 A
ROLLBACK;  -- 취소! B는 존재하지 않는 데이터를 읽음
```

**발생:** READ UNCOMMITTED
**방지:** READ COMMITTED 이상

### 7.2. Non-Repeatable Read (반복 불가능 읽기)

**정의:** 같은 트랜잭션 내에서 같은 데이터를 읽었는데 값이 달라짐

```sql
-- 트랜잭션 A
START TRANSACTION;
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 1000

-- 트랜잭션 B
UPDATE accounts SET balance = 2000 WHERE account_id = 'A001';
COMMIT;

-- 트랜잭션 A (계속)
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 2000 (값이 바뀜!)
```

**발생:** READ UNCOMMITTED, READ COMMITTED
**방지:** REPEATABLE READ 이상

### 7.3. Phantom Read (팬텀 리드)

**정의:** 같은 쿼리를 실행했는데 결과 행의 개수가 달라짐

```sql
-- 트랜잭션 A
START TRANSACTION;
SELECT COUNT(*) FROM accounts WHERE balance > 1000;  -- 5개

-- 트랜잭션 B
INSERT INTO accounts VALUES ('F001', 'Frank', 1500);
COMMIT;

-- 트랜잭션 A (계속)
SELECT COUNT(*) FROM accounts WHERE balance > 1000;  -- 6개 (행 추가됨!)
```

**발생:** READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ (일반적으로)
**방지:** SERIALIZABLE (MySQL REPEATABLE READ도 방지)

---

## 8. 격리 수준 설정 방법

### 8.1. 세션 수준 설정

```sql
-- 현재 세션의 격리 수준 변경
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- 확인
SELECT @@transaction_isolation;
```

### 8.2. 다음 트랜잭션만 설정

```sql
-- 다음 트랜잭션에만 적용
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

START TRANSACTION;
-- 이 트랜잭션만 READ COMMITTED
COMMIT;

-- 이후 트랜잭션은 원래 설정으로 돌아감
```

### 8.3. 글로벌 설정 (my.cnf)

```ini
[mysqld]
transaction-isolation = REPEATABLE-READ
```

---

## 9. 실습 문제

### 문제 1: Dirty Read 테스트 (난이도: ⭐⭐)

두 세션을 열어 READ UNCOMMITTED에서 Dirty Read가 발생하는지 확인하세요.

```sql
-- 세션 1
-- 여기에 SQL 작성

-- 세션 2
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
-- 세션 1
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;

-- 초기 값 확인
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 1,000,000

-- 세션 2
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;

-- 값 변경 (COMMIT 안 함)
UPDATE accounts SET balance = 888888 WHERE account_id = 'A001';

-- 세션 1 (다시)
-- Dirty Read 발생!
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 888888

-- 세션 2
ROLLBACK;

-- 세션 1
-- 존재하지 않던 데이터를 읽음
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 1,000,000
COMMIT;
```
</details>

---

### 문제 2: Non-Repeatable Read 비교 (난이도: ⭐⭐⭐)

READ COMMITTED와 REPEATABLE READ에서 Non-Repeatable Read 발생 여부를 비교하세요.

<details>
<summary>정답 보기</summary>

```sql
-- 실험 1: READ COMMITTED
-- 세션 1
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 1,000,000

-- 세션 2
UPDATE accounts SET balance = 1500000 WHERE account_id = 'A001';
COMMIT;

-- 세션 1 (다시)
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 1,500,000 (Non-Repeatable Read!)
COMMIT;

-- 실험 2: REPEATABLE READ
-- 세션 1
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 1,500,000

-- 세션 2
UPDATE accounts SET balance = 2000000 WHERE account_id = 'A001';
COMMIT;

-- 세션 1 (다시)
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 여전히 1,500,000 (방지됨!)
COMMIT;
```
</details>

---

### 문제 3: 격리 수준과 성능 비교 (난이도: ⭐⭐⭐)

서로 다른 격리 수준에서 동시 트랜잭션 처리 시간을 비교하세요.

<details>
<summary>정답 보기</summary>

```sql
-- 테스트 준비
CREATE TABLE test_accounts (
    id INT PRIMARY KEY AUTO_INCREMENT,
    balance DECIMAL(15,2)
);

INSERT INTO test_accounts (balance)
SELECT 1000000 FROM
(SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) a,
(SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) b,
(SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) c;

-- READ COMMITTED 테스트
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
-- 두 세션에서 동시에 UPDATE 실행 → 상대적으로 빠름

-- SERIALIZABLE 테스트
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
-- 두 세션에서 동시에 UPDATE 실행 → 순차 실행되어 느림

-- 정리
DROP TABLE test_accounts;
```
</details>

---

## 강사 가이드

### 수업 진행 팁

1. **두 세션 실습 필수** (30분)
   - 학생들을 2인 1조로 구성
   - 각자 MySQL 클라이언트 실행
   - Dirty Read, Non-Repeatable Read 직접 체험

2. **격리 수준 순서대로** (각 10분)
   - READ UNCOMMITTED → READ COMMITTED → REPEATABLE READ → SERIALIZABLE
   - 각 수준에서 발생하는 문제 시연
   - 점진적으로 문제가 해결되는 것 강조

3. **MySQL 특수성 강조** (5분)
   - MySQL REPEATABLE READ는 Phantom Read도 방지
   - 다른 DBMS와 다름을 명확히
   - Next-Key Lock 개념 소개

4. **실무 선택 기준** (10분)
   - 대부분: REPEATABLE READ (MySQL 기본값)
   - 높은 동시성 필요: READ COMMITTED
   - 절대 정확도: SERIALIZABLE
   - READ UNCOMMITTED는 거의 사용 안 함

5. **성능 vs 정확도 트레이드오프** (5분)
   - 비즈니스 요구사항에 따라 선택
   - 모든 상황에 완벽한 답은 없음
   - 테스트를 통해 최적값 찾기

### 자주 하는 질문

**Q1: MySQL은 왜 REPEATABLE READ가 기본인가요?**
> A: MySQL은 Replication(복제)을 고려하여 REPEATABLE READ를 기본값으로 설정했습니다. 일관된 스냅샷이 복제에 유리합니다. Oracle/PostgreSQL은 READ COMMITTED가 기본입니다.

**Q2: READ UNCOMMITTED는 언제 사용하나요?**
> A: 거의 사용하지 않습니다. 대략적인 실시간 통계나 모니터링에서만 고려합니다. 데이터 정확도가 중요하지 않은 경우에만 사용하세요.

**Q3: 격리 수준을 트랜잭션마다 바꿀 수 있나요?**
> A: 네, `SET TRANSACTION ISOLATION LEVEL`로 다음 트랜잭션의 격리 수준을 변경할 수 있습니다. 하지만 일관성을 위해 애플리케이션 전체에서 같은 수준을 사용하는 것이 좋습니다.

**Q4: SERIALIZABLE을 사용하면 동시 처리가 불가능한가요?**
> A: 거의 불가능합니다. 트랜잭션이 순차적으로 실행되므로 동시성이 매우 낮습니다. 멀티코어 CPU의 이점을 활용할 수 없어 성능이 크게 저하됩니다.

**Q5: 격리 수준이 높을수록 무조건 좋은 건가요?**
> A: 아니요. 높은 격리 수준은 성능 저하를 가져옵니다. 비즈니스 요구사항에 맞는 적절한 수준을 선택해야 합니다.

---

## 요약

### 핵심 개념

**4가지 격리 수준**

1. **READ UNCOMMITTED (레벨 0)**
   - 커밋 안 된 데이터도 읽기 가능
   - Dirty Read 발생
   - 거의 사용 안 함

2. **READ COMMITTED (레벨 1)**
   - 커밋된 데이터만 읽기
   - Non-Repeatable Read 발생
   - Oracle, PostgreSQL 기본값

3. **REPEATABLE READ (레벨 2)**
   - 트랜잭션 내 일관된 스냅샷
   - MySQL 기본값
   - MySQL은 Phantom Read도 방지

4. **SERIALIZABLE (레벨 3)**
   - 완전한 격리 (순차 실행)
   - 모든 문제 방지
   - 성능 최저

### 발생 가능한 문제

| 문제 | 설명 | 방지 수준 |
|-----|------|----------|
| Dirty Read | 커밋 안 된 데이터 읽기 | READ COMMITTED 이상 |
| Non-Repeatable Read | 같은 데이터 읽었는데 값 변경 | REPEATABLE READ 이상 |
| Phantom Read | 같은 쿼리 실행했는데 행 수 변경 | SERIALIZABLE (MySQL은 REPEATABLE READ) |

### 명령어

```sql
-- 격리 수준 확인
SELECT @@transaction_isolation;

-- 격리 수준 설정
SET SESSION TRANSACTION ISOLATION LEVEL {level};
SET TRANSACTION ISOLATION LEVEL {level};
```

### 다음 단계

다음 시간에는 **락(Lock)과 동시성 제어**를 학습합니다:
- 공유 락(Shared Lock) vs 배타적 락(Exclusive Lock)
- 행 수준 락 vs 테이블 수준 락
- 락 대기와 타임아웃
- 락 모니터링

---

**연습 권장사항:**
- 두 세션으로 모든 격리 수준 테스트
- 각 격리 수준에서 발생하는 문제 직접 확인
- 실무 애플리케이션의 격리 수준 확인
- 성능 테스트로 격리 수준별 차이 측정
