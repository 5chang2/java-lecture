# 5.7. 실습: 트랜잭션 실습 종합 프로젝트

## 학습 목표
- 트랜잭션, ACID, 격리 수준, 락, 데드락을 종합적으로 활용한다
- 실무 시나리오 기반의 동시성 제어 문제를 해결한다
- 데이터 일관성을 보장하는 안전한 시스템을 구현한다

---

## 프로젝트 개요

이번 실습에서는 **온라인 티켓 예매 시스템**을 구현하면서 트랜잭션과 동시성 제어의 모든 개념을 활용합니다.

각 미션은 실무에서 자주 마주치는 동시성 문제를 해결하는 것에 초점을 둡니다.

---

## Mission 1: 안전한 티켓 예매 시스템 (난이도: ⭐⭐)

### 시나리오
동시에 여러 사용자가 같은 티켓을 예매하려고 할 때, **한 명만 예매에 성공**하도록 보장해야 합니다.

### 요구사항

**1-1. 테이블 생성**

```sql
-- 공연 정보
CREATE TABLE shows (
    show_id INT PRIMARY KEY AUTO_INCREMENT,
    show_name VARCHAR(100),
    show_date DATE,
    total_seats INT
);

-- 좌석 정보
CREATE TABLE seats (
    seat_id INT PRIMARY KEY AUTO_INCREMENT,
    show_id INT,
    seat_number VARCHAR(10),
    status ENUM('available', 'reserved', 'sold') DEFAULT 'available',
    FOREIGN KEY (show_id) REFERENCES shows(show_id)
);

-- 예매 정보
CREATE TABLE bookings (
    booking_id INT PRIMARY KEY AUTO_INCREMENT,
    seat_id INT,
    customer_name VARCHAR(100),
    customer_email VARCHAR(100),
    booking_date DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (seat_id) REFERENCES seats(seat_id)
);

-- 샘플 데이터
INSERT INTO shows (show_name, show_date, total_seats)
VALUES ('뮤지컬 오페라의 유령', '2025-12-25', 100);

INSERT INTO seats (show_id, seat_number, status)
SELECT 1, CONCAT('A', num), 'available'
FROM (
    SELECT @row := @row + 1 AS num
    FROM (SELECT 0 UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4) t1,
         (SELECT 0 UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4) t2,
         (SELECT @row:=0) t3
) numbers
WHERE num <= 100;
```

**1-2. 안전한 예매 프로시저 작성**

동시 예매를 방지하는 프로시저를 작성하세요.

**요구사항:**
- 좌석 상태 확인 (available만 예매 가능)
- FOR UPDATE로 락 획득
- 예매 성공 시 상태를 'reserved'로 변경
- ACID 속성 보장

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
DELIMITER $$

CREATE PROCEDURE book_seat(
    IN p_seat_id INT,
    IN p_customer_name VARCHAR(100),
    IN p_customer_email VARCHAR(100),
    OUT p_result VARCHAR(100)
)
BEGIN
    DECLARE seat_status VARCHAR(20);

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_result = 'Error: Booking failed';
    END;

    START TRANSACTION;

    -- 좌석 상태 확인 및 락 획득
    SELECT status INTO seat_status
    FROM seats
    WHERE seat_id = p_seat_id
    FOR UPDATE;  -- 배타적 락

    -- 예매 가능 여부 확인
    IF seat_status = 'available' THEN
        -- 좌석 상태 변경
        UPDATE seats
        SET status = 'reserved'
        WHERE seat_id = p_seat_id;

        -- 예매 기록 생성
        INSERT INTO bookings (seat_id, customer_name, customer_email)
        VALUES (p_seat_id, p_customer_name, p_customer_email);

        SET p_result = 'Success: Seat booked';
        COMMIT;
    ELSE
        SET p_result = CONCAT('Failed: Seat is ', seat_status);
        ROLLBACK;
    END IF;
END$$

DELIMITER ;

-- 사용
CALL book_seat(1, 'Alice', 'alice@example.com', @result);
SELECT @result;

-- 동시 예매 테스트 (두 세션에서 동시 실행)
-- 한 세션만 성공, 다른 세션은 대기 후 실패
```
</details>

---

### 문제 1-3: 동시성 테스트 (난이도: ⭐⭐⭐)

두 세션을 열어 같은 좌석을 동시에 예매하고, 한 명만 성공하는지 확인하세요.

<details>
<summary>정답 보기</summary>

```sql
-- 세션 1
CALL book_seat(2, 'Bob', 'bob@example.com', @result1);
SELECT @result1;

-- 세션 2 (동시에 실행)
CALL book_seat(2, 'Charlie', 'charlie@example.com', @result2);
SELECT @result2;

-- 결과 확인
-- 한 세션: "Success: Seat booked"
-- 다른 세션: "Failed: Seat is reserved"

SELECT * FROM bookings WHERE seat_id = 2;  -- 한 명만 예매됨
```
</details>

---

## Mission 2: 계좌 이체 시스템 (난이도: ⭐⭐⭐)

### 시나리오
은행 계좌 간 이체 시 **데이터 일관성을 보장**하고 **데드락을 예방**해야 합니다.

### 요구사항

**2-1. 테이블 생성**

```sql
CREATE TABLE bank_accounts (
    account_id VARCHAR(20) PRIMARY KEY,
    account_holder VARCHAR(100),
    balance DECIMAL(15, 2) NOT NULL CHECK (balance >= 0),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE transactions (
    transaction_id INT PRIMARY KEY AUTO_INCREMENT,
    from_account VARCHAR(20),
    to_account VARCHAR(20),
    amount DECIMAL(15, 2),
    transaction_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status ENUM('success', 'failed', 'pending') DEFAULT 'pending',
    FOREIGN KEY (from_account) REFERENCES bank_accounts(account_id),
    FOREIGN KEY (to_account) REFERENCES bank_accounts(account_id)
);

-- 샘플 데이터
INSERT INTO bank_accounts (account_id, account_holder, balance) VALUES
('ACC001', 'Alice', 1000000),
('ACC002', 'Bob', 500000),
('ACC003', 'Charlie', 750000),
('ACC004', 'David', 1200000);
```

**2-2. 데드락 방지 이체 프로시저**

락 획득 순서를 일관되게 유지하여 데드락을 예방하는 프로시저를 작성하세요.

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
DELIMITER $$

CREATE PROCEDURE safe_transfer(
    IN p_from_account VARCHAR(20),
    IN p_to_account VARCHAR(20),
    IN p_amount DECIMAL(15, 2),
    OUT p_result VARCHAR(100)
)
BEGIN
    DECLARE from_balance DECIMAL(15, 2);
    DECLARE first_acc VARCHAR(20);
    DECLARE second_acc VARCHAR(20);

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_result = 'Error: Transfer failed';
    END;

    -- 데드락 방지: 계좌 ID 정렬 (항상 작은 ID부터 락)
    IF p_from_account < p_to_account THEN
        SET first_acc = p_from_account;
        SET second_acc = p_to_account;
    ELSE
        SET first_acc = p_to_account;
        SET second_acc = p_from_account;
    END IF;

    START TRANSACTION;

    -- 항상 같은 순서로 락 획득
    SELECT balance INTO from_balance
    FROM bank_accounts
    WHERE account_id = first_acc
    FOR UPDATE;

    SELECT balance INTO from_balance
    FROM bank_accounts
    WHERE account_id = second_acc
    FOR UPDATE;

    -- 출금 계좌 잔액 확인
    SELECT balance INTO from_balance
    FROM bank_accounts
    WHERE account_id = p_from_account;

    IF from_balance < p_amount THEN
        SET p_result = 'Failed: Insufficient balance';
        ROLLBACK;
    ELSE
        -- 이체 실행
        UPDATE bank_accounts
        SET balance = balance - p_amount
        WHERE account_id = p_from_account;

        UPDATE bank_accounts
        SET balance = balance + p_amount
        WHERE account_id = p_to_account;

        -- 거래 기록
        INSERT INTO transactions (from_account, to_account, amount, status)
        VALUES (p_from_account, p_to_account, p_amount, 'success');

        SET p_result = 'Success: Transfer completed';
        COMMIT;
    END IF;
END$$

DELIMITER ;

-- 사용
CALL safe_transfer('ACC001', 'ACC002', 100000, @result);
SELECT @result;

-- 총 잔액 확인 (일관성 체크)
SELECT SUM(balance) FROM bank_accounts;  -- 항상 동일해야 함
```
</details>

---

### 문제 2-3: 데드락 방지 테스트 (난이도: ⭐⭐⭐)

두 세션에서 서로 반대 방향으로 이체해도 데드락이 발생하지 않는지 확인하세요.

<details>
<summary>정답 보기</summary>

```sql
-- 세션 1: A → B 이체
CALL safe_transfer('ACC001', 'ACC002', 50000, @result1);
SELECT @result1;

-- 세션 2 (동시에): B → A 이체
CALL safe_transfer('ACC002', 'ACC001', 30000, @result2);
SELECT @result2;

-- 데드락 발생 안 함! (락 획득 순서가 같기 때문)
-- 순차적으로 실행됨

-- 일관성 확인
SELECT account_id, balance FROM bank_accounts
WHERE account_id IN ('ACC001', 'ACC002');

SELECT SUM(balance) FROM bank_accounts;  -- 총액 불변
```
</details>

---

## Mission 3: 재고 관리 시스템 (난이도: ⭐⭐⭐⭐)

### 시나리오
동시 주문 시 **재고 부족 문제**를 방지하고, **ACID 속성**을 보장해야 합니다.

### 요구사항

**3-1. 테이블 생성**

```sql
CREATE TABLE products (
    product_id INT PRIMARY KEY AUTO_INCREMENT,
    product_name VARCHAR(100),
    stock INT NOT NULL CHECK (stock >= 0),
    price DECIMAL(10, 2)
);

CREATE TABLE orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_name VARCHAR(100),
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    total_amount DECIMAL(10, 2),
    status ENUM('pending', 'confirmed', 'cancelled') DEFAULT 'pending'
);

CREATE TABLE order_items (
    order_item_id INT PRIMARY KEY AUTO_INCREMENT,
    order_id INT,
    product_id INT,
    quantity INT,
    price DECIMAL(10, 2),
    FOREIGN KEY (order_id) REFERENCES orders(order_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);

-- 샘플 데이터
INSERT INTO products (product_name, stock, price) VALUES
('노트북', 10, 1200000),
('마우스', 50, 30000),
('키보드', 30, 80000);
```

**3-2. 안전한 주문 프로시저**

재고 확인 및 차감을 안전하게 처리하는 프로시저를 작성하세요.

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
DELIMITER $$

CREATE PROCEDURE create_order(
    IN p_customer_name VARCHAR(100),
    IN p_product_id INT,
    IN p_quantity INT,
    OUT p_result VARCHAR(100)
)
BEGIN
    DECLARE current_stock INT;
    DECLARE product_price DECIMAL(10, 2);
    DECLARE new_order_id INT;
    DECLARE total DECIMAL(10, 2);

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_result = 'Error: Order failed';
    END;

    START TRANSACTION;

    -- 재고 확인 및 락 획득
    SELECT stock, price INTO current_stock, product_price
    FROM products
    WHERE product_id = p_product_id
    FOR UPDATE;  -- 배타적 락

    -- 재고 충분한지 확인
    IF current_stock < p_quantity THEN
        SET p_result = CONCAT('Failed: Insufficient stock (available: ', current_stock, ')');
        ROLLBACK;
    ELSE
        -- 재고 차감
        UPDATE products
        SET stock = stock - p_quantity
        WHERE product_id = p_product_id;

        -- 주문 생성
        SET total = product_price * p_quantity;

        INSERT INTO orders (customer_name, total_amount, status)
        VALUES (p_customer_name, total, 'confirmed');

        SET new_order_id = LAST_INSERT_ID();

        -- 주문 항목 추가
        INSERT INTO order_items (order_id, product_id, quantity, price)
        VALUES (new_order_id, p_product_id, p_quantity, product_price);

        SET p_result = CONCAT('Success: Order #', new_order_id, ' created');
        COMMIT;
    END IF;
END$$

DELIMITER ;

-- 사용
CALL create_order('Alice', 1, 2, @result);
SELECT @result;

-- 재고 확인
SELECT product_name, stock FROM products WHERE product_id = 1;
```
</details>

---

### 문제 3-3: 동시 주문 시나리오 (난이도: ⭐⭐⭐⭐)

재고가 5개인 상품에 대해 3개씩 동시 주문 시, 한 주문만 성공하는지 확인하세요.

<details>
<summary>정답 보기</summary>

```sql
-- 재고 5개로 설정
UPDATE products SET stock = 5 WHERE product_id = 1;

-- 세션 1: 3개 주문
CALL create_order('Bob', 1, 3, @result1);
SELECT @result1;

-- 세션 2 (동시에): 3개 주문
CALL create_order('Charlie', 1, 3, @result2);
SELECT @result2;

-- 결과 확인
-- 한 세션: "Success: Order #X created"
-- 다른 세션: "Failed: Insufficient stock (available: 2)"

SELECT product_name, stock FROM products WHERE product_id = 1;  -- 2개 남음
SELECT * FROM orders WHERE status = 'confirmed';  -- 1건만 성공
```
</details>

---

## Mission 4: 격리 수준별 동작 비교 (난이도: ⭐⭐⭐)

### 시나리오
서로 다른 격리 수준에서 **동시성 문제**가 어떻게 나타나는지 확인합니다.

### 요구사항

**4-1. Dirty Read 테스트**

READ UNCOMMITTED와 READ COMMITTED에서 Dirty Read 발생 여부를 비교하세요.

<details>
<summary>정답 보기</summary>

```sql
-- 테스트 데이터
CREATE TABLE test_isolation (
    id INT PRIMARY KEY,
    value INT
);

INSERT INTO test_isolation VALUES (1, 100);

-- 실험 1: READ UNCOMMITTED
-- 세션 1
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;
SELECT value FROM test_isolation WHERE id = 1;  -- 100

-- 세션 2
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;
UPDATE test_isolation SET value = 999 WHERE id = 1;  -- COMMIT 안 함

-- 세션 1 (다시)
SELECT value FROM test_isolation WHERE id = 1;  -- 999 (Dirty Read!)

-- 세션 2
ROLLBACK;

-- 세션 1
SELECT value FROM test_isolation WHERE id = 1;  -- 100 (존재하지 않던 데이터를 읽음)
COMMIT;

-- 실험 2: READ COMMITTED
-- 세션 1
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
SELECT value FROM test_isolation WHERE id = 1;  -- 100

-- 세션 2
START TRANSACTION;
UPDATE test_isolation SET value = 888 WHERE id = 1;  -- COMMIT 안 함

-- 세션 1 (다시)
SELECT value FROM test_isolation WHERE id = 1;  -- 100 (Dirty Read 방지!)

-- 세션 2
COMMIT;

-- 세션 1
SELECT value FROM test_isolation WHERE id = 1;  -- 888 (COMMIT 후에만 보임)
COMMIT;

-- 정리
DROP TABLE test_isolation;
```
</details>

---

### 문제 4-2: Repeatable Read 테스트 (난이도: ⭐⭐⭐)

REPEATABLE READ에서 일관된 스냅샷이 유지되는지 확인하세요.

<details>
<summary>정답 보기</summary>

```sql
-- 세션 1
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT balance FROM bank_accounts WHERE account_id = 'ACC001';  -- 예: 1,000,000

-- 세션 2
UPDATE bank_accounts SET balance = 2000000 WHERE account_id = 'ACC001';
-- COMMIT (즉시 확정, autocommit이 ON이면)

-- 세션 1 (다시)
SELECT balance FROM bank_accounts WHERE account_id = 'ACC001';  -- 여전히 1,000,000
-- MVCC로 트랜잭션 시작 시점의 스냅샷 유지!

COMMIT;

-- 새 트랜잭션에서 조회
SELECT balance FROM bank_accounts WHERE account_id = 'ACC001';  -- 2,000,000
```
</details>

---

## Mission 5: 종합 프로젝트 - 온라인 쇼핑몰 (난이도: ⭐⭐⭐⭐⭐)

### 시나리오
완전한 온라인 쇼핑몰 주문 시스템을 구현하며, 모든 동시성 제어 개념을 종합 활용합니다.

### 요구사항

**5-1. 복합 주문 프로시저**

여러 상품을 한 번에 주문하는 프로시저를 작성하세요.

**조건:**
- 모든 상품의 재고가 충분해야 주문 성공
- 하나라도 재고 부족 시 전체 롤백 (원자성)
- 데드락 방지
- 격리 수준 고려

<details>
<summary>정답 보기</summary>

```sql
DELIMITER $$

CREATE PROCEDURE create_multi_item_order(
    IN p_customer_name VARCHAR(100),
    IN p_product_ids VARCHAR(200),  -- '1,2,3' 형식
    IN p_quantities VARCHAR(200),    -- '2,1,3' 형식
    OUT p_result VARCHAR(200)
)
BEGIN
    DECLARE new_order_id INT;
    DECLARE total_amount DECIMAL(10, 2) DEFAULT 0;
    DECLARE i INT DEFAULT 1;
    DECLARE product_id INT;
    DECLARE quantity INT;
    DECLARE stock INT;
    DECLARE price DECIMAL(10, 2);

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_result = 'Error: Order failed - rolled back';
    END;

    START TRANSACTION;

    -- 주문 생성 (일단 pending)
    INSERT INTO orders (customer_name, total_amount, status)
    VALUES (p_customer_name, 0, 'pending');

    SET new_order_id = LAST_INSERT_ID();

    -- 각 상품 처리 (간단한 구현)
    -- 실무에서는 JSON이나 임시 테이블 사용

    -- 상품 1 처리 예시 (product_id = 1, quantity = 2)
    SELECT stock, price INTO stock, price
    FROM products WHERE product_id = 1 FOR UPDATE;

    IF stock < 2 THEN
        SET p_result = 'Failed: Product 1 insufficient stock';
        ROLLBACK;
    ELSE
        UPDATE products SET stock = stock - 2 WHERE product_id = 1;
        INSERT INTO order_items (order_id, product_id, quantity, price)
        VALUES (new_order_id, 1, 2, price);
        SET total_amount = total_amount + (price * 2);
    END IF;

    -- 주문 확정
    UPDATE orders SET total_amount = total_amount, status = 'confirmed'
    WHERE order_id = new_order_id;

    SET p_result = CONCAT('Success: Order #', new_order_id);
    COMMIT;
END$$

DELIMITER ;
```
</details>

---

## 강사 가이드

### 수업 진행 팁

1. **Mission 1부터 순차적으로** (전체 180분)
   - Mission 1 (30분): FOR UPDATE 기본
   - Mission 2 (40분): 데드락 예방
   - Mission 3 (40분): 재고 관리
   - Mission 4 (30분): 격리 수준
   - Mission 5 (40분): 종합 프로젝트

2. **동시성 테스트 강조** (각 미션마다)
   - 반드시 두 세션으로 테스트
   - 동시 실행 시 어떻게 동작하는지 확인
   - 락 대기와 타임아웃 경험

3. **일관성 검증** (각 트랜잭션 후)
   - 총 잔액이 변하지 않는지 (계좌 이체)
   - 재고가 음수가 아닌지 (주문)
   - 데이터 무결성 확인

4. **실수 시나리오 시연** (각 미션마다)
   - FOR UPDATE를 빼면 어떻게 되는지
   - 트랜잭션을 안 쓰면 어떻게 되는지
   - "이래서 필요합니다" 강조

5. **코드 리뷰 세션** (20분)
   - 우수 사례 공유
   - 개선점 논의
   - 실무 팁 공유

### 평가 기준

| 항목 | 배점 | 평가 기준 |
|-----|------|---------|
| **기능 정확성** | 40% | 동시성 제어가 올바르게 동작하는가 |
| **ACID 보장** | 30% | 원자성, 일관성, 격리성, 지속성 준수 |
| **데드락 예방** | 20% | 락 획득 순서, 트랜잭션 길이 고려 |
| **코드 품질** | 10% | 가독성, 오류 처리, 주석 |

---

## 요약

### 실습에서 다룬 개념

1. **트랜잭션 기본**
   - START TRANSACTION, COMMIT, ROLLBACK
   - ACID 속성 보장

2. **동시성 제어**
   - FOR UPDATE로 배타적 락
   - FOR SHARE로 공유 락

3. **데드락 예방**
   - 락 획득 순서 일관성
   - 트랜잭션 길이 단축

4. **격리 수준**
   - READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ
   - 각 수준에서의 동작 차이

5. **실무 패턴**
   - 좌석 예매 시스템
   - 계좌 이체 시스템
   - 재고 관리 시스템

### 핵심 교훈

- **항상 트랜잭션 사용**: 여러 SQL 문이 하나의 논리적 작업을 구성할 때
- **FOR UPDATE 필수**: 읽고 쓰는 패턴에서 동시성 제어
- **락 순서 일관성**: 데드락 예방의 핵심
- **짧은 트랜잭션**: 성능과 동시성 향상
- **일관성 검증**: 트랜잭션 후 데이터 무결성 확인

### 다음 단계

**6장: NoSQL 데이터베이스**에서 학습할 내용:
- NoSQL과 SQL의 차이점
- MongoDB 기본 사용법
- 트랜잭션이 없는 환경에서의 데이터 처리
- CAP 정리와 최종 일관성 (Eventual Consistency)

---

**축하합니다!** 5장 트랜잭션과 동시성을 완료했습니다. 이제 여러분은 안전하고 일관된 데이터베이스 시스템을 구축할 수 있습니다.

**연습 권장사항:**
- 실제 웹 애플리케이션에 트랜잭션 적용해보기
- 의도적으로 동시성 문제 만들고 해결하기
- 다양한 격리 수준 테스트
- 데드락 발생 및 예방 연습
- 실무 시나리오에 맞는 프로시저 작성
