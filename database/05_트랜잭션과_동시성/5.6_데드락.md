# 5.6. 데드락(Deadlock) 이해와 예방

## 학습 목표
- 데드락의 개념과 발생 원인을 이해한다
- 데드락 발생 조건과 탐지 방법을 학습한다
- 데드락 예방 및 해결 전략을 익힌다
- 실무에서 데드락을 처리하는 방법을 학습한다

---

## 1. 데드락(Deadlock)이란?

**데드락(교착 상태)**은 두 개 이상의 트랜잭션이 **서로가 보유한 락을 기다리면서 무한히 대기**하는 상황입니다.

```
데드락 = "서로를 기다리며 멈춰버린 상태"

트랜잭션 A: 자원 1을 보유, 자원 2를 기다림 ⏳
트랜잭션 B: 자원 2를 보유, 자원 1을 기다림 ⏳

→ 둘 다 영원히 진행하지 못함!
```

### 1.1. 실생활 비유

```
도로 교차로에서의 교착 상태:

북쪽 차: 동쪽 차가 비켜주길 기다림
동쪽 차: 남쪽 차가 비켜주길 기다림
남쪽 차: 서쪽 차가 비켜주길 기다림
서쪽 차: 북쪽 차가 비켜주길 기다림

→ 아무도 움직이지 못함! (데드락)
```

---

## 2. 데드락 발생 예제

### 2.1. 간단한 데드락 시나리오

**세션 1 (트랜잭션 A):**
```sql
START TRANSACTION;

-- 계좌 A에 락 획득
UPDATE accounts SET balance = balance - 100 WHERE account_id = 'A001';

-- 잠시 대기 (세션 2가 계좌 B에 락을 걸 시간 주기)
-- DO SLEEP(5);
```

**세션 2 (트랜잭션 B - 동시에 실행):**
```sql
START TRANSACTION;

-- 계좌 B에 락 획득
UPDATE accounts SET balance = balance - 100 WHERE account_id = 'B001';

-- 잠시 대기
-- DO SLEEP(5);
```

**세션 1 (계속):**
```sql
-- 계좌 B에 락 시도 (세션 2가 보유 중)
UPDATE accounts SET balance = balance + 100 WHERE account_id = 'B001';
-- 대기... ⏳
```

**세션 2 (계속):**
```sql
-- 계좌 A에 락 시도 (세션 1이 보유 중)
UPDATE accounts SET balance = balance + 100 WHERE account_id = 'A001';
-- 대기... ⏳

-- 데드락 발생!
-- ERROR 1213: Deadlock found when trying to get lock; try restarting transaction
```

### 2.2. 데드락 발생 과정

```
시간    트랜잭션 A                    트랜잭션 B
-----------------------------------------------------------
T1      A001에 락 획득 🔒
T2                                   B001에 락 획득 🔒
T3      B001에 락 시도 ⏳
        (B가 보유 중 → 대기)
T4                                   A001에 락 시도 ⏳
                                     (A가 보유 중 → 대기)

💥 데드락 발생! 서로를 기다리는 순환 대기
```

---

## 3. 데드락 발생 조건 (4가지 필요조건)

데드락이 발생하려면 다음 **4가지 조건이 모두 만족**되어야 합니다:

### 3.1. 상호 배제 (Mutual Exclusion)

**자원은 한 번에 하나의 트랜잭션만 사용 가능**

```sql
-- 배타적 락: 한 트랜잭션만 보유 가능
UPDATE accounts SET balance = balance + 100 WHERE account_id = 'A001';
```

### 3.2. 점유와 대기 (Hold and Wait)

**자원을 보유한 상태에서 다른 자원을 기다림**

```sql
START TRANSACTION;
UPDATE accounts SET balance = ... WHERE account_id = 'A001';  -- 보유 🔒
UPDATE accounts SET balance = ... WHERE account_id = 'B001';  -- 대기 ⏳
```

### 3.3. 비선점 (No Preemption)

**다른 트랜잭션의 락을 강제로 빼앗을 수 없음**

```
트랜잭션 A가 락을 보유 중이면
트랜잭션 B는 A가 락을 해제할 때까지 기다려야 함
강제로 빼앗을 수 없음
```

### 3.4. 순환 대기 (Circular Wait)

**대기 관계가 순환 구조를 형성**

```
A → B → C → A (순환)

트랜잭션 A: B의 자원을 기다림
트랜잭션 B: C의 자원을 기다림
트랜잭션 C: A의 자원을 기다림
```

---

## 4. MySQL의 데드락 탐지 및 처리

### 4.1. 자동 데드락 탐지

MySQL InnoDB는 **자동으로 데드락을 탐지**합니다.

```
InnoDB Deadlock Detection:
1. 주기적으로 대기 그래프(Wait-for Graph) 확인
2. 순환 대기 발견 시 데드락 판단
3. "희생자(Victim)" 선택 (롤백할 트랜잭션)
4. 선택된 트랜잭션을 강제 롤백
5. 다른 트랜잭션은 계속 진행
```

### 4.2. 희생자 선택 기준

MySQL은 다음 기준으로 롤백할 트랜잭션을 선택합니다:
- **가장 적은 행을 수정한 트랜잭션** (롤백 비용이 낮음)
- Undo 로그가 적은 트랜잭션

### 4.3. 데드락 에러 메시지

```sql
ERROR 1213 (40001): Deadlock found when trying to get lock;
try restarting transaction
```

**애플리케이션에서의 처리:**
```java
// Java 예시
try {
    // 트랜잭션 실행
    executeTransaction();
} catch (SQLException e) {
    if (e.getErrorCode() == 1213) {  // Deadlock
        // 재시도
        retryTransaction();
    }
}
```

---

## 5. 데드락 정보 확인

### 5.1. 최근 데드락 정보 조회

```sql
-- 가장 최근 데드락 정보 확인
SHOW ENGINE INNODB STATUS\G

-- Deadlock 섹션에서 다음 정보 확인:
-- 1. 데드락에 연루된 트랜잭션들
-- 2. 각 트랜잭션이 보유한 락
-- 3. 각 트랜잭션이 기다리는 락
-- 4. 어떤 트랜잭션이 롤백되었는지
```

**출력 예시:**
```
------------------------
LATEST DETECTED DEADLOCK
------------------------
2025-01-15 10:30:45

*** (1) TRANSACTION:
TRANSACTION 12345, ACTIVE 10 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)
MySQL thread id 101, query id 5001 localhost root updating
UPDATE accounts SET balance = balance + 100 WHERE account_id = 'B001'

*** (1) WAITING FOR THIS LOCK:
RECORD LOCKS space id 25 page no 3 n bits 72 index PRIMARY of table accounts
trx id 12345 lock_mode X locks rec but not gap waiting

*** (2) TRANSACTION:
TRANSACTION 12346, ACTIVE 8 sec starting index read
mysql tables in use 1, locked 1
3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1
MySQL thread id 102, query id 5002 localhost root updating
UPDATE accounts SET balance = balance + 100 WHERE account_id = 'A001'

*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 25 page no 3 n bits 72 index PRIMARY of table accounts
trx id 12346 lock_mode X locks rec but not gap

*** (2) WAITING FOR THIS LOCK:
RECORD LOCKS space id 25 page no 3 n bits 72 index PRIMARY of table accounts
trx id 12346 lock_mode X locks rec but not gap waiting

*** WE ROLL BACK TRANSACTION (1)
```

---

## 6. 데드락 예방 전략

### 6.1. 락 획득 순서 일관성 유지

**가장 효과적인 예방 방법**

```sql
-- ❌ 나쁜 예: 트랜잭션마다 락 획득 순서가 다름
-- 트랜잭션 A
UPDATE accounts SET ... WHERE account_id = 'A001';  -- 먼저 A
UPDATE accounts SET ... WHERE account_id = 'B001';  -- 그다음 B

-- 트랜잭션 B
UPDATE accounts SET ... WHERE account_id = 'B001';  -- 먼저 B
UPDATE accounts SET ... WHERE account_id = 'A001';  -- 그다음 A
-- 데드락 발생 가능!

-- ✅ 좋은 예: 항상 같은 순서로 락 획득
-- 모든 트랜잭션
UPDATE accounts SET ... WHERE account_id = 'A001';  -- 항상 A 먼저
UPDATE accounts SET ... WHERE account_id = 'B001';  -- 그다음 B
```

**실무 적용:**
```sql
-- 계좌 ID를 정렬하여 항상 작은 ID부터 락 획득
DELIMITER $$

CREATE PROCEDURE safe_transfer(
    IN acc1 VARCHAR(10),
    IN acc2 VARCHAR(10),
    IN amount DECIMAL(15,2)
)
BEGIN
    DECLARE first_acc VARCHAR(10);
    DECLARE second_acc VARCHAR(10);

    -- ID 정렬 (항상 작은 ID부터)
    IF acc1 < acc2 THEN
        SET first_acc = acc1;
        SET second_acc = acc2;
    ELSE
        SET first_acc = acc2;
        SET second_acc = acc1;
    END IF;

    START TRANSACTION;

    -- 항상 같은 순서로 락 획득
    SELECT * FROM accounts WHERE account_id = first_acc FOR UPDATE;
    SELECT * FROM accounts WHERE account_id = second_acc FOR UPDATE;

    -- 이체 실행
    UPDATE accounts SET balance = balance - amount WHERE account_id = acc1;
    UPDATE accounts SET balance = balance + amount WHERE account_id = acc2;

    COMMIT;
END$$

DELIMITER ;
```

### 6.2. 트랜잭션 짧게 유지

```sql
-- ❌ 나쁜 예: 긴 트랜잭션
START TRANSACTION;
SELECT * FROM accounts WHERE account_id = 'A001' FOR UPDATE;
-- 복잡한 계산... (30초)
-- 외부 API 호출... (10초)
-- 파일 I/O... (20초)
UPDATE accounts SET ...;
COMMIT;

-- ✅ 좋은 예: 짧은 트랜잭션
-- 복잡한 계산 먼저 (트랜잭션 밖)
-- 외부 API 호출 (트랜잭션 밖)
-- 파일 I/O (트랜잭션 밖)

START TRANSACTION;
SELECT * FROM accounts WHERE account_id = 'A001' FOR UPDATE;
UPDATE accounts SET ...;
COMMIT;  -- 빠르게 종료
```

### 6.3. 인덱스 사용

인덱스가 없으면 풀 테이블 스캔을 하면서 과도한 락 발생 → 데드락 위험 증가

```sql
-- ❌ 나쁜 예: 인덱스 없음
UPDATE accounts SET balance = balance + 100
WHERE customer_name = 'Alice';  -- customer_name에 인덱스 없음
-- 전체 테이블을 스캔하면서 모든 행에 락!

-- ✅ 좋은 예: 인덱스 사용
CREATE INDEX idx_customer_name ON accounts(customer_name);

UPDATE accounts SET balance = balance + 100
WHERE customer_name = 'Alice';
-- 필요한 행에만 락
```

### 6.4. 락 타임아웃 설정

```sql
-- 락 대기 시간 설정 (데드락이 아닌 일반 락 대기에 유용)
SET innodb_lock_wait_timeout = 10;  -- 10초

-- 또는 NOWAIT 사용 (MySQL 8.0+)
SELECT * FROM accounts WHERE account_id = 'A001' FOR UPDATE NOWAIT;
-- 락을 즉시 획득하지 못하면 에러 반환
```

### 6.5. 격리 수준 낮추기 (신중히)

```sql
-- 격리 수준을 READ COMMITTED로 낮추면 일부 락이 빨리 해제됨
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 단, Non-Repeatable Read 발생 가능
-- 비즈니스 요구사항 확인 필수
```

---

## 7. 데드락 재시도 로직

애플리케이션에서 데드락 발생 시 **자동 재시도** 구현

### 7.1. 프로시저에서 재시도

```sql
DELIMITER $$

CREATE PROCEDURE transfer_with_deadlock_retry(
    IN from_acc VARCHAR(10),
    IN to_acc VARCHAR(10),
    IN amount DECIMAL(15,2),
    IN max_retries INT,
    OUT result VARCHAR(100)
)
BEGIN
    DECLARE retry_count INT DEFAULT 0;
    DECLARE success BOOLEAN DEFAULT FALSE;
    DECLARE CONTINUE HANDLER FOR 1213  -- Deadlock
    BEGIN
        ROLLBACK;
        SET retry_count = retry_count + 1;
    END;

    retry_loop: WHILE retry_count <= max_retries AND NOT success DO
        START TRANSACTION;

        -- 이체 로직
        UPDATE accounts SET balance = balance - amount WHERE account_id = from_acc;
        UPDATE accounts SET balance = balance + amount WHERE account_id = to_acc;

        COMMIT;
        SET success = TRUE;
        SET result = CONCAT('Success after ', retry_count, ' retries');
    END WHILE retry_loop;

    IF NOT success THEN
        SET result = CONCAT('Failed after ', max_retries, ' retries');
    END IF;
END$$

DELIMITER ;

-- 사용
CALL transfer_with_deadlock_retry('A001', 'B001', 100000, 3, @result);
SELECT @result;
```

### 7.2. 애플리케이션 레벨 재시도 (의사 코드)

```python
# Python 예시
MAX_RETRIES = 3

for attempt in range(MAX_RETRIES):
    try:
        # 트랜잭션 실행
        execute_transaction()
        break  # 성공 시 종료
    except DeadlockException:
        if attempt < MAX_RETRIES - 1:
            time.sleep(0.1 * (attempt + 1))  # 백오프
            continue
        else:
            raise  # 최대 재시도 초과
```

---

## 8. 실습 문제

### 문제 1: 데드락 발생시키기 (난이도: ⭐⭐)

두 세션을 열어 의도적으로 데드락을 발생시키세요.

```sql
-- 세션 1
-- 여기에 SQL 작성

-- 세션 2
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
-- 테이블 준비
CREATE TABLE test_deadlock (
    id VARCHAR(10) PRIMARY KEY,
    value INT
);

INSERT INTO test_deadlock VALUES ('A', 100), ('B', 200);

-- 세션 1
START TRANSACTION;
UPDATE test_deadlock SET value = value + 10 WHERE id = 'A';  -- A 락 획득
-- 잠시 대기 (세션 2가 B에 락 걸 시간 주기)

-- 세션 2 (빠르게 실행)
START TRANSACTION;
UPDATE test_deadlock SET value = value + 10 WHERE id = 'B';  -- B 락 획득

-- 세션 1 (계속)
UPDATE test_deadlock SET value = value + 10 WHERE id = 'B';  -- B 대기...

-- 세션 2 (계속)
UPDATE test_deadlock SET value = value + 10 WHERE id = 'A';  -- A 대기...
-- ERROR 1213: Deadlock found!

-- 정리
DROP TABLE test_deadlock;
```
</details>

---

### 문제 2: 데드락 예방 (난이도: ⭐⭐⭐)

문제 1의 데드락을 락 획득 순서 일관성으로 예방하세요.

<details>
<summary>정답 보기</summary>

```sql
-- 세션 1
START TRANSACTION;
-- 항상 A → B 순서
UPDATE test_deadlock SET value = value + 10 WHERE id = 'A';
UPDATE test_deadlock SET value = value + 10 WHERE id = 'B';
COMMIT;

-- 세션 2
START TRANSACTION;
-- 마찬가지로 A → B 순서 (같은 순서!)
UPDATE test_deadlock SET value = value + 10 WHERE id = 'A';  -- 세션 1 대기
UPDATE test_deadlock SET value = value + 10 WHERE id = 'B';
COMMIT;

-- 데드락 발생 안 함! 순차적으로 실행 ✅
```
</details>

---

### 문제 3: 재시도 로직 구현 (난이도: ⭐⭐⭐⭐)

데드락 발생 시 자동으로 재시도하는 프로시저를 작성하세요.

<details>
<summary>정답 보기</summary>

```sql
DELIMITER $$

CREATE PROCEDURE safe_multi_update(
    IN id1 VARCHAR(10),
    IN id2 VARCHAR(10),
    IN val1 INT,
    IN val2 INT,
    OUT result VARCHAR(100)
)
BEGIN
    DECLARE retry_count INT DEFAULT 0;
    DECLARE max_retries INT DEFAULT 3;
    DECLARE success BOOLEAN DEFAULT FALSE;

    -- 데드락 핸들러
    DECLARE CONTINUE HANDLER FOR 1213
    BEGIN
        ROLLBACK;
        SET retry_count = retry_count + 1;
        SELECT CONCAT('Deadlock detected, retry ', retry_count) AS debug_msg;
    END;

    -- 재시도 루프
    retry_loop: WHILE retry_count <= max_retries AND NOT success DO
        START TRANSACTION;

        -- 항상 같은 순서로 락 획득 (ID 정렬)
        IF id1 < id2 THEN
            UPDATE test_deadlock SET value = val1 WHERE id = id1;
            UPDATE test_deadlock SET value = val2 WHERE id = id2;
        ELSE
            UPDATE test_deadlock SET value = val2 WHERE id = id2;
            UPDATE test_deadlock SET value = val1 WHERE id = id1;
        END IF;

        COMMIT;
        SET success = TRUE;
        SET result = CONCAT('Success after ', retry_count, ' retries');
    END WHILE retry_loop;

    IF NOT success THEN
        SET result = CONCAT('Failed after ', max_retries, ' retries');
    END IF;
END$$

DELIMITER ;

-- 사용
CALL safe_multi_update('A', 'B', 999, 888, @result);
SELECT @result;
```
</details>

---

## 강사 가이드

### 수업 진행 팁

1. **데드락 체험** (20분)
   - 학생들 2인 1조로 세션 실행
   - 의도적으로 데드락 발생시키기
   - 에러 메시지와 롤백 경험

2. **순환 대기 시각화** (10분)
   - 화이트보드에 화살표로 그리기
   - A → B → A 순환 강조
   - "이러면 무한 대기!" 강조

3. **예방 전략 실습** (20분)
   - 락 획득 순서 통일로 데드락 해결
   - 같은 코드인데 순서만 바꿔서 해결되는 것 시연
   - "간단하지만 효과적!" 강조

4. **실무 패턴** (15분)
   - 재시도 로직 구현
   - 백오프(Backoff) 전략
   - 로깅의 중요성

5. **데드락 정보 확인** (10분)
   - SHOW ENGINE INNODB STATUS 실행
   - Deadlock 섹션 해석
   - 어떤 트랜잭션이 희생자인지 확인

### 자주 하는 질문

**Q1: 데드락은 완전히 예방할 수 있나요?**
> A: 완전한 예방은 어렵지만, 락 획득 순서 일관성 유지로 대부분 예방 가능합니다. 복잡한 시스템에서는 드물게 발생할 수 있으므로 재시도 로직 구현이 중요합니다.

**Q2: MySQL은 데드락을 자동으로 해결하는데 왜 예방이 필요한가요?**
> A: 자동 해결은 하나의 트랜잭션을 강제 롤백하는 것입니다. 롤백된 트랜잭션은 실패하고, 재시도가 필요합니다. 빈번한 데드락은 성능 저하를 일으키므로 예방이 중요합니다.

**Q3: 데드락과 락 타임아웃의 차이는?**
> A:
> - **데드락**: 순환 대기로 영원히 진행 못 함 → MySQL이 감지하여 즉시 롤백
> - **락 타임아웃**: 단순 대기 → 설정된 시간 후 타임아웃

**Q4: 어떤 트랜잭션이 롤백되나요?**
> A: MySQL은 Undo 로그가 적은 트랜잭션(롤백 비용이 낮음)을 선택하여 롤백합니다.

**Q5: 데드락이 자주 발생하면 어떻게 해야 하나요?**
> A:
> 1. SHOW ENGINE INNODB STATUS로 패턴 분석
> 2. 락 획득 순서 검토
> 3. 트랜잭션 길이 단축
> 4. 인덱스 최적화
> 5. 격리 수준 조정 (신중히)

---

## 요약

### 핵심 개념

**데드락 = 순환 대기로 인한 교착 상태**

### 발생 조건 (4가지 모두 필요)

1. 상호 배제
2. 점유와 대기
3. 비선점
4. **순환 대기** ← 주로 이것을 깨뜨림

### 예방 전략

1. **락 획득 순서 일관성 유지** (가장 효과적)
2. 트랜잭션 짧게 유지
3. 인덱스 사용
4. 락 타임아웃 설정
5. 격리 수준 조정 (신중히)

### 대응 전략

1. 자동 탐지 및 롤백 (MySQL 자동)
2. **재시도 로직** (애플리케이션)
3. 로깅 및 모니터링

### 명령어

```sql
-- 데드락 정보 확인
SHOW ENGINE INNODB STATUS\G

-- 락 타임아웃 설정
SET innodb_lock_wait_timeout = 10;

-- NOWAIT 사용 (MySQL 8.0+)
SELECT * FROM ... FOR UPDATE NOWAIT;
```

### 다음 단계

다음 시간에는 **5장 종합 실습**을 진행합니다:
- 트랜잭션, ACID, 격리 수준, 락, 데드락을 종합 활용
- 실무 시나리오 기반 문제 해결
- 동시성 제어 종합 프로젝트

---

**연습 권장사항:**
- 의도적으로 데드락 발생시켜보기
- 락 획득 순서 변경으로 예방 확인
- SHOW ENGINE INNODB STATUS 분석 연습
- 재시도 로직 직접 구현해보기
