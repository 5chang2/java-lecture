# 5.2. ACID 속성

## 학습 목표
- ACID 속성의 의미를 이해한다
- 각 속성(원자성, 일관성, 격리성, 지속성)의 개념을 학습한다
- 실제 예제를 통해 ACID 속성이 보장되는 것을 확인한다
- ACID 위반 시 발생하는 문제를 이해한다

---

## 1. ACID란?

**ACID**는 트랜잭션이 안전하게 수행되기 위해 보장해야 하는 **4가지 핵심 속성**입니다.

| 속성 | 영문 | 의미 |
|-----|------|------|
| **A** | Atomicity | 원자성 - All or Nothing |
| **C** | Consistency | 일관성 - 규칙 준수 |
| **I** | Isolation | 격리성 - 독립 실행 |
| **D** | Durability | 지속성 - 영구 보존 |

```
ACID는 신뢰할 수 있는 트랜잭션 시스템의 필수 조건입니다.
이 4가지가 모두 보장되어야 데이터베이스가 안전합니다!
```

---

## 2. Atomicity (원자성)

### 2.1. 개념

**"All or Nothing"** - 트랜잭션의 모든 작업이 **완전히 성공하거나 완전히 실패**해야 합니다. 부분적인 성공은 없습니다.

```
원자(Atom): 더 이상 나눌 수 없는 최소 단위
트랜잭션도 마찬가지로 나눌 수 없는 하나의 단위로 동작
```

### 2.2. 실생활 비유

```
온라인 쇼핑 주문:

1. 재고 감소
2. 주문 기록
3. 결제 처리
4. 배송 정보 등록

→ 이 중 하나라도 실패하면 전체 취소!
→ 재고만 감소하고 결제 실패하면 안 됨
```

### 2.3. MySQL에서의 구현

```sql
-- 계좌 이체 예제
START TRANSACTION;

-- 출금 (A 계좌)
UPDATE accounts SET balance = balance - 100000 WHERE account_id = 'A001';

-- 시스템 오류 발생 시뮬레이션
-- 입금 (B 계좌) - 실패했다고 가정
-- UPDATE accounts SET balance = balance + 100000 WHERE account_id = 'B001';

-- 문제 발생! 롤백으로 모든 작업 취소
ROLLBACK;

-- 결과: 출금도 취소됨 → 원자성 보장 ✅
```

### 2.4. 원자성 위반 시 문제

```sql
-- 트랜잭션 없이 실행 (원자성 보장 안 됨)
UPDATE accounts SET balance = balance - 100000 WHERE account_id = 'A001';
-- 여기서 시스템 장애! 💥

-- 문제: A 계좌에서만 돈이 빠져나감
-- B 계좌에는 돈이 들어가지 않음
-- 데이터 불일치 발생! ❌
```

---

## 3. Consistency (일관성)

### 3.1. 개념

트랜잭션 실행 **전후로 데이터베이스가 일관된 상태를 유지**해야 합니다. 모든 **무결성 제약조건**(constraints)이 지켜져야 합니다.

```
일관성 = 데이터베이스의 규칙(제약조건)이 항상 지켜지는 상태
```

### 3.2. 무결성 제약조건 예시

```sql
CREATE TABLE accounts (
    account_id VARCHAR(10) PRIMARY KEY,
    owner_name VARCHAR(50) NOT NULL,
    balance DECIMAL(15, 2) NOT NULL CHECK (balance >= 0),  -- 잔액은 0 이상
    account_type ENUM('savings', 'checking') NOT NULL
);

-- 제약조건:
-- 1. account_id는 고유해야 함 (PRIMARY KEY)
-- 2. owner_name은 NULL이 아니어야 함 (NOT NULL)
-- 3. balance는 0 이상이어야 함 (CHECK)
-- 4. account_type은 정해진 값만 가능 (ENUM)
```

### 3.3. 일관성 보장 예제

```sql
-- 계좌 잔액이 충분한지 확인하는 트랜잭션
START TRANSACTION;

-- 현재 잔액 확인
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 50,000원

-- 100,000원 출금 시도
UPDATE accounts SET balance = balance - 100000 WHERE account_id = 'A001';
-- CHECK 제약조건 위반! (balance < 0)
-- ERROR: Check constraint violated

-- 자동 롤백됨
-- 결과: 일관성 유지 ✅
```

### 3.4. 비즈니스 규칙 일관성

제약조건뿐만 아니라 **비즈니스 규칙**도 유지되어야 합니다.

```sql
-- 비즈니스 규칙: "전체 계좌의 잔액 합은 변하지 않아야 함"
SELECT SUM(balance) FROM accounts;  -- 이체 전: 1,500,000

START TRANSACTION;

-- A → B 이체
UPDATE accounts SET balance = balance - 100000 WHERE account_id = 'A001';
UPDATE accounts SET balance = balance + 100000 WHERE account_id = 'B001';

COMMIT;

SELECT SUM(balance) FROM accounts;  -- 이체 후: 1,500,000 (변화 없음) ✅
```

---

## 4. Isolation (격리성)

### 4.1. 개념

**동시에 실행되는 여러 트랜잭션이 서로 간섭하지 않고 독립적으로** 실행되는 것처럼 보여야 합니다.

```
여러 사용자가 동시에 데이터베이스를 사용해도
각자 혼자 사용하는 것처럼 느껴져야 함
```

### 4.2. 실생활 비유

```
은행 ATM:

사용자 A와 B가 동시에 같은 계좌에서 출금

격리성이 없으면:
- A: 잔액 100만원 확인
- B: 잔액 100만원 확인 (동시에)
- A: 50만원 출금 (잔액 50만원)
- B: 50만원 출금 (잔액... 음수?!) ❌

격리성이 있으면:
- A: 트랜잭션 시작 → 출금 완료
- B: A가 끝날 때까지 대기 → 이후 출금 ✅
```

### 4.3. 격리 수준 (Isolation Level)

격리성의 정도를 조절할 수 있습니다 (자세한 내용은 5.4에서 학습):

| 격리 수준 | 설명 | 성능 | 일관성 |
|----------|------|------|-------|
| READ UNCOMMITTED | 커밋 안 된 데이터도 읽기 | 높음 | 낮음 |
| READ COMMITTED | 커밋된 데이터만 읽기 | 중간 | 중간 |
| REPEATABLE READ | 반복 읽기 일관성 보장 (MySQL 기본) | 중간 | 높음 |
| SERIALIZABLE | 완전 격리 (순차 실행처럼) | 낮음 | 최고 |

### 4.4. 격리성 실습

**두 개의 MySQL 클라이언트 창을 열어 실습하세요.**

#### 세션 1 (사용자 A):
```sql
START TRANSACTION;

-- 계좌 A에서 출금
UPDATE accounts SET balance = balance - 50000 WHERE account_id = 'A001';

-- 아직 COMMIT 안 함! (다른 세션에서는 변경사항 안 보임)
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 예: 950,000
```

#### 세션 2 (사용자 B - 동시에):
```sql
-- 사용자 A가 COMMIT하기 전
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 예: 1,000,000 (원래 값)

-- 격리성 덕분에 A의 변경사항이 보이지 않음! ✅
```

#### 세션 1 (계속):
```sql
COMMIT;  -- 확정
```

#### 세션 2 (다시):
```sql
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 950,000 (이제 보임)
```

---

## 5. Durability (지속성)

### 5.1. 개념

트랜잭션이 **성공적으로 COMMIT되면, 그 결과는 영구적으로 보존**되어야 합니다. 시스템 장애가 발생해도 데이터는 손실되지 않습니다.

```
COMMIT = "이제 안전합니다. 절대 사라지지 않습니다."
```

### 5.2. 실생활 비유

```
문서 저장:

트랜잭션 없이:
- 문서 작성 중
- 정전 발생! 💥
- 모든 내용 사라짐 ❌

트랜잭션 (COMMIT) 후:
- 문서 작성 완료
- "저장" 클릭 (= COMMIT)
- 정전 발생해도 복구됨 ✅
```

### 5.3. MySQL에서의 구현

MySQL은 **WAL (Write-Ahead Logging)** 방식으로 지속성을 보장합니다.

```
COMMIT 시:
1. 변경사항을 로그 파일에 먼저 기록 (redo log)
2. 로그 기록 완료 후 COMMIT 성공 응답
3. 나중에 실제 데이터 파일에 반영

시스템 장애 발생 시:
1. 로그 파일 읽기
2. COMMIT된 트랜잭션 재실행 (redo)
3. COMMIT 안 된 트랜잭션 취소 (undo)
```

### 5.4. 지속성 실습

```sql
-- 트랜잭션 실행 및 COMMIT
START TRANSACTION;

INSERT INTO accounts VALUES ('C001', 'Charlie', 500000.00, 'savings');

COMMIT;  -- 이 시점에 영구 저장됨

-- MySQL 재시작해도 데이터 유지됨 ✅
SELECT * FROM accounts WHERE account_id = 'C001';  -- 여전히 존재
```

### 5.5. 지속성 vs 백업

```
지속성 (Durability):
- 시스템 장애(정전, 프로세스 종료)에서 보호
- 트랜잭션 로그로 복구

백업 (Backup):
- 물리적 손상(디스크 파손, 화재)에서 보호
- 별도 저장소에 전체 데이터 복사

→ 둘 다 필요합니다!
```

---

## 6. ACID 속성 종합 예제

계좌 이체를 통해 ACID 4가지 속성을 모두 확인해봅시다.

```sql
-- 초기 설정
CREATE TABLE accounts (
    account_id VARCHAR(10) PRIMARY KEY,
    owner_name VARCHAR(50) NOT NULL,
    balance DECIMAL(15, 2) NOT NULL CHECK (balance >= 0),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO accounts (account_id, owner_name, balance) VALUES
('A001', 'Alice', 1000000.00),
('B001', 'Bob', 500000.00);

-- 초기 상태
SELECT * FROM accounts;
SELECT SUM(balance) AS total FROM accounts;  -- 1,500,000
```

### 계좌 이체 트랜잭션

```sql
START TRANSACTION;

-- 1. 출금 (A → B로 200,000원 이체)
UPDATE accounts SET balance = balance - 200000 WHERE account_id = 'A001';

-- 2. 입금
UPDATE accounts SET balance = balance + 200000 WHERE account_id = 'B001';

-- 중간 확인
SELECT * FROM accounts;
SELECT SUM(balance) AS total FROM accounts;  -- 여전히 1,500,000

COMMIT;

-- 최종 확인
SELECT * FROM accounts;
/*
A001: 800,000
B001: 700,000
Total: 1,500,000
*/
```

**ACID 속성 확인:**

✅ **Atomicity**: 두 UPDATE 모두 성공 또는 모두 실패 (부분 성공 없음)
✅ **Consistency**: CHECK 제약조건 만족 (balance >= 0), 총액 불변
✅ **Isolation**: 다른 세션에서는 COMMIT 전까지 변경사항 안 보임
✅ **Durability**: COMMIT 후 시스템 재시작해도 데이터 유지

---

## 7. ACID 위반 시 발생하는 문제들

### 7.1. 원자성 위반: Lost Update (갱신 손실)

```sql
-- 트랜잭션 없이 실행
UPDATE accounts SET balance = balance - 100000 WHERE account_id = 'A001';
-- 시스템 장애! 두 번째 UPDATE 실행 안 됨
-- UPDATE accounts SET balance = balance + 100000 WHERE account_id = 'B001';

-- 결과: A 계좌에서만 돈이 빠짐 (100,000원 손실)
```

### 7.2. 일관성 위반: Invalid State (무효 상태)

```sql
-- 제약조건 무시
UPDATE accounts SET balance = -500000 WHERE account_id = 'A001';
-- 음수 잔액 허용 시 일관성 위반

-- 비즈니스 규칙 위반
-- 총액이 변하지 않아야 하는데...
UPDATE accounts SET balance = balance - 100000 WHERE account_id = 'A001';
-- B 계좌에 입금 안 함 → 총액 감소 (일관성 위반)
```

### 7.3. 격리성 위반: Dirty Read (더티 리드)

```sql
-- 세션 1
START TRANSACTION;
UPDATE accounts SET balance = 999999 WHERE account_id = 'A001';
-- COMMIT 안 함

-- 세션 2 (격리 수준이 READ UNCOMMITTED인 경우)
SELECT balance FROM accounts WHERE account_id = 'A001';  -- 999999 (커밋 안 된 데이터!)

-- 세션 1
ROLLBACK;  -- 취소!

-- 세션 2는 존재하지 않는 데이터를 읽음 (문제!)
```

### 7.4. 지속성 위반: Data Loss (데이터 손실)

```sql
-- COMMIT 했지만 로그에 기록되기 전에 시스템 장애
INSERT INTO accounts VALUES ('D001', 'David', 1000000, 'savings');
COMMIT;  -- 응답 받음

-- 그러나 디스크에 기록되기 전에 정전...
-- 재시작 후 데이터 없음 (지속성 위반)
```

---

## 8. 실습 문제

### 문제 1: ACID 속성 식별 (난이도: ⭐⭐)

다음 시나리오에서 어떤 ACID 속성이 보장되는지 식별하세요.

**시나리오:**
```sql
START TRANSACTION;

-- 상품 재고 감소
UPDATE products SET stock = stock - 1 WHERE product_id = 101;

-- 주문 생성
INSERT INTO orders (product_id, quantity, customer_id)
VALUES (101, 1, 5001);

COMMIT;
```

**질문:**
1. 재고 감소와 주문 생성이 함께 성공하거나 실패하는 것은? → ______
2. 다른 고객이 COMMIT 전에는 변경사항을 볼 수 없는 것은? → ______
3. COMMIT 후 시스템 장애가 발생해도 데이터가 유지되는 것은? → ______
4. 재고가 음수가 되지 않도록 제약조건이 지켜지는 것은? → ______

<details>
<summary>정답 보기</summary>

1. **Atomicity (원자성)** - All or Nothing
2. **Isolation (격리성)** - 트랜잭션 간 독립성
3. **Durability (지속성)** - 영구 보존
4. **Consistency (일관성)** - 제약조건 준수
</details>

---

### 문제 2: 원자성 테스트 (난이도: ⭐⭐)

sakila 데이터베이스에서 다음 작업을 수행하고 ROLLBACK하세요:
1. 특정 고객의 이메일 변경
2. 해당 고객의 주소 변경
3. ROLLBACK 후 변경사항이 모두 취소되었는지 확인

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
-- 원래 데이터 확인
SELECT c.customer_id, c.email, a.address
FROM customer c
JOIN address a ON c.address_id = a.address_id
WHERE c.customer_id = 1;

-- 트랜잭션 시작
START TRANSACTION;

-- 1. 이메일 변경
UPDATE customer SET email = 'newemail@test.com' WHERE customer_id = 1;

-- 2. 주소 변경
UPDATE address SET address = 'New Address 999'
WHERE address_id = (SELECT address_id FROM customer WHERE customer_id = 1);

-- 변경 확인
SELECT c.customer_id, c.email, a.address
FROM customer c
JOIN address a ON c.address_id = a.address_id
WHERE c.customer_id = 1;

-- ROLLBACK
ROLLBACK;

-- 원래대로 복구 확인 (원자성 보장!)
SELECT c.customer_id, c.email, a.address
FROM customer c
JOIN address a ON c.address_id = a.address_id
WHERE c.customer_id = 1;
```
</details>

---

### 문제 3: 일관성 테스트 (난이도: ⭐⭐⭐)

계좌 이체 시나리오에서 일관성이 유지되는지 확인하세요.

**조건:**
- 총 계좌 잔액은 이체 전후가 동일해야 함
- 각 계좌의 잔액은 0 이상이어야 함

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
-- 테스트 테이블 생성
CREATE TABLE test_accounts (
    account_id VARCHAR(10) PRIMARY KEY,
    balance DECIMAL(15, 2) NOT NULL CHECK (balance >= 0)
);

INSERT INTO test_accounts VALUES
('A001', 1000000),
('B001', 500000);

-- 이체 전 총액 확인
SELECT SUM(balance) AS total_before FROM test_accounts;  -- 1,500,000

-- 정상 이체
START TRANSACTION;
UPDATE test_accounts SET balance = balance - 100000 WHERE account_id = 'A001';
UPDATE test_accounts SET balance = balance + 100000 WHERE account_id = 'B001';
COMMIT;

-- 이체 후 총액 확인 (일관성 유지!)
SELECT SUM(balance) AS total_after FROM test_accounts;  -- 1,500,000

-- 잔액 부족 시나리오
START TRANSACTION;
UPDATE test_accounts SET balance = balance - 2000000 WHERE account_id = 'A001';
-- CHECK 제약조건 위반으로 오류 발생
-- ERROR 1264: Out of range value for column 'balance'
ROLLBACK;

-- 일관성 유지 확인
SELECT * FROM test_accounts;  -- 변경사항 없음

-- 정리
DROP TABLE test_accounts;
```
</details>

---

## 강사 가이드

### 수업 진행 팁

1. **ACID 약어 먼저 외우기** (5분)
   - "에이씨아이디"라고 소리 내어 반복
   - 각 알파벳의 의미를 손가락으로 세며 암기
   - 실생활 비유로 각 개념 설명

2. **원자성부터 순차적으로** (각 10분)
   - 한 번에 하나씩 집중 설명
   - 실습 예제로 직접 확인
   - "이게 없으면 어떤 문제가 생기는가?" 강조

3. **두 세션 동시 실습** (15분)
   - 격리성 실습 시 필수
   - 학생들 2인 1조로 각자 세션 열기
   - 서로의 트랜잭션이 어떻게 보이는지 확인

4. **ACID 위반 사례 시연** (15분)
   - 실제로 문제를 만들어보기
   - "이래서 ACID가 중요합니다" 강조
   - 실무에서 자주 발생하는 사례 공유

5. **종합 예제로 마무리** (10분)
   - 하나의 트랜잭션에서 ACID 4가지 모두 확인
   - 학생들이 직접 식별하도록 질문

### 자주 하는 질문

**Q1: ACID가 모두 보장되면 성능이 떨어지나요?**
> A: 네, 트레이드오프가 있습니다. 특히 격리성(I)과 지속성(D)은 성능에 영향을 줍니다. 그래서 격리 수준을 조절하거나, 중요하지 않은 데이터는 완화된 설정을 사용합니다.

**Q2: NoSQL은 ACID를 보장하지 않나요?**
> A: 전통적으로 NoSQL은 확장성을 위해 ACID를 희생했습니다(BASE 모델). 하지만 최근 MongoDB 등은 트랜잭션을 지원하여 ACID를 보장하기도 합니다.

**Q3: READ UNCOMMITTED를 사용하면 안 되나요?**
> A: 대부분의 경우 사용하지 않습니다. Dirty Read가 발생하여 잘못된 데이터를 읽을 수 있습니다. 특수한 경우(실시간 통계, 로그 분석 등)에만 사용합니다.

**Q4: Consistency는 누가 보장하나요?**
> A: 데이터베이스와 애플리케이션이 함께 보장합니다.
> - 데이터베이스: 제약조건(PK, FK, CHECK 등)
> - 애플리케이션: 비즈니스 규칙

**Q5: Durability는 100% 보장되나요?**
> A: 거의 100%지만 절대적이지는 않습니다. 디스크가 물리적으로 파손되면 데이터가 손실될 수 있습니다. 그래서 백업과 복제(Replication)가 필요합니다.

### 실습 중 흔한 오해

1. **"COMMIT만 하면 ACID가 보장된다"**
   - X: 제약조건, 격리 수준 설정 등도 필요

2. **"격리성 = 완전 독립 실행"**
   - X: 격리 수준에 따라 다름, SERIALIZABLE만 완전 격리

3. **"Durability = 백업"**
   - X: 다른 개념, 둘 다 필요

---

## 요약

### 핵심 개념

**ACID는 트랜잭션의 4가지 필수 속성**

1. **Atomicity (원자성)**
   - All or Nothing
   - 부분 성공 없음
   - COMMIT 또는 ROLLBACK

2. **Consistency (일관성)**
   - 제약조건 준수
   - 비즈니스 규칙 유지
   - 트랜잭션 전후 일관된 상태

3. **Isolation (격리성)**
   - 트랜잭션 간 독립성
   - 동시 실행 시 간섭 방지
   - 격리 수준으로 조절 가능

4. **Durability (지속성)**
   - COMMIT 후 영구 보존
   - 시스템 장애에도 복구
   - WAL(Write-Ahead Logging)로 구현

### 다음 단계

다음 시간에는 **COMMIT과 ROLLBACK**을 자세히 학습합니다:
- COMMIT의 동작 원리
- ROLLBACK의 활용
- SAVEPOINT로 부분 롤백
- 자동 커밋 모드 제어

---

**연습 권장사항:**
- 각 ACID 속성을 직접 위반해보고 문제 확인
- 두 세션으로 격리성 테스트 반복
- 계좌 이체 예제로 4가지 속성 모두 확인
- 실무에서 ACID가 중요한 사례 찾아보기
