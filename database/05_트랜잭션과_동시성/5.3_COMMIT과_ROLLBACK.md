# 5.3. COMMIT과 ROLLBACK

## 학습 목표
- COMMIT의 동작 원리와 사용법을 이해한다
- ROLLBACK의 동작 원리와 활용 방법을 학습한다
- SAVEPOINT를 사용한 부분 롤백을 익힌다
- 자동 커밋 모드를 제어하는 방법을 학습한다

---

## 1. COMMIT이란?

**COMMIT**은 트랜잭션의 모든 변경사항을 **영구적으로 확정(저장)**하는 명령입니다.

```
COMMIT = "확정"
- 모든 변경사항이 데이터베이스에 영구 저장됨
- 다른 사용자들도 변경사항을 볼 수 있음
- 더 이상 ROLLBACK 불가능
```

### 1.1. COMMIT 전후 비교

```sql
-- COMMIT 전 상태
START TRANSACTION;
INSERT INTO city VALUES (5001, 'Test City', 'KOR', 'Test', 10000);
-- 현재 세션에서만 보임
-- 다른 세션에서는 안 보임
-- ROLLBACK 가능

-- COMMIT 실행
COMMIT;

-- COMMIT 후 상태
-- 모든 세션에서 보임
-- 영구적으로 저장됨
-- ROLLBACK 불가능
```

---

## 2. ROLLBACK이란?

**ROLLBACK**은 트랜잭션의 모든 변경사항을 **취소하고 원래 상태로 되돌리는** 명령입니다.

```
ROLLBACK = "취소"
- 트랜잭션 시작 시점으로 복원
- 모든 변경사항이 없었던 것처럼 됨
- 데이터 일관성 유지
```

### 2.1. ROLLBACK 전후 비교

```sql
-- 원본 데이터
SELECT COUNT(*) FROM city WHERE CountryCode = 'KOR';  -- 예: 70개

-- 트랜잭션 시작 및 변경
START TRANSACTION;
DELETE FROM city WHERE CountryCode = 'KOR';
SELECT COUNT(*) FROM city WHERE CountryCode = 'KOR';  -- 0개

-- ROLLBACK 실행
ROLLBACK;

-- 원래대로 복원됨!
SELECT COUNT(*) FROM city WHERE CountryCode = 'KOR';  -- 70개
```

---

## 3. COMMIT의 동작 원리

### 3.1. COMMIT 처리 과정

```
1. 트랜잭션 변경사항을 로그에 기록 (Redo Log)
2. 로그를 디스크에 기록 (flush)
3. 트랜잭션 상태를 "COMMITTED"로 변경
4. 락(Lock) 해제
5. 다른 트랜잭션에 변경사항 가시화
```

### 3.2. COMMIT 예제

```sql
-- 계좌 이체 트랜잭션
CREATE TABLE accounts (
    account_id VARCHAR(10) PRIMARY KEY,
    balance DECIMAL(15, 2)
);

INSERT INTO accounts VALUES ('A001', 1000000), ('B001', 500000);

-- 트랜잭션 시작
START TRANSACTION;

-- 변경 작업
UPDATE accounts SET balance = balance - 100000 WHERE account_id = 'A001';
UPDATE accounts SET balance = balance + 100000 WHERE account_id = 'B001';

-- 중간 확인 (현재 세션에서만 보임)
SELECT * FROM accounts;
/*
A001: 900,000
B001: 600,000
*/

-- COMMIT - 영구 확정
COMMIT;

-- 이제 모든 세션에서 확인 가능
SELECT * FROM accounts;
```

### 3.3. COMMIT과 WAL (Write-Ahead Logging)

MySQL은 **WAL 방식**으로 COMMIT을 처리합니다.

```
WAL 원칙: 데이터를 변경하기 전에 로그를 먼저 기록

장점:
- 디스크 I/O 효율적 (로그는 순차 쓰기)
- 시스템 장애 시 복구 가능
- COMMIT 응답 속도 향상
```

```
COMMIT 시:
┌─────────────────┐
│ 1. 로그에 기록   │ → Redo Log (빠름)
└─────────────────┘
         ↓
┌─────────────────┐
│ 2. 로그 동기화   │ → fsync() (디스크에 확실히 기록)
└─────────────────┘
         ↓
┌─────────────────┐
│ 3. COMMIT 완료  │ → 사용자에게 응답
└─────────────────┘
         ↓
┌─────────────────┐
│ 4. 데이터 파일   │ → 나중에 반영 (Checkpoint)
└─────────────────┘
```

---

## 4. ROLLBACK의 동작 원리

### 4.1. ROLLBACK 처리 과정

```
1. Undo Log에서 이전 상태 읽기
2. 변경사항을 역순으로 취소
3. 트랜잭션 상태를 "ABORTED"로 변경
4. 락(Lock) 해제
5. 트랜잭션 시작 전 상태로 복원
```

### 4.2. ROLLBACK 예제

```sql
-- 실수로 데이터 삭제
START TRANSACTION;

-- 모든 계좌 삭제 (실수!)
DELETE FROM accounts;

-- 확인 (비어있음!)
SELECT COUNT(*) FROM accounts;  -- 0개

-- 당황하지 말고 ROLLBACK
ROLLBACK;

-- 복구됨!
SELECT COUNT(*) FROM accounts;  -- 원래 개수
SELECT * FROM accounts;  -- 모든 데이터 복원
```

### 4.3. Undo Log 이해

```sql
-- Undo Log 동작 시뮬레이션

START TRANSACTION;

-- 작업 1: INSERT
INSERT INTO accounts VALUES ('C001', 300000);
-- Undo Log: DELETE FROM accounts WHERE account_id = 'C001'

-- 작업 2: UPDATE
UPDATE accounts SET balance = balance + 50000 WHERE account_id = 'A001';
-- Undo Log: UPDATE accounts SET balance = balance - 50000 WHERE account_id = 'A001'

-- 작업 3: DELETE
DELETE FROM accounts WHERE account_id = 'B001';
-- Undo Log: INSERT INTO accounts VALUES ('B001', 600000)

ROLLBACK;

-- Undo Log를 역순으로 실행:
-- 3. INSERT INTO accounts VALUES ('B001', 600000)
-- 2. UPDATE accounts SET balance = balance - 50000 WHERE account_id = 'A001'
-- 1. DELETE FROM accounts WHERE account_id = 'C001'
```

---

## 5. SAVEPOINT (세이브포인트)

**SAVEPOINT**는 트랜잭션 내에서 **부분 롤백 지점**을 만드는 기능입니다.

### 5.1. SAVEPOINT 사용법

```sql
START TRANSACTION;

-- 작업 1
INSERT INTO city VALUES (5001, 'City A', 'KOR', 'District A', 10000);

-- 체크포인트 1
SAVEPOINT sp1;

-- 작업 2
INSERT INTO city VALUES (5002, 'City B', 'KOR', 'District B', 20000);

-- 체크포인트 2
SAVEPOINT sp2;

-- 작업 3
INSERT INTO city VALUES (5003, 'City C', 'KOR', 'District C', 30000);

-- sp2까지만 롤백 (작업 3만 취소, 1,2는 유지)
ROLLBACK TO SAVEPOINT sp2;

-- 확인
SELECT * FROM city WHERE ID >= 5001;  -- City A, B만 있음

-- 최종 확정
COMMIT;
```

### 5.2. SAVEPOINT 실무 활용

**시나리오: 대량 데이터 처리 중 일부만 롤백**

```sql
START TRANSACTION;

-- 100개 레코드 처리 시작
-- ...
-- 50개까지 처리 완료
SAVEPOINT batch_50;

-- 51번째에서 오류 발생
-- ERROR: Duplicate entry

-- 51번째부터만 롤백, 50개는 유지
ROLLBACK TO SAVEPOINT batch_50;

-- 오류 수정 후 재시도
-- ...

COMMIT;
```

### 5.3. SAVEPOINT 삭제

```sql
START TRANSACTION;

SAVEPOINT sp1;
-- 작업...

-- SAVEPOINT 삭제 (메모리 절약)
RELEASE SAVEPOINT sp1;

-- 이제 sp1로 롤백 불가능
-- ROLLBACK TO SAVEPOINT sp1;  -- 에러!

COMMIT;
```

---

## 6. 자동 커밋 모드 (Autocommit)

### 6.1. 자동 커밋이란?

MySQL은 기본적으로 **각 SQL 문을 자동으로 COMMIT**합니다.

```sql
-- 자동 커밋 상태 확인
SELECT @@autocommit;  -- 1 (활성화)

-- 자동 커밋 모드에서는
INSERT INTO city VALUES (5001, 'City X', 'KOR', 'District X', 10000);
-- 자동으로 COMMIT됨 (즉시 영구 저장)
```

### 6.2. 자동 커밋 비활성화

```sql
-- 자동 커밋 비활성화
SET autocommit = 0;

-- 이제 명시적으로 COMMIT 또는 ROLLBACK 필요
INSERT INTO city VALUES (5002, 'City Y', 'KOR', 'District Y', 20000);
-- 아직 확정 안 됨

SELECT * FROM city WHERE ID = 5002;  -- 현재 세션에서만 보임

COMMIT;  -- 이제 확정됨

-- 자동 커밋 재활성화
SET autocommit = 1;
```

### 6.3. 자동 커밋 vs 명시적 트랜잭션

```sql
-- 방법 1: 자동 커밋 OFF
SET autocommit = 0;
INSERT INTO accounts VALUES ('D001', 100000);
UPDATE accounts SET balance = balance + 10000 WHERE account_id = 'A001';
COMMIT;

-- 방법 2: 명시적 트랜잭션 (권장)
-- autocommit 상태와 무관하게 동작
START TRANSACTION;
INSERT INTO accounts VALUES ('D001', 100000);
UPDATE accounts SET balance = balance + 10000 WHERE account_id = 'A001';
COMMIT;
```

**권장사항:** `SET autocommit = 0` 보다는 `START TRANSACTION`을 사용하세요.
- 의도가 명확함
- autocommit 설정에 영향받지 않음
- 코드 가독성 향상

---

## 7. COMMIT과 ROLLBACK 사용 패턴

### 7.1. 안전한 데이터 수정 패턴

```sql
-- ✅ 좋은 패턴
START TRANSACTION;

-- 1. 변경 전 데이터 확인
SELECT * FROM accounts WHERE account_id = 'A001';

-- 2. 변경 실행
UPDATE accounts SET balance = balance - 100000 WHERE account_id = 'A001';

-- 3. 변경 후 데이터 확인
SELECT * FROM accounts WHERE account_id = 'A001';

-- 4. 문제없으면 COMMIT, 문제 있으면 ROLLBACK
COMMIT;
-- 또는 ROLLBACK;
```

### 7.2. 조건부 COMMIT/ROLLBACK

```sql
-- 저장 프로시저에서의 패턴
DELIMITER $$

CREATE PROCEDURE transfer_money(
    IN from_account VARCHAR(10),
    IN to_account VARCHAR(10),
    IN amount DECIMAL(15,2),
    OUT result VARCHAR(50)
)
BEGIN
    DECLARE current_balance DECIMAL(15,2);

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET result = 'Transfer failed - rolled back';
    END;

    START TRANSACTION;

    -- 잔액 확인
    SELECT balance INTO current_balance
    FROM accounts
    WHERE account_id = from_account;

    -- 조건 확인
    IF current_balance < amount THEN
        ROLLBACK;
        SET result = 'Insufficient balance';
    ELSE
        -- 이체 실행
        UPDATE accounts SET balance = balance - amount WHERE account_id = from_account;
        UPDATE accounts SET balance = balance + amount WHERE account_id = to_account;
        COMMIT;
        SET result = 'Transfer successful';
    END IF;
END$$

DELIMITER ;

-- 사용
CALL transfer_money('A001', 'B001', 50000, @result);
SELECT @result;
```

### 7.3. 대량 처리 시 배치 COMMIT

```sql
-- ❌ 나쁜 예: 모든 작업을 하나의 트랜잭션으로
START TRANSACTION;
-- 10만 건 INSERT... (메모리 부족, 락 대기 발생)
COMMIT;

-- ✅ 좋은 예: 배치 단위로 COMMIT
SET @batch_size = 1000;
SET @counter = 0;

START TRANSACTION;

-- 반복 (의사 코드)
WHILE counter < 100000 DO
    INSERT INTO ...;
    SET @counter = @counter + 1;

    IF @counter % @batch_size = 0 THEN
        COMMIT;
        START TRANSACTION;
    END IF;
END WHILE;

COMMIT;
```

---

## 8. 실습 문제

### 문제 1: COMMIT 기본 (난이도: ⭐)

sakila 데이터베이스에서 새로운 배우를 추가하고 COMMIT하세요.

**요구사항:**
- 배우 이름: Test Actor
- COMMIT 전후로 데이터 확인

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
-- 현재 배우 수
SELECT COUNT(*) FROM actor;

-- 트랜잭션 시작
START TRANSACTION;

-- 배우 추가
INSERT INTO actor (first_name, last_name)
VALUES ('Test', 'Actor');

-- COMMIT 전 확인
SELECT * FROM actor WHERE first_name = 'Test';

-- COMMIT
COMMIT;

-- COMMIT 후 확인 (다른 세션에서도 보임)
SELECT * FROM actor WHERE first_name = 'Test';

-- 정리
DELETE FROM actor WHERE first_name = 'Test';
```
</details>

---

### 문제 2: ROLLBACK 활용 (난이도: ⭐⭐)

실수로 모든 customer를 삭제했다가 ROLLBACK으로 복구하세요.

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
-- 원래 고객 수 확인
SELECT COUNT(*) FROM customer;  -- 예: 599명

-- 트랜잭션 시작
START TRANSACTION;

-- 실수로 모든 고객 삭제!
DELETE FROM customer;

-- 확인 (비어있음!)
SELECT COUNT(*) FROM customer;  -- 0명

-- 당황하지 말고 ROLLBACK
ROLLBACK;

-- 복구 확인
SELECT COUNT(*) FROM customer;  -- 599명 (복구됨!)
```
</details>

---

### 문제 3: SAVEPOINT 활용 (난이도: ⭐⭐⭐)

3개의 영화 데이터를 추가하되, 마지막 영화만 롤백하세요.

**요구사항:**
1. 영화 A 추가 → SAVEPOINT sp1
2. 영화 B 추가 → SAVEPOINT sp2
3. 영화 C 추가
4. sp2로 ROLLBACK (C만 취소)
5. COMMIT (A, B만 확정)

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
START TRANSACTION;

-- 1. 영화 A 추가
INSERT INTO film (title, language_id, rental_duration, rental_rate, replacement_cost)
VALUES ('Test Film A', 1, 3, 2.99, 19.99);

SAVEPOINT sp1;

-- 2. 영화 B 추가
INSERT INTO film (title, language_id, rental_duration, rental_rate, replacement_cost)
VALUES ('Test Film B', 1, 3, 2.99, 19.99);

SAVEPOINT sp2;

-- 3. 영화 C 추가
INSERT INTO film (title, language_id, rental_duration, rental_rate, replacement_cost)
VALUES ('Test Film C', 1, 3, 2.99, 19.99);

-- 확인 (A, B, C 모두 있음)
SELECT title FROM film WHERE title LIKE 'Test Film%';

-- 4. sp2로 ROLLBACK (C만 취소)
ROLLBACK TO SAVEPOINT sp2;

-- 확인 (A, B만 있음)
SELECT title FROM film WHERE title LIKE 'Test Film%';

-- 5. COMMIT
COMMIT;

-- 최종 확인
SELECT title FROM film WHERE title LIKE 'Test Film%';

-- 정리
DELETE FROM film WHERE title LIKE 'Test Film%';
```
</details>

---

### 문제 4: 조건부 COMMIT (난이도: ⭐⭐⭐)

재고가 있는 경우에만 주문을 생성하는 로직을 작성하세요.

**요구사항:**
- film_id = 1의 재고(inventory) 확인
- 재고가 1개 이상이면 대여(rental) 기록 생성 및 COMMIT
- 재고가 없으면 ROLLBACK

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
START TRANSACTION;

-- 재고 확인
SET @stock_count = (
    SELECT COUNT(*)
    FROM inventory
    WHERE film_id = 1
);

SELECT @stock_count AS '재고 수량';

-- 조건 분기
IF @stock_count > 0 THEN
    -- 재고 있음: 대여 생성
    INSERT INTO rental (rental_date, inventory_id, customer_id, staff_id)
    SELECT NOW(), inventory_id, 1, 1
    FROM inventory
    WHERE film_id = 1
    LIMIT 1;

    SELECT 'Rental created' AS Result;
    COMMIT;
ELSE
    -- 재고 없음: 롤백
    SELECT 'No inventory available' AS Result;
    ROLLBACK;
END IF;

-- MySQL은 IF를 세션 변수나 프로시저에서만 지원하므로,
-- 실제로는 프로시저로 작성해야 합니다.

-- 프로시저 버전:
DELIMITER $$

CREATE PROCEDURE rent_if_available(IN p_film_id INT, IN p_customer_id INT)
BEGIN
    DECLARE stock_count INT;

    START TRANSACTION;

    SELECT COUNT(*) INTO stock_count
    FROM inventory
    WHERE film_id = p_film_id;

    IF stock_count > 0 THEN
        INSERT INTO rental (rental_date, inventory_id, customer_id, staff_id)
        SELECT NOW(), inventory_id, p_customer_id, 1
        FROM inventory
        WHERE film_id = p_film_id
        LIMIT 1;

        SELECT 'Rental created' AS Result;
        COMMIT;
    ELSE
        SELECT 'No inventory available' AS Result;
        ROLLBACK;
    END IF;
END$$

DELIMITER ;

-- 사용
CALL rent_if_available(1, 1);
```
</details>

---

## 강사 가이드

### 수업 진행 팁

1. **실수 복구 시연** (15분)
   - 일부러 DELETE 실행 후 당황하는 연기
   - "앗! 실수했다!" → ROLLBACK으로 복구
   - 학생들에게 안도감 제공: "트랜잭션이 있어서 안전합니다"

2. **COMMIT의 영구성 강조** (10분)
   - COMMIT 후에는 복구 불가능함을 강조
   - "COMMIT은 신중하게, 확인 후 실행"
   - 실무에서는 SELECT로 확인 후 COMMIT

3. **SAVEPOINT 실용성** (15분)
   - 대량 처리 시 유용함 강조
   - 배치 처리 예제 시연
   - "50개까지는 성공, 51번째만 실패" 시나리오

4. **autocommit 주의사항** (10분)
   - 기본값이 ON임을 반드시 강조
   - START TRANSACTION 사용 권장
   - SET autocommit = 0의 위험성 (깜빡하면 확정 안 됨)

5. **실무 패턴 공유** (10분)
   - 조건부 COMMIT/ROLLBACK
   - 오류 처리와 함께 사용
   - 프로그래밍 언어에서의 try-catch 패턴

### 자주 하는 질문

**Q1: COMMIT을 깜빡하면 어떻게 되나요?**
> A:
> - 세션 종료 시 자동 ROLLBACK
> - 다른 사용자들은 변경사항을 볼 수 없음
> - 락이 유지되어 다른 트랜잭션이 대기할 수 있음

**Q2: ROLLBACK 후 데이터가 완전히 복구되나요?**
> A: 네, 트랜잭션 시작 시점으로 100% 복구됩니다. 단, COMMIT 후에는 ROLLBACK 불가능합니다.

**Q3: SAVEPOINT는 몇 개까지 만들 수 있나요?**
> A: 이론적으로는 무제한이지만, 메모리를 사용하므로 적당히 사용해야 합니다. 보통 3-5개 정도가 적절합니다.

**Q4: autocommit = 0으로 설정하면 모든 SQL이 트랜잭션이 되나요?**
> A: 네, 각 SQL 문이 명시적으로 COMMIT 또는 ROLLBACK을 필요로 합니다. 하지만 START TRANSACTION을 사용하는 것이 더 명확합니다.

**Q5: COMMIT이 실패할 수 있나요?**
> A: 드물지만 가능합니다:
> - 디스크 공간 부족
> - 권한 부족
> - 제약조건 위반 (지연된 제약조건 체크)
> - 시스템 장애

### 실습 중 흔한 실수

1. **COMMIT 후 ROLLBACK 시도**
```sql
START TRANSACTION;
INSERT INTO ...;
COMMIT;
ROLLBACK;  -- 소용없음!
```

2. **autocommit = 1 상태에서 트랜잭션 없이 작업**
```sql
DELETE FROM important_table;  -- 즉시 COMMIT됨! 복구 불가!
```

3. **SAVEPOINT 이름 오타**
```sql
SAVEPOINT sp1;
-- ...
ROLLBACK TO SAVEPOINT sp2;  -- ERROR: Savepoint not found
```

---

## 요약

### 핵심 개념

1. **COMMIT**
   - 트랜잭션 변경사항을 영구 확정
   - WAL 방식으로 로그에 먼저 기록
   - COMMIT 후에는 ROLLBACK 불가능

2. **ROLLBACK**
   - 트랜잭션 변경사항을 취소
   - Undo Log를 사용하여 원래 상태로 복원
   - 트랜잭션 시작 시점으로 완전히 되돌림

3. **SAVEPOINT**
   - 트랜잭션 내 부분 롤백 지점
   - 대량 처리 시 유용
   - RELEASE SAVEPOINT로 삭제 가능

4. **Autocommit**
   - MySQL 기본값: ON (자동 커밋)
   - START TRANSACTION 사용 권장
   - SET autocommit = 0은 신중하게 사용

### 명령어 정리

```sql
-- 트랜잭션 제어
START TRANSACTION;  -- 트랜잭션 시작
COMMIT;             -- 확정
ROLLBACK;           -- 취소

-- SAVEPOINT
SAVEPOINT sp_name;            -- 세이브포인트 생성
ROLLBACK TO SAVEPOINT sp_name;  -- 부분 롤백
RELEASE SAVEPOINT sp_name;    -- 세이브포인트 삭제

-- Autocommit
SET autocommit = 0;  -- 비활성화
SET autocommit = 1;  -- 활성화
SELECT @@autocommit;  -- 상태 확인
```

### 다음 단계

다음 시간에는 **트랜잭션 격리 수준(Isolation Level)**을 학습합니다:
- READ UNCOMMITTED
- READ COMMITTED
- REPEATABLE READ (MySQL 기본)
- SERIALIZABLE
- 격리 수준별 발생하는 문제들 (Dirty Read, Non-Repeatable Read, Phantom Read)

---

**연습 권장사항:**
- 실수로 데이터 삭제 후 ROLLBACK 연습 반복
- SAVEPOINT를 활용한 부분 롤백 실습
- 두 세션으로 COMMIT 전후 가시성 테스트
- 프로시저에서 조건부 COMMIT/ROLLBACK 구현
