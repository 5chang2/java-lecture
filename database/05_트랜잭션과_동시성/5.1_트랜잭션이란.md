# 5.1. 트랜잭션(Transaction)이란?

## 학습 목표
- 트랜잭션의 개념과 필요성을 이해한다
- 트랜잭션의 기본 특징을 학습한다
- 실제 사례를 통해 트랜잭션의 중요성을 인식한다
- MySQL에서 트랜잭션을 시작하고 종료하는 방법을 익힌다

---

## 1. 트랜잭션이란?

**트랜잭션(Transaction)**은 데이터베이스에서 수행되는 **하나의 논리적인 작업 단위**입니다. 여러 개의 SQL 문을 하나의 작업으로 묶어서, **모두 성공하거나 모두 실패하도록** 보장합니다.

### 실생활 비유: 은행 계좌 이체

```
A 계좌에서 B 계좌로 10만원을 이체한다고 가정:

1. A 계좌에서 10만원 차감
2. B 계좌에 10만원 추가

이 두 작업은 반드시 함께 성공하거나 함께 실패해야 합니다!
- 1번만 성공하고 2번 실패 → 돈이 사라짐 ❌
- 1번 실패하고 2번 성공 → 돈이 생김 ❌
- 둘 다 성공 또는 둘 다 실패 → 정상 ✅
```

---

## 2. 트랜잭션이 필요한 이유

### 2.1. 데이터 일관성 보장

```sql
-- 트랜잭션 없이 실행하면 문제 발생 가능
UPDATE accounts SET balance = balance - 100000 WHERE account_id = 'A';
-- 이 시점에 시스템 오류 발생! 💥
UPDATE accounts SET balance = balance + 100000 WHERE account_id = 'B';
```

**문제:** 첫 번째 UPDATE는 성공했지만 두 번째가 실패하면 A 계좌에서 돈만 빠져나가고 B 계좌에는 들어가지 않습니다.

```sql
-- 트랜잭션으로 묶으면 안전
START TRANSACTION;

UPDATE accounts SET balance = balance - 100000 WHERE account_id = 'A';
UPDATE accounts SET balance = balance + 100000 WHERE account_id = 'B';

COMMIT;  -- 모두 성공 시 확정
-- 또는
ROLLBACK;  -- 하나라도 실패 시 모두 취소
```

### 2.2. 동시성 제어

여러 사용자가 동시에 같은 데이터를 수정할 때 충돌을 방지합니다.

```
시나리오: 좌석 예약 시스템

사용자 A: 좌석 1번 예약 시도
사용자 B: 좌석 1번 예약 시도 (동시에!)

트랜잭션이 없으면 → 두 사람 모두 예약 성공 ❌
트랜잭션이 있으면 → 한 사람만 성공, 다른 사람은 실패 ✅
```

### 2.3. 복구 가능성

시스템 장애 발생 시 데이터를 일관된 상태로 복구할 수 있습니다.

```
트랜잭션 A: 진행 중 (아직 COMMIT 안 함)
트랜잭션 B: COMMIT 완료

시스템 재시작 후:
- 트랜잭션 A: 자동 ROLLBACK (복구)
- 트랜잭션 B: 데이터 유지
```

---

## 3. 트랜잭션의 기본 개념

### 3.1. 트랜잭션의 시작과 종료

```sql
-- 명시적 트랜잭션 시작
START TRANSACTION;
-- 또는
BEGIN;

-- SQL 문 실행
INSERT INTO ...;
UPDATE ...;
DELETE ...;

-- 트랜잭션 종료
COMMIT;      -- 모든 변경사항 확정
-- 또는
ROLLBACK;    -- 모든 변경사항 취소
```

### 3.2. 자동 커밋 모드

MySQL은 기본적으로 **자동 커밋(Autocommit)** 모드입니다.

```sql
-- 자동 커밋 상태 확인
SELECT @@autocommit;  -- 1이면 활성화

-- 각 SQL 문이 자동으로 하나의 트랜잭션으로 처리됨
INSERT INTO users VALUES (1, 'John');  -- 자동 COMMIT
UPDATE users SET name = 'Jane' WHERE id = 1;  -- 자동 COMMIT
```

**자동 커밋 비활성화:**

```sql
SET autocommit = 0;  -- 비활성화

-- 이제 명시적으로 COMMIT 또는 ROLLBACK 필요
INSERT INTO users VALUES (2, 'Alice');
-- 아직 확정되지 않음! COMMIT 또는 ROLLBACK 필요
```

---

## 4. 트랜잭션 기본 실습

### 4.1. world DB로 기본 개념 실습

#### 예제 1: COMMIT 사용

```sql
-- 현재 도시 수 확인
SELECT COUNT(*) FROM city;  -- 예: 4079개

-- 트랜잭션 시작
START TRANSACTION;

-- 새 도시 추가
INSERT INTO city (Name, CountryCode, District, Population)
VALUES ('Test City', 'KOR', 'Test District', 100000);

-- 아직 다른 세션에서는 보이지 않음!
SELECT COUNT(*) FROM city;  -- 4080개 (현재 세션에서만)

-- 변경사항 확정
COMMIT;

-- 이제 모든 세션에서 확인 가능
SELECT COUNT(*) FROM city;  -- 4080개
```

#### 예제 2: ROLLBACK 사용

```sql
-- 트랜잭션 시작
START TRANSACTION;

-- 도시 삭제
DELETE FROM city WHERE Name = 'Seoul';

-- 확인
SELECT COUNT(*) FROM city WHERE Name = 'Seoul';  -- 0개

-- 실수했다! 취소하자
ROLLBACK;

-- 복구됨!
SELECT COUNT(*) FROM city WHERE Name = 'Seoul';  -- 다시 1개
```

#### 예제 3: 계좌 이체 시뮬레이션

```sql
-- 테스트용 계좌 테이블 생성
CREATE TABLE accounts (
    account_id VARCHAR(10) PRIMARY KEY,
    owner_name VARCHAR(50),
    balance DECIMAL(15, 2)
);

-- 샘플 데이터 삽입
INSERT INTO accounts VALUES
('A001', 'Alice', 1000000.00),
('B001', 'Bob', 500000.00);

-- 초기 잔액 확인
SELECT * FROM accounts;
```

**이체 트랜잭션:**

```sql
START TRANSACTION;

-- Alice가 Bob에게 100,000원 이체
UPDATE accounts SET balance = balance - 100000 WHERE account_id = 'A001';
UPDATE accounts SET balance = balance + 100000 WHERE account_id = 'B001';

-- 결과 확인
SELECT * FROM accounts;
-- A001: 900,000
-- B001: 600,000

-- 확정
COMMIT;
```

**실패 시나리오:**

```sql
START TRANSACTION;

-- Alice가 Bob에게 2,000,000원 이체 시도 (잔액 부족!)
UPDATE accounts SET balance = balance - 2000000 WHERE account_id = 'A001';
-- 결과: balance가 음수가 됨 (제약조건이 없다면)

SELECT * FROM accounts WHERE account_id = 'A001';
-- A001: -1,000,000 (잘못됨!)

-- 취소!
ROLLBACK;

-- 원래대로 복구됨
SELECT * FROM accounts WHERE account_id = 'A001';
-- A001: 900,000
```

---

## 5. 트랜잭션과 DDL

**주의:** DDL(Data Definition Language) 문은 **암묵적으로 COMMIT을 수행**합니다.

```sql
START TRANSACTION;

INSERT INTO city VALUES (5000, 'New City', 'KOR', 'District', 50000);

-- DDL 문 실행
CREATE TABLE temp_table (id INT);
-- 이 시점에 자동 COMMIT 발생! 위의 INSERT도 확정됨

ROLLBACK;  -- 소용없음! 이미 COMMIT됨
```

**영향을 받는 DDL 문:**
- CREATE, ALTER, DROP (TABLE, DATABASE, INDEX 등)
- TRUNCATE TABLE
- RENAME TABLE

---

## 6. 세이브포인트 (SAVEPOINT)

큰 트랜잭션 내에서 **부분적인 롤백 지점**을 만들 수 있습니다.

```sql
START TRANSACTION;

-- 첫 번째 작업
INSERT INTO city VALUES (5001, 'City A', 'KOR', 'District A', 10000);

-- 세이브포인트 생성
SAVEPOINT sp1;

-- 두 번째 작업
INSERT INTO city VALUES (5002, 'City B', 'KOR', 'District B', 20000);

-- 세이브포인트 생성
SAVEPOINT sp2;

-- 세 번째 작업
INSERT INTO city VALUES (5003, 'City C', 'KOR', 'District C', 30000);

-- sp2까지만 롤백 (City C만 취소)
ROLLBACK TO SAVEPOINT sp2;

-- sp1까지 롤백 (City B, C 취소, City A만 남음)
ROLLBACK TO SAVEPOINT sp1;

-- 또는 전체 롤백
ROLLBACK;

-- 또는 전체 커밋
COMMIT;
```

---

## 7. 트랜잭션 사용 패턴

### 7.1. 짧은 트랜잭션 유지

```sql
-- ❌ 나쁜 예: 긴 트랜잭션
START TRANSACTION;
SELECT * FROM large_table;  -- 오래 걸림
-- 사용자 입력 대기... (몇 분)
UPDATE ...;
COMMIT;

-- ✅ 좋은 예: 짧은 트랜잭션
SELECT * FROM large_table;  -- 트랜잭션 밖에서 조회
-- 사용자 입력 대기...
START TRANSACTION;
UPDATE ...;  -- 빠르게 실행
COMMIT;
```

### 7.2. 읽기 전용 작업은 트랜잭션 불필요

```sql
-- 불필요한 트랜잭션
START TRANSACTION;
SELECT * FROM users WHERE id = 1;
COMMIT;

-- 더 나은 방법
SELECT * FROM users WHERE id = 1;
```

### 7.3. 오류 처리와 함께 사용

```sql
-- 프로그래밍 언어에서의 패턴 (의사 코드)
try {
    START TRANSACTION;

    // 여러 SQL 문 실행
    executeSQL("UPDATE accounts SET balance = balance - 100 WHERE id = 1");
    executeSQL("UPDATE accounts SET balance = balance + 100 WHERE id = 2");

    COMMIT;
} catch (Exception e) {
    ROLLBACK;
    // 오류 처리
}
```

---

## 8. 실습 문제

sakila 데이터베이스를 사용하여 트랜잭션을 연습하세요.

### 문제 1: 기본 트랜잭션 (난이도: ⭐)

customer 테이블에 새 고객을 추가한 후, ROLLBACK으로 취소하세요.

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
-- 현재 고객 수 확인
SELECT COUNT(*) FROM customer;

-- 트랜잭션 시작
START TRANSACTION;

-- 새 고객 추가
INSERT INTO customer (store_id, first_name, last_name, email, address_id, create_date)
VALUES (1, 'Test', 'User', 'test@example.com', 1, NOW());

-- 추가 확인
SELECT * FROM customer WHERE email = 'test@example.com';

-- 취소
ROLLBACK;

-- 취소 확인
SELECT * FROM customer WHERE email = 'test@example.com';  -- 결과 없음
```
</details>

---

### 문제 2: 여러 작업 묶기 (난이도: ⭐⭐)

한 트랜잭션 내에서 다음 작업을 수행하고 COMMIT하세요:
1. 특정 고객(customer_id = 1)의 이메일 업데이트
2. 해당 고객의 주소(address) 업데이트

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
-- 현재 정보 확인
SELECT c.customer_id, c.email, a.address, a.phone
FROM customer c
JOIN address a ON c.address_id = a.address_id
WHERE c.customer_id = 1;

-- 트랜잭션 시작
START TRANSACTION;

-- 이메일 업데이트
UPDATE customer
SET email = 'newemail@example.com'
WHERE customer_id = 1;

-- 주소 업데이트
UPDATE address
SET address = 'New Address 123', phone = '123-456-7890'
WHERE address_id = (SELECT address_id FROM customer WHERE customer_id = 1);

-- 변경사항 확인
SELECT c.customer_id, c.email, a.address, a.phone
FROM customer c
JOIN address a ON c.address_id = a.address_id
WHERE c.customer_id = 1;

-- 확정
COMMIT;
```
</details>

---

### 문제 3: SAVEPOINT 활용 (난이도: ⭐⭐⭐)

다음 시나리오를 SAVEPOINT를 사용하여 구현하세요:
1. 새 고객 A 추가 → SAVEPOINT sp1
2. 새 고객 B 추가 → SAVEPOINT sp2
3. 새 고객 C 추가
4. sp2까지 ROLLBACK (고객 C만 취소)
5. COMMIT

```sql
-- 여기에 SQL 작성
```

<details>
<summary>정답 보기</summary>

```sql
START TRANSACTION;

-- 1. 고객 A 추가
INSERT INTO customer (store_id, first_name, last_name, email, address_id, create_date)
VALUES (1, 'Customer', 'A', 'customerA@test.com', 1, NOW());

SAVEPOINT sp1;

-- 2. 고객 B 추가
INSERT INTO customer (store_id, first_name, last_name, email, address_id, create_date)
VALUES (1, 'Customer', 'B', 'customerB@test.com', 1, NOW());

SAVEPOINT sp2;

-- 3. 고객 C 추가
INSERT INTO customer (store_id, first_name, last_name, email, address_id, create_date)
VALUES (1, 'Customer', 'C', 'customerC@test.com', 1, NOW());

-- 확인 (3명 모두 있음)
SELECT * FROM customer WHERE email LIKE '%@test.com';

-- 4. sp2까지 ROLLBACK
ROLLBACK TO SAVEPOINT sp2;

-- 확인 (A, B만 있고 C는 없음)
SELECT * FROM customer WHERE email LIKE '%@test.com';

-- 5. COMMIT
COMMIT;

-- 최종 확인
SELECT * FROM customer WHERE email LIKE '%@test.com';
```
</details>

---

## 강사 가이드

### 수업 진행 팁

1. **실생활 비유로 시작** (10분)
   - 은행 계좌 이체 예시로 트랜잭션의 필요성 설명
   - "여러 작업이 하나처럼 동작해야 하는 상황" 질문
   - 학생들이 경험한 사례 공유 (온라인 쇼핑, 티켓 예매 등)

2. **실습 중심 진행** (30분)
   - 이론 설명은 최소화하고 직접 실행해보기
   - accounts 테이블로 계좌 이체 시뮬레이션
   - 두 개의 MySQL 클라이언트 창을 열어 동시성 시연

3. **COMMIT vs ROLLBACK 체감** (15분)
   - 실수로 DELETE 한 후 ROLLBACK으로 복구하는 경험
   - "트랜잭션 덕분에 데이터를 지킬 수 있다" 강조
   - 트랜잭션 없이 실행했을 때의 위험성 설명

4. **흔한 실수 시연** (10분)
   - DDL 문 실행 시 자동 COMMIT 발생 보여주기
   - 긴 트랜잭션의 문제점 설명
   - 자동 커밋 모드 ON/OFF 차이 체험

5. **다음 차시 예고** (5분)
   - ACID 속성으로 트랜잭션의 특성 깊이 있게 학습 예정
   - 격리 수준, 락, 데드락 등 고급 주제 소개

### 자주 하는 질문

**Q1: 트랜잭션을 항상 사용해야 하나요?**
> A: 아니요. 단순 SELECT나 단일 INSERT/UPDATE는 트랜잭션으로 묶을 필요가 없습니다. **여러 SQL 문이 하나의 논리적 작업을 구성할 때만** 사용합니다.

**Q2: COMMIT을 깜빡하면 어떻게 되나요?**
> A:
> - 자동 커밋 모드 ON (기본): 각 문이 자동 COMMIT
> - 자동 커밋 모드 OFF: 세션 종료 시 자동 ROLLBACK
> - 명시적 트랜잭션(START TRANSACTION): 연결 종료 시 자동 ROLLBACK

**Q3: 트랜잭션이 너무 길면 어떤 문제가 생기나요?**
> A:
> - 다른 사용자가 해당 데이터에 접근하지 못하고 대기 (락 대기)
> - 메모리 사용량 증가
> - 시스템 장애 시 복구 시간 증가
> - 데드락 발생 확률 증가

**Q4: SELECT만 하는데도 트랜잭션이 필요한가요?**
> A: 대부분 불필요하지만, **여러 SELECT 문이 일관된 스냅샷을 봐야 하는 경우** 트랜잭션이 필요합니다. 예: 보고서 생성 시 데이터가 중간에 변경되면 안 되는 경우.

**Q5: 프로그래밍 언어에서는 어떻게 사용하나요?**
> A:
> ```java
> // Java 예시
> try {
>     connection.setAutoCommit(false);
>     // SQL 실행
>     connection.commit();
> } catch (SQLException e) {
>     connection.rollback();
> }
> ```

### 실습 중 흔한 실수

1. **START TRANSACTION 후 COMMIT 잊어버림**
```sql
START TRANSACTION;
INSERT INTO users VALUES (1, 'John');
-- COMMIT을 잊음!
-- 연결 종료 시 자동 ROLLBACK됨
```

2. **DDL과 DML 혼용**
```sql
START TRANSACTION;
INSERT INTO users VALUES (1, 'John');
CREATE TABLE temp (id INT);  -- 여기서 자동 COMMIT!
-- INSERT도 확정됨
ROLLBACK;  -- 소용없음
```

3. **여러 세션에서 같은 데이터 수정**
```sql
-- 세션 1
START TRANSACTION;
UPDATE accounts SET balance = 1000 WHERE id = 1;
-- COMMIT 안 함

-- 세션 2
UPDATE accounts SET balance = 2000 WHERE id = 1;  -- 대기...
```

### 데모 시나리오

**시나리오: 온라인 쇼핑몰 주문 처리**

```sql
-- 주문 처리 트랜잭션 시뮬레이션
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    name VARCHAR(100),
    stock INT,
    price DECIMAL(10, 2)
);

CREATE TABLE orders (
    order_id INT AUTO_INCREMENT PRIMARY KEY,
    product_id INT,
    quantity INT,
    total_price DECIMAL(10, 2),
    order_date DATETIME
);

INSERT INTO products VALUES
(1, 'Laptop', 10, 1000000),
(2, 'Mouse', 50, 30000);

-- 주문 처리 (트랜잭션 필수!)
START TRANSACTION;

-- 1. 재고 확인
SELECT stock FROM products WHERE product_id = 1;  -- 10개

-- 2. 재고 감소
UPDATE products SET stock = stock - 1 WHERE product_id = 1;

-- 3. 주문 생성
INSERT INTO orders (product_id, quantity, total_price, order_date)
VALUES (1, 1, 1000000, NOW());

-- 4. 확정
COMMIT;

-- 확인
SELECT * FROM products WHERE product_id = 1;  -- stock: 9
SELECT * FROM orders;
```

---

## 요약

### 핵심 개념

1. **트랜잭션은 논리적 작업 단위**
   - 여러 SQL 문을 하나로 묶음
   - 모두 성공 또는 모두 실패 (원자성)

2. **트랜잭션 제어 명령**
   ```sql
   START TRANSACTION / BEGIN  -- 시작
   COMMIT                     -- 확정
   ROLLBACK                   -- 취소
   SAVEPOINT                  -- 중간 저장점
   ```

3. **자동 커밋 모드**
   - MySQL 기본값: ON
   - OFF로 설정 시 명시적 COMMIT 필요

4. **주의사항**
   - DDL 문은 자동 COMMIT 발생
   - 트랜잭션은 가능한 짧게 유지
   - 읽기 전용 작업은 트랜잭션 불필요

### 다음 단계

다음 시간에는 **ACID 속성**을 학습합니다:
- Atomicity (원자성)
- Consistency (일관성)
- Isolation (격리성)
- Durability (지속성)

트랜잭션이 보장하는 4가지 핵심 속성을 자세히 알아봅니다.

---

**연습 권장사항:**
- 실제 데이터로 계좌 이체 시뮬레이션 여러 번 연습
- COMMIT과 ROLLBACK의 차이를 체감할 수 있도록 반복 실습
- 두 개의 MySQL 클라이언트로 동시성 테스트
- 실수로 DELETE 실행 후 ROLLBACK으로 복구하는 경험하기
