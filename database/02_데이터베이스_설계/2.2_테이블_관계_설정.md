# 2.2. 테이블 관계 설정 (1:1, 1:N, N:M)

> ERD의 관계를 실제 데이터베이스 테이블로 구현할 수 있다.

---

## 1. ERD에서 테이블로

ERD는 개념적 설계이고, 이를 **실제 데이터베이스 테이블로 변환**하는 과정이 필요합니다.

### 변환 규칙

```
ERD 개체 → 데이터베이스 테이블
ERD 속성 → 테이블의 열(Column)
ERD 관계 → 외래키(Foreign Key)로 구현
```

---

## 2. 1:1 관계 구현

### 개념
한 테이블의 행이 다른 테이블의 **정확히 한 행**과만 연결됩니다.

### 구현 방법

**방법 1: 외래키를 양쪽 중 한 곳에 배치** (권장)

```sql
-- 회원 테이블
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE
);

-- 회원 프로필 테이블
CREATE TABLE user_profiles (
    profile_id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT UNIQUE,  -- UNIQUE: 1:1 관계 보장
    bio TEXT,
    profile_image VARCHAR(255),
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

**핵심**: `user_id`에 `UNIQUE` 제약 조건을 설정하여 1:1 관계를 보장합니다.

**데이터 예시**:
```
users 테이블:
+--------+-----------+------------------+
|user_id | username  | email            |
+--------+-----------+------------------+
| 1      | hong      | hong@email.com   |
| 2      | kim       | kim@email.com    |
+--------+-----------+------------------+

user_profiles 테이블:
+-----------+--------+-------------+-------------------+
|profile_id |user_id | bio         | profile_image     |
+-----------+--------+-------------+-------------------+
| 1         | 1      | Hello!      | profile1.jpg      |
| 2         | 2      | Nice to meet | profile2.jpg     |
+-----------+--------+-------------+-------------------+
```

**방법 2: 두 테이블을 하나로 합치기**

1:1 관계가 항상 존재한다면 테이블을 합치는 것도 고려할 수 있습니다.

```sql
-- 통합 테이블
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE,
    bio TEXT,
    profile_image VARCHAR(255)
);
```

**사용 목적**:
- **데이터 분리**: 보안이 필요한 정보를 별도 테이블로 분리
- **성능 최적화**: 자주 사용하지 않는 데이터 분리

---

## 3. 1:N 관계 구현

### 개념
한 테이블의 행이 다른 테이블의 **여러 행**과 연결됩니다. **가장 흔한 관계**입니다.

### 구현 방법

**'다(N)' 쪽 테이블에 외래키(FK) 추가**

```sql
-- 회원 테이블 (1)
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE
);

-- 게시글 테이블 (N)
CREATE TABLE posts (
    post_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    user_id INT NOT NULL,  -- 외래키
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

**데이터 예시**:
```
users 테이블:
+--------+-----------+------------------+
|user_id | username  | email            |
+--------+-----------+------------------+
| 1      | hong      | hong@email.com   |
| 2      | kim       | kim@email.com    |
+--------+-----------+------------------+

posts 테이블:
+--------+------------+----------+--------+
|post_id | title      | content  |user_id |
+--------+------------+----------+--------+
| 1      | 첫 글      | 안녕!    | 1      | ← hong의 글
| 2      | 두번째 글  | 반가워   | 1      | ← hong의 글
| 3      | 김의 글    | Hello    | 2      | ← kim의 글
+--------+------------+----------+--------+
```

한 회원(user_id=1)이 여러 게시글(post_id=1, 2)을 작성했습니다.

### 조회 예시

**특정 회원의 모든 게시글 조회**:
```sql
SELECT * FROM posts WHERE user_id = 1;
```

**게시글과 작성자 정보 함께 조회** (JOIN):
```sql
SELECT p.title, p.content, u.username
FROM posts p
JOIN users u ON p.user_id = u.user_id;
```

---

## 4. N:M 관계 구현

### 개념
양쪽 테이블 모두 여러 행과 연결됩니다.

### 문제점
RDBMS는 N:M 관계를 **직접 구현할 수 없습니다**.

### 해결 방법
**중간 테이블(연결 테이블, Junction Table)**을 생성하여 두 개의 1:N 관계로 분해합니다.

### 구현 예시: 학생 ↔ 과목

```sql
-- 학생 테이블
CREATE TABLE students (
    student_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL
);

-- 과목 테이블
CREATE TABLE subjects (
    subject_id INT PRIMARY KEY AUTO_INCREMENT,
    subject_name VARCHAR(50) NOT NULL
);

-- 수강신청 테이블 (중간 테이블)
CREATE TABLE enrollments (
    enrollment_id INT PRIMARY KEY AUTO_INCREMENT,
    student_id INT NOT NULL,
    subject_id INT NOT NULL,
    enrolled_date DATE DEFAULT (CURRENT_DATE),
    FOREIGN KEY (student_id) REFERENCES students(student_id),
    FOREIGN KEY (subject_id) REFERENCES subjects(subject_id),
    UNIQUE (student_id, subject_id)  -- 같은 학생이 같은 과목을 중복 수강 방지
);
```

**관계 도식**:
```
students |-------< enrollments >-------| subjects
         1         N         N         1
```

**데이터 예시**:
```
students 테이블:
+-----------+--------+
|student_id | name   |
+-----------+--------+
| 1         | 홍길동 |
| 2         | 김영희 |
+-----------+--------+

subjects 테이블:
+-----------+-------------+
|subject_id | subject_name|
+-----------+-------------+
| 1         | 자바        |
| 2         | 데이터베이스|
+-----------+-------------+

enrollments 테이블:
+-------------+-----------+-----------+
|enrollment_id|student_id |subject_id |
+-------------+-----------+-----------+
| 1           | 1         | 1         | ← 홍길동이 자바 수강
| 2           | 1         | 2         | ← 홍길동이 DB 수강
| 3           | 2         | 1         | ← 김영희가 자바 수강
+-------------+-----------+-----------+
```

- 홍길동(student_id=1)은 자바(subject_id=1), DB(subject_id=2) 수강
- 자바(subject_id=1)는 홍길동, 김영희가 수강

### 조회 예시

**특정 학생이 수강하는 모든 과목**:
```sql
SELECT s.subject_name
FROM enrollments e
JOIN subjects s ON e.subject_id = s.subject_id
WHERE e.student_id = 1;
```

**특정 과목을 수강하는 모든 학생**:
```sql
SELECT st.name
FROM enrollments e
JOIN students st ON e.student_id = st.student_id
WHERE e.subject_id = 1;
```

### 중간 테이블에 추가 정보 저장

중간 테이블에는 관계와 관련된 추가 정보를 저장할 수 있습니다.

```sql
CREATE TABLE enrollments (
    enrollment_id INT PRIMARY KEY AUTO_INCREMENT,
    student_id INT NOT NULL,
    subject_id INT NOT NULL,
    enrolled_date DATE DEFAULT (CURRENT_DATE),
    grade VARCHAR(2),  -- 성적 추가
    FOREIGN KEY (student_id) REFERENCES students(student_id),
    FOREIGN KEY (subject_id) REFERENCES subjects(subject_id)
);
```

---

## 5. 실습 예시: 쇼핑몰 주문 시스템

### 요구사항
- 고객은 여러 주문을 할 수 있다 (1:N)
- 한 주문에는 여러 상품이 포함될 수 있다 (N:M)

### ERD
```
고객 |-------< 주문 >-------| 상품
     1         N   N         1
```

### 테이블 구조

```sql
-- 고객 테이블
CREATE TABLE customers (
    customer_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE
);

-- 상품 테이블
CREATE TABLE products (
    product_id INT PRIMARY KEY AUTO_INCREMENT,
    product_name VARCHAR(100) NOT NULL,
    price DECIMAL(10, 2) NOT NULL
);

-- 주문 테이블
CREATE TABLE orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT NOT NULL,
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    total_amount DECIMAL(10, 2),
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

-- 주문상세 테이블 (중간 테이블)
CREATE TABLE order_details (
    order_detail_id INT PRIMARY KEY AUTO_INCREMENT,
    order_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL DEFAULT 1,
    price_at_purchase DECIMAL(10, 2) NOT NULL,  -- 주문 시점의 가격
    FOREIGN KEY (order_id) REFERENCES orders(order_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);
```

**핵심**: `price_at_purchase`는 주문 시점의 가격을 저장합니다. 상품 가격은 언제든 변경될 수 있기 때문에, 주문 당시의 가격을 별도로 기록해야 합니다.

### 데이터 삽입

```sql
-- 고객 추가
INSERT INTO customers (name, email) VALUES
('홍길동', 'hong@email.com'),
('김영희', 'kim@email.com');

-- 상품 추가
INSERT INTO products (product_name, price) VALUES
('노트북', 1500000.00),
('마우스', 25000.00),
('키보드', 50000.00);

-- 주문 추가
INSERT INTO orders (customer_id, total_amount) VALUES
(1, 1575000.00);  -- 홍길동의 주문

-- 주문상세 추가
INSERT INTO order_details (order_id, product_id, quantity, price_at_purchase) VALUES
(1, 1, 1, 1500000.00),  -- 노트북 1개
(1, 2, 3, 25000.00);    -- 마우스 3개
```

### 조회: 특정 주문의 상세 내역

```sql
SELECT
    o.order_id,
    c.name AS customer_name,
    p.product_name,
    od.quantity,
    od.price_at_purchase,
    (od.quantity * od.price_at_purchase) AS subtotal
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
JOIN order_details od ON o.order_id = od.order_id
JOIN products p ON od.product_id = p.product_id
WHERE o.order_id = 1;
```

---

## 실습 문제

### 문제 1: 관계 구현하기

다음 요구사항을 테이블로 구현하세요.

**요구사항**: 직원 관리 시스템
- 직원은 한 부서에 속한다 (N:1)
- 한 부서에는 여러 직원이 있다 (1:N)

**작성할 SQL**:
```sql
-- 부서 테이블


-- 직원 테이블
```

**예상 답**:
```sql
CREATE TABLE departments (
    dept_id INT PRIMARY KEY AUTO_INCREMENT,
    dept_name VARCHAR(50) NOT NULL
);

CREATE TABLE employees (
    emp_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    dept_id INT NOT NULL,
    FOREIGN KEY (dept_id) REFERENCES departments(dept_id)
);
```

### 문제 2: N:M 관계 구현하기

**요구사항**: 영화 예매 시스템
- 영화는 여러 배우가 출연한다
- 배우는 여러 영화에 출연한다

**작성할 SQL**:
```sql
-- 영화 테이블


-- 배우 테이블


-- 출연 테이블 (중간 테이블)
```

**힌트**: 중간 테이블에 `role` (배역) 정보도 추가해보세요.

### 문제 3: 복잡한 관계 설계

**요구사항**: 병원 예약 시스템
- 환자는 여러 번 예약할 수 있다
- 의사는 여러 환자를 진료한다
- 한 예약에는 한 명의 환자와 한 명의 의사가 관련된다

**질문**:
1. 어떤 테이블이 필요한가요?
2. 각 테이블의 기본키는 무엇인가요?
3. 외래키는 어디에 위치해야 하나요?

**예상 답**:
```
테이블: patients, doctors, appointments

appointments 테이블이 핵심:
- patient_id (FK)
- doctor_id (FK)
- appointment_date
```

---

## 강사 가이드

### 핵심 포인트
1. **외래키가 핵심**: 관계는 외래키로 구현된다는 점 강조
2. **방향 이해**: '일' 쪽의 기본키가 '다' 쪽의 외래키로
3. **중간 테이블 필수**: N:M은 반드시 중간 테이블로 분해
4. **실습 중심**: 코드를 직접 작성하며 이해

### 자주 하는 질문

**Q: 외래키는 꼭 설정해야 하나요?**
A: 필수는 아니지만 강력 권장. 외래키가 없으면 데이터 무결성을 보장할 수 없음.

**Q: 중간 테이블의 이름은 어떻게 짓나요?**
A: 두 테이블 이름을 조합하거나, 관계를 나타내는 동사 사용 (예: `enrollments`, `order_details`)

**Q: 중간 테이블에 기본키가 필요한가요?**
A: 권장. 각 관계를 고유하게 식별할 수 있어야 함.

**Q: 1:1 관계는 언제 사용하나요?**
A: 드물지만 보안, 성능, 선택적 속성 분리 시 사용.

### 실습 진행 방법
1. 간단한 관계부터 시작 (1:N)
2. SQL로 직접 테이블 생성
3. 데이터 삽입 및 JOIN 쿼리 실습
4. N:M 관계로 확장
5. 실제 프로젝트 시나리오 설계

---

## 요약

- **1:1 관계**: 외래키에 `UNIQUE` 제약 조건 추가
  - 예: users ↔ user_profiles
- **1:N 관계**: '다(N)' 쪽에 외래키 추가 (가장 흔함)
  - 예: users(1) ↔ posts(N)
- **N:M 관계**: 중간 테이블로 두 개의 1:N으로 분해
  - 예: students ↔ enrollments ↔ subjects
- **외래키 (FK)**: 관계를 구현하는 핵심 도구
- **중간 테이블**: N:M 관계 해소, 추가 정보 저장 가능
- **참조 무결성**: 외래키로 데이터 일관성 보장

**다음 단계**: 데이터 중복을 제거하고 구조를 최적화하는 정규화를 배웁니다!
