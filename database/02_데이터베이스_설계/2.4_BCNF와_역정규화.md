# 2.4. BCNF와 역정규화

> BCNF의 개념을 이해하고, 실무에서 사용하는 역정규화 기법을 적용할 수 있다.

---

## 1. BCNF (Boyce-Codd Normal Form)

### 정의
**BCNF**는 3NF보다 더 강화된 정규형입니다. **모든 결정자(Determinant)가 후보키(Candidate Key)여야 합니다.**

**쉽게 말하면**:
```
어떤 열이 다른 열을 결정한다면,
그 열은 반드시 기본키(또는 후보키)여야 함
```

### 용어 정리

**결정자 (Determinant)**:
- 다른 열의 값을 결정할 수 있는 열
- A → B 관계에서 A가 결정자

**후보키 (Candidate Key)**:
- 기본키가 될 수 있는 열
- 유일성과 최소성을 만족

---

## 2. BCNF가 필요한 이유

### Before (BCNF 위반)

**시나리오**: 한 교수는 한 과목만 가르친다고 가정

```sql
+--------+------+--------+
| 학생   | 과목 | 교수   |
+--------+------+--------+
| 김민준 | 물리 | 박교수 |
| 이서연 | 물리 | 박교수 |
| 박하준 | 화학 | 최교수 |
| 김민준 | 화학 | 최교수 |
+--------+------+--------+
```

**종속 관계**:
```
(학생, 과목) → 교수  ✓ (기본키 → 다른 열)
교수 → 과목          ✓ (결정자이지만 후보키 아님) ✗ 문제!
```

**후보키**: `(학생, 과목)`

**문제점**:
- `교수`가 `과목`을 결정하지만, `교수`는 후보키가 아님
- 같은 교수가 여러 행에 중복 저장됨
- 교수의 담당 과목 변경 시 여러 행 수정 필요

### After (BCNF 만족)

**해결**: 결정자인 `교수`를 후보키로 갖는 테이블로 분리

```sql
-- 수강생 테이블
+--------+--------+
| 학생   | 교수   |
+--------+--------+
| 김민준 | 박교수 |
| 이서연 | 박교수 |
| 박하준 | 최교수 |
| 김민준 | 최교수 |
+--------+--------+

-- 교수담당 테이블
+--------+------+
| 교수   | 과목 |
+--------+------+
| 박교수 | 물리 |
| 최교수 | 화학 |
+--------+------+
```

### SQL 구현

```sql
-- 교수담당 테이블
CREATE TABLE professor_subjects (
    professor_name VARCHAR(50) PRIMARY KEY,
    subject VARCHAR(50) NOT NULL
);

-- 수강생 테이블
CREATE TABLE student_professors (
    student_id INT PRIMARY KEY AUTO_INCREMENT,
    student_name VARCHAR(50) NOT NULL,
    professor_name VARCHAR(50) NOT NULL,
    FOREIGN KEY (professor_name) REFERENCES professor_subjects(professor_name)
);
```

---

## 3. 3NF vs BCNF 비교

### 차이점

```
3NF:  기본키가 아닌 열들 간에 종속 관계 없음
BCNF: 모든 결정자가 후보키
```

**예시**:
```
3NF 만족하지만 BCNF 위반:
  - 결정자가 있지만 후보키가 아닌 경우

BCNF 만족:
  - 모든 결정자가 후보키인 경우
  - (BCNF를 만족하면 자동으로 3NF도 만족)
```

### 언제 3NF와 BCNF가 다른가?

**대부분의 경우 3NF = BCNF**
- 단일 후보키를 가진 테이블은 3NF면 BCNF도 만족

**차이가 발생하는 경우**:
- 복합 후보키가 여러 개 있고
- 후보키가 서로 겹칠 때

**실무에서**: 3NF까지만 적용해도 대부분 충분합니다.

---

## 4. 역정규화 (Denormalization)

### 정의
**역정규화**는 의도적으로 정규화 규칙을 위반하여 데이터 중복을 허용하는 것입니다.

**목적**: 조회 성능 향상

### 왜 역정규화를 하는가?

**정규화의 단점**:
```sql
-- 정규화된 구조: 여러 테이블 JOIN 필요
SELECT
    o.order_id,
    c.name,
    p.product_name,
    od.quantity
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
JOIN order_details od ON o.order_id = od.order_id
JOIN products p ON od.product_id = p.product_id;
```

**문제점**:
- 여러 테이블을 JOIN하면 성능 저하
- 복잡한 쿼리 작성 필요
- 대량 데이터에서 JOIN은 매우 느림

---

## 5. 역정규화 기법

### 1. 테이블 통합

**정규화된 구조**:
```sql
-- 주문 테이블
+----------+------------+
| order_id | customer_id|
+----------+------------+
| 1        | C001       |
+----------+------------+

-- 고객 테이블
+------------+--------+
| customer_id| name   |
+------------+--------+
| C001       | 홍길동 |
+------------+--------+
```

**역정규화 (테이블 통합)**:
```sql
-- 통합 주문 테이블
+----------+------------+----------+
| order_id | customer_id| cust_name|
+----------+------------+----------+
| 1        | C001       | 홍길동   |
+----------+------------+----------+
```

**장점**: JOIN 없이 한 번에 조회
**단점**: 고객명 변경 시 모든 주문 수정 필요

### 2. 파생 열 추가

**정규화된 구조**:
```sql
-- 주문상세 테이블
+----------+--------+----------+-------+
| order_id | prod_id| quantity | price |
+----------+--------+----------+-------+
| 1        | P01    | 2        | 10000 |
| 1        | P02    | 1        | 5000  |
+----------+--------+----------+-------+
```

**역정규화 (총액 열 추가)**:
```sql
-- 주문 테이블
+----------+------------+------------+
| order_id | customer_id| total_amount|
+----------+------------+------------+
| 1        | C001       | 25000      |
+----------+------------+------------+
```

**장점**: 총액 계산 없이 바로 조회
**단점**: 주문상세 변경 시 총액도 업데이트 필요

### 3. 자주 사용하는 JOIN 결과 저장

**정규화된 구조**:
```sql
-- 게시글 + 작성자 정보를 매번 JOIN
SELECT p.*, u.username
FROM posts p
JOIN users u ON p.user_id = u.user_id;
```

**역정규화 (작성자명 저장)**:
```sql
-- 게시글 테이블에 작성자명 추가
CREATE TABLE posts (
    post_id INT PRIMARY KEY,
    title VARCHAR(255),
    content TEXT,
    user_id INT,
    author_name VARCHAR(50),  -- 역정규화
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

### 4. 집계 데이터 미리 계산

**정규화된 구조**:
```sql
-- 매번 집계 쿼리 실행
SELECT user_id, COUNT(*) as post_count
FROM posts
GROUP BY user_id;
```

**역정규화 (카운트 저장)**:
```sql
-- 사용자 테이블에 게시글 수 저장
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    username VARCHAR(50),
    post_count INT DEFAULT 0  -- 역정규화
);

-- 게시글 삽입 시 카운트 증가
-- (Trigger 또는 Application에서 처리)
```

---

## 강사 가이드

### 핵심 포인트
1. **BCNF는 심화**: 3NF만 알아도 대부분 충분, BCNF는 개념만 이해
2. **역정규화는 트레이드오프**: 성능 vs 무결성, 상황에 따라 판단
3. **실무 중심**: 언제 역정규화를 사용하는지 실제 예시로 설명
4. **대안 제시**: 역정규화 전에 인덱스, 캐시 등 다른 방법 고려

### 자주 하는 질문

**Q: BCNF까지 꼭 정규화해야 하나요?**
A: 아님. 대부분은 3NF까지면 충분. BCNF는 특수한 경우에만 필요.

**Q: 역정규화는 나쁜 것 아닌가요?**
A: 아님. 성능을 위해 의도적으로 사용하는 기법. 단, 신중하게 적용해야 함.

**Q: 언제 역정규화를 해야 하나요?**
A: 성능 문제가 실제로 발생했을 때. 처음부터 역정규화하지 말 것.

**Q: 역정규화한 데이터는 어떻게 동기화하나요?**
A: Application 코드, Trigger, 또는 Batch Job으로 처리.

### 실습 진행 방법
1. BCNF 위반 예시로 개념 이해
2. 정규화된 테이블의 JOIN 성능 측정
3. 역정규화 적용 후 성능 비교
4. 데이터 불일치 시나리오 실습
5. 실무 사례 토론

---

## 요약

- **BCNF**: 모든 결정자가 후보키여야 함 (3NF보다 강화)
  - 예: 교수 → 과목 관계에서 교수가 결정자이지만 후보키 아님
- **3NF vs BCNF**: 대부분 동일, 복합 후보키가 겹칠 때만 차이 발생
- **역정규화**: 의도적으로 중복 허용, 조회 성능 향상
- **역정규화 기법**:
  - 테이블 통합
  - 파생 열 추가 (총액, 카운트 등)
  - 자주 사용하는 JOIN 결과 저장
- **역정규화 시점**: 성능 문제 발생 후, 조회가 많고 변경이 적을 때
- **대안**: 인덱스, 뷰, 캐시 먼저 고려

**다음 단계**: 데이터 무결성을 보장하는 제약 조건을 배웁니다!
