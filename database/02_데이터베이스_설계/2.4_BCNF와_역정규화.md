# 2.4. BCNF와 역정규화

> BCNF의 개념을 이해하고, 실무에서 사용하는 역정규화 기법을 적용할 수 있다.

---

## 1. BCNF (Boyce-Codd Normal Form)

### 정의
**BCNF**는 3NF보다 더 강화된 정규형입니다. **모든 결정자(Determinant)가 후보키(Candidate Key)여야 합니다.**

**쉽게 말하면**:
```
어떤 열이 다른 열을 결정한다면,
그 열은 반드시 기본키(또는 후보키)여야 함
```

### 용어 정리

**결정자 (Determinant)**:
- 다른 열의 값을 결정할 수 있는 열
- A → B 관계에서 A가 결정자

**후보키 (Candidate Key)**:
- 기본키가 될 수 있는 열
- 유일성과 최소성을 만족

---

## 2. BCNF가 필요한 이유

### Before (BCNF 위반)

**시나리오**: 한 교수는 한 과목만 가르친다고 가정

```sql
+--------+------+--------+
| 학생   | 과목 | 교수   |
+--------+------+--------+
| 김민준 | 물리 | 박교수 |
| 이서연 | 물리 | 박교수 |
| 박하준 | 화학 | 최교수 |
| 김민준 | 화학 | 최교수 |
+--------+------+--------+
```

**종속 관계**:
```
(학생, 과목) → 교수  ✓ (기본키 → 다른 열)
교수 → 과목          ✓ (결정자이지만 후보키 아님) ✗ 문제!
```

**후보키**: `(학생, 과목)`

**문제점**:
- `교수`가 `과목`을 결정하지만, `교수`는 후보키가 아님
- 같은 교수가 여러 행에 중복 저장됨
- 교수의 담당 과목 변경 시 여러 행 수정 필요

### After (BCNF 만족)

**해결**: 결정자인 `교수`를 후보키로 갖는 테이블로 분리

```sql
-- 수강생 테이블
+--------+--------+
| 학생   | 교수   |
+--------+--------+
| 김민준 | 박교수 |
| 이서연 | 박교수 |
| 박하준 | 최교수 |
| 김민준 | 최교수 |
+--------+--------+

-- 교수담당 테이블
+--------+------+
| 교수   | 과목 |
+--------+------+
| 박교수 | 물리 |
| 최교수 | 화학 |
+--------+------+
```

### SQL 구현

```sql
-- 교수담당 테이블
CREATE TABLE professor_subjects (
    professor_name VARCHAR(50) PRIMARY KEY,
    subject VARCHAR(50) NOT NULL
);

-- 수강생 테이블
CREATE TABLE student_professors (
    student_id INT PRIMARY KEY AUTO_INCREMENT,
    student_name VARCHAR(50) NOT NULL,
    professor_name VARCHAR(50) NOT NULL,
    FOREIGN KEY (professor_name) REFERENCES professor_subjects(professor_name)
);
```

---

## 3. 3NF vs BCNF 비교

### 차이점

```
3NF:  기본키가 아닌 열들 간에 종속 관계 없음
BCNF: 모든 결정자가 후보키
```

**예시**:
```
3NF 만족하지만 BCNF 위반:
  - 결정자가 있지만 후보키가 아닌 경우

BCNF 만족:
  - 모든 결정자가 후보키인 경우
  - (BCNF를 만족하면 자동으로 3NF도 만족)
```

### 언제 3NF와 BCNF가 다른가?

**대부분의 경우 3NF = BCNF**
- 단일 후보키를 가진 테이블은 3NF면 BCNF도 만족

**차이가 발생하는 경우**:
- 복합 후보키가 여러 개 있고
- 후보키가 서로 겹칠 때

**실무에서**: 3NF까지만 적용해도 대부분 충분합니다.

---

## 4. 역정규화 (Denormalization)

### 정의
**역정규화**는 의도적으로 정규화 규칙을 위반하여 데이터 중복을 허용하는 것입니다.

**목적**: 조회 성능 향상

### 왜 역정규화를 하는가?

**정규화의 단점**:
```sql
-- 정규화된 구조: 여러 테이블 JOIN 필요
SELECT
    o.order_id,
    c.name,
    p.product_name,
    od.quantity
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
JOIN order_details od ON o.order_id = od.order_id
JOIN products p ON od.product_id = p.product_id;
```

**문제점**:
- 여러 테이블을 JOIN하면 성능 저하
- 복잡한 쿼리 작성 필요
- 대량 데이터에서 JOIN은 매우 느림

---

## 5. 역정규화 기법

### 1. 테이블 통합

**정규화된 구조**:
```sql
-- 주문 테이블
+----------+------------+
| order_id | customer_id|
+----------+------------+
| 1        | C001       |
+----------+------------+

-- 고객 테이블
+------------+--------+
| customer_id| name   |
+------------+--------+
| C001       | 홍길동 |
+------------+--------+
```

**역정규화 (테이블 통합)**:
```sql
-- 통합 주문 테이블
+----------+------------+----------+
| order_id | customer_id| cust_name|
+----------+------------+----------+
| 1        | C001       | 홍길동   |
+----------+------------+----------+
```

**장점**: JOIN 없이 한 번에 조회
**단점**: 고객명 변경 시 모든 주문 수정 필요

### 2. 파생 열 추가

**정규화된 구조**:
```sql
-- 주문상세 테이블
+----------+--------+----------+-------+
| order_id | prod_id| quantity | price |
+----------+--------+----------+-------+
| 1        | P01    | 2        | 10000 |
| 1        | P02    | 1        | 5000  |
+----------+--------+----------+-------+
```

**역정규화 (총액 열 추가)**:
```sql
-- 주문 테이블
+----------+------------+------------+
| order_id | customer_id| total_amount|
+----------+------------+------------+
| 1        | C001       | 25000      |
+----------+------------+------------+
```

**장점**: 총액 계산 없이 바로 조회
**단점**: 주문상세 변경 시 총액도 업데이트 필요

### 3. 자주 사용하는 JOIN 결과 저장

**정규화된 구조**:
```sql
-- 게시글 + 작성자 정보를 매번 JOIN
SELECT p.*, u.username
FROM posts p
JOIN users u ON p.user_id = u.user_id;
```

**역정규화 (작성자명 저장)**:
```sql
-- 게시글 테이블에 작성자명 추가
CREATE TABLE posts (
    post_id INT PRIMARY KEY,
    title VARCHAR(255),
    content TEXT,
    user_id INT,
    author_name VARCHAR(50),  -- 역정규화
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

### 4. 집계 데이터 미리 계산

**정규화된 구조**:
```sql
-- 매번 집계 쿼리 실행
SELECT user_id, COUNT(*) as post_count
FROM posts
GROUP BY user_id;
```

**역정규화 (카운트 저장)**:
```sql
-- 사용자 테이블에 게시글 수 저장
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    username VARCHAR(50),
    post_count INT DEFAULT 0  -- 역정규화
);

-- 게시글 삽입 시 카운트 증가
-- (Trigger 또는 Application에서 처리)
```

---

## 6. 역정규화 적용 시나리오

### 시나리오 1: 쇼핑몰 주문 시스템

**요구사항**: 주문 목록 조회 시 주문 총액을 빠르게 표시

**정규화된 구조**:
```sql
-- 주문 테이블
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    order_date TIMESTAMP
);

-- 주문상세 테이블
CREATE TABLE order_details (
    order_detail_id INT PRIMARY KEY,
    order_id INT,
    product_id INT,
    quantity INT,
    price DECIMAL(10, 2)
);

-- 총액 조회 (매번 계산)
SELECT
    o.order_id,
    SUM(od.quantity * od.price) AS total_amount
FROM orders o
JOIN order_details od ON o.order_id = od.order_id
GROUP BY o.order_id;
```

**역정규화 적용**:
```sql
-- 주문 테이블에 총액 추가
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    order_date TIMESTAMP,
    total_amount DECIMAL(10, 2)  -- 역정규화
);

-- 주문 상세 삽입/수정 시 총액 업데이트
-- (Application 또는 Trigger로 처리)
```

### 시나리오 2: SNS 게시글 시스템

**요구사항**: 게시글 목록에 댓글 수 표시

**정규화된 구조**:
```sql
-- 게시글 테이블
CREATE TABLE posts (
    post_id INT PRIMARY KEY,
    title VARCHAR(255),
    content TEXT
);

-- 댓글 테이블
CREATE TABLE comments (
    comment_id INT PRIMARY KEY,
    post_id INT,
    content TEXT
);

-- 댓글 수 조회 (매번 카운트)
SELECT
    p.*,
    COUNT(c.comment_id) AS comment_count
FROM posts p
LEFT JOIN comments c ON p.post_id = c.post_id
GROUP BY p.post_id;
```

**역정규화 적용**:
```sql
-- 게시글 테이블에 댓글 수 추가
CREATE TABLE posts (
    post_id INT PRIMARY KEY,
    title VARCHAR(255),
    content TEXT,
    comment_count INT DEFAULT 0  -- 역정규화
);

-- 댓글 삽입 시 카운트 증가
```

---

## 7. 역정규화 주의사항

### 언제 역정규화를 고려하는가?

✅ **역정규화를 고려할 때**:
- 조회 성능이 매우 중요한 경우
- 복잡한 JOIN이 자주 발생하는 경우
- 읽기가 쓰기보다 훨씬 많은 경우
- 집계 쿼리가 자주 실행되는 경우

❌ **역정규화를 피해야 할 때**:
- 데이터 정확성이 최우선인 경우 (금융, 의료)
- 데이터 변경이 자주 발생하는 경우
- 데이터 양이 적은 경우

### 역정규화의 단점

**1. 데이터 불일치 위험**
```sql
-- 총액이 실제 상세 금액 합과 다를 수 있음
orders.total_amount ≠ SUM(order_details.price)
```

**2. 업데이트 복잡도 증가**
```sql
-- 주문 상세 수정 시 총액도 업데이트 필요
UPDATE order_details SET quantity = 3 WHERE ...;
UPDATE orders SET total_amount = ... WHERE ...;  -- 추가 작업!
```

**3. 저장 공간 증가**
- 중복 데이터 저장으로 디스크 사용량 증가

### 역정규화 대신 고려할 방법

**1. 인덱스(Index) 추가**
```sql
-- JOIN 성능 향상
CREATE INDEX idx_user_id ON posts(user_id);
```

**2. 뷰(View) 생성**
```sql
-- 자주 사용하는 JOIN 결과를 뷰로 저장
CREATE VIEW post_with_author AS
SELECT p.*, u.username
FROM posts p
JOIN users u ON p.user_id = u.user_id;
```

**3. 캐시(Cache) 활용**
- Redis 등 인메모리 DB에 자주 조회하는 데이터 캐싱

**4. 구체화된 뷰(Materialized View)**
- 뷰의 결과를 물리적으로 저장 (PostgreSQL, Oracle 지원)

---

## 실습 문제

### 문제 1: BCNF 판별하기

다음 테이블이 BCNF를 만족하는지 판별하세요.

```sql
+--------+--------+----------+
| 학생ID | 과목   | 담당조교 |
+--------+--------+----------+
| 1      | 자바   | 김조교   |
| 2      | 자바   | 김조교   |
| 1      | DB     | 이조교   |
+--------+--------+----------+
```

**조건**: 한 과목은 한 명의 조교만 담당

**질문**:
1. 기본키는 무엇인가요?
2. 어떤 종속 관계가 있나요?
3. BCNF를 위반하나요?

**답**:
1. 기본키: `(학생ID, 과목)`
2. 종속: `과목 → 담당조교` (과목이 조교를 결정)
3. 위반. `과목`이 결정자이지만 후보키가 아님

### 문제 2: 역정규화 판단하기

다음 상황에서 역정규화를 적용해야 할지 판단하세요.

**상황 1**: 은행 계좌 잔액
- 계좌 테이블에 현재 잔액을 저장할지, 매번 거래 내역을 합산할지?

**상황 2**: 블로그 조회수
- 게시글 테이블에 조회수를 저장할지, 조회 로그를 카운트할지?

**답**:
- 상황 1: 역정규화 ✓ (잔액은 자주 조회, 정확성 중요하지만 거래마다 업데이트 가능)
- 상황 2: 역정규화 ✓ (조회수는 자주 표시, 약간의 오차 허용)

### 문제 3: 역정규화 설계

다음 정규화된 테이블에 역정규화를 적용하세요.

```sql
-- 상품 테이블
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    name VARCHAR(100),
    price DECIMAL(10, 2)
);

-- 리뷰 테이블
CREATE TABLE reviews (
    review_id INT PRIMARY KEY,
    product_id INT,
    rating INT,  -- 1-5점
    comment TEXT
);
```

**요구사항**: 상품 목록에 평균 평점과 리뷰 수를 빠르게 표시

**작성할 SQL**: products 테이블에 역정규화 열 추가

**답**:
```sql
ALTER TABLE products
ADD COLUMN avg_rating DECIMAL(3, 2) DEFAULT 0,
ADD COLUMN review_count INT DEFAULT 0;
```

---

## 강사 가이드

### 핵심 포인트
1. **BCNF는 심화**: 3NF만 알아도 대부분 충분, BCNF는 개념만 이해
2. **역정규화는 트레이드오프**: 성능 vs 무결성, 상황에 따라 판단
3. **실무 중심**: 언제 역정규화를 사용하는지 실제 예시로 설명
4. **대안 제시**: 역정규화 전에 인덱스, 캐시 등 다른 방법 고려

### 자주 하는 질문

**Q: BCNF까지 꼭 정규화해야 하나요?**
A: 아님. 대부분은 3NF까지면 충분. BCNF는 특수한 경우에만 필요.

**Q: 역정규화는 나쁜 것 아닌가요?**
A: 아님. 성능을 위해 의도적으로 사용하는 기법. 단, 신중하게 적용해야 함.

**Q: 언제 역정규화를 해야 하나요?**
A: 성능 문제가 실제로 발생했을 때. 처음부터 역정규화하지 말 것.

**Q: 역정규화한 데이터는 어떻게 동기화하나요?**
A: Application 코드, Trigger, 또는 Batch Job으로 처리.

### 실습 진행 방법
1. BCNF 위반 예시로 개념 이해
2. 정규화된 테이블의 JOIN 성능 측정
3. 역정규화 적용 후 성능 비교
4. 데이터 불일치 시나리오 실습
5. 실무 사례 토론

---

## 요약

- **BCNF**: 모든 결정자가 후보키여야 함 (3NF보다 강화)
  - 예: 교수 → 과목 관계에서 교수가 결정자이지만 후보키 아님
- **3NF vs BCNF**: 대부분 동일, 복합 후보키가 겹칠 때만 차이 발생
- **역정규화**: 의도적으로 중복 허용, 조회 성능 향상
- **역정규화 기법**:
  - 테이블 통합
  - 파생 열 추가 (총액, 카운트 등)
  - 자주 사용하는 JOIN 결과 저장
- **역정규화 시점**: 성능 문제 발생 후, 조회가 많고 변경이 적을 때
- **대안**: 인덱스, 뷰, 캐시 먼저 고려

**다음 단계**: 데이터 무결성을 보장하는 제약 조건을 배웁니다!
