# 2.3. 정규화 - 1NF, 2NF, 3NF

> 데이터 중복을 제거하고, 1NF부터 3NF까지 정규화를 수행할 수 있다.

---

## 1. 정규화란?

### 정의
**정규화(Normalization)**는 데이터의 중복을 최소화하고 데이터 무결성을 보장하기 위해 테이블 구조를 재구성하는 과정입니다.

**비유로 이해하기**
```
정규화 = 정리정돈
  → 물건(데이터)을 올바른 위치에 분류하여 배치
  → 중복을 줄이고 찾기 쉽게 만듦
```

### 왜 정규화가 필요한가?

**정규화하지 않으면 발생하는 문제**:

```sql
-- 정규화되지 않은 주문 테이블
+----------+----------+----------+----------+
| 주문번호 | 고객명   | 고객전화 | 상품목록 |
+----------+----------+----------+----------+
| 1        | 홍길동   | 010-1111 | 노트북, 마우스 |
| 2        | 김영희   | 010-2222 | 키보드 |
| 3        | 홍길동   | 010-1111 | 모니터 |
+----------+----------+----------+----------+
```

**문제점**:
1. **중복**: 홍길동의 정보가 중복 저장됨
2. **수정 이상**: 홍길동의 전화번호 변경 시 모든 행을 수정해야 함
3. **삭제 이상**: 주문을 삭제하면 고객 정보도 함께 사라짐
4. **삽입 이상**: 주문 없이는 고객 정보를 저장할 수 없음

---

## 2. 데이터 무결성

정규화의 목표는 **데이터 무결성(Data Integrity)**을 보장하는 것입니다.

### 무결성의 종류

**1. 개체 무결성 (Entity Integrity)**
- 기본키는 NULL이 될 수 없음
- 각 행을 고유하게 식별해야 함

```sql
-- 올바른 예
학번(PK): 2024001  ✓
학번(PK): NULL     ✗  -- 불가능!
```

**2. 참조 무결성 (Referential Integrity)**
- 외래키 값은 참조하는 테이블의 기본키 값이거나 NULL이어야 함

```sql
-- orders 테이블
customer_id(FK): 999  ✗  -- customers 테이블에 없는 ID
customer_id(FK): 1    ✓  -- customers 테이블에 존재
customer_id(FK): NULL ✓  -- NULL도 허용
```

**3. 도메인 무결성 (Domain Integrity)**
- 열의 값은 정의된 도메인(범위) 내에 있어야 함

```sql
나이: -5      ✗  -- 음수 불가
나이: 20      ✓
나이: 999     ✗  -- 범위 초과
성별: 'M'     ✓
성별: 'X'     ✗  -- M, F만 허용
```

---

## 3. 제1정규형 (1NF): 원자값

> 테이블의 모든 열은 **원자값(Atomic Value)**, 즉 더 이상 분해할 수 없는 단일 값을 가져야 합니다.

### Before (1NF 위반)

**문제**: `자격증` 열에 여러 값이 콤마로 구분되어 저장됨

```sql
+--------+--------+------------------+
| 직원ID | 이름   | 자격증           |
+--------+--------+------------------+
| 101    | 김철수 | 정보처리기사, SQLD |
| 102    | 이영희 | DAP              |
+--------+--------+------------------+
```

**문제점**:
- 특정 자격증을 가진 직원 검색이 어려움
- 자격증 추가/삭제 시 문자열 파싱 필요

### After (1NF 만족)

**해결**: 각 행이 하나의 자격증만 가지도록 분리

```sql
+--------+--------+-------------+
| 직원ID | 이름   | 자격증      |
+--------+--------+-------------+
| 101    | 김철수 | 정보처리기사 |
| 101    | 김철수 | SQLD        |
| 102    | 이영희 | DAP         |
+--------+--------+-------------+
```

**또는 별도 테이블로 분리** (권장):

```sql
-- 직원 테이블
+--------+--------+
| 직원ID | 이름   |
+--------+--------+
| 101    | 김철수 |
| 102    | 이영희 |
+--------+--------+

-- 자격증 테이블
+--------+-------------+
| 직원ID | 자격증      |
+--------+-------------+
| 101    | 정보처리기사 |
| 101    | SQLD        |
| 102    | DAP         |
+--------+-------------+
```

### SQL 구현

```sql
-- 직원 테이블
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL
);

-- 자격증 테이블
CREATE TABLE certifications (
    cert_id INT PRIMARY KEY AUTO_INCREMENT,
    emp_id INT NOT NULL,
    cert_name VARCHAR(50) NOT NULL,
    FOREIGN KEY (emp_id) REFERENCES employees(emp_id)
);
```

---

## 4. 제2정규형 (2NF): 완전 함수 종속

> 1NF를 만족하고, **기본키의 일부에만 종속되는 열이 없어야 합니다.** (복합 기본키를 사용하는 테이블에 적용)

### 함수 종속이란?

```
A → B  (A가 B를 결정한다)

예: 학번 → 이름
    학번을 알면 이름을 알 수 있음
```

### Before (2NF 위반)

**문제**: 기본키는 `(주문번호, 제품번호)`인데, `제품명`은 `제품번호`에만 종속됨

```sql
+---------+---------+----------+------+
| 주문번호| 제품번호| 제품명   | 수량 |
+---------+---------+----------+------+
| A001    | P01     | 노트북   | 1    |
| A001    | P02     | 마우스   | 1    |
| A002    | P01     | 노트북   | 2    |
+---------+---------+----------+------+
```

**종속 관계**:
```
(주문번호, 제품번호) → 수량  ✓ (완전 함수 종속)
제품번호 → 제품명           ✓ (부분 함수 종속) ✗ 문제!
```

**문제점**:
- `제품명`이 중복 저장됨
- 제품명 변경 시 여러 행을 수정해야 함

### After (2NF 만족)

**해결**: 부분 종속 제거를 위해 테이블 분리

```sql
-- 주문상세 테이블
+---------+---------+------+
| 주문번호| 제품번호| 수량 |
+---------+---------+------+
| A001    | P01     | 1    |
| A001    | P02     | 1    |
| A002    | P01     | 2    |
+---------+---------+------+

-- 제품 테이블
+---------+--------+
| 제품번호| 제품명 |
+---------+--------+
| P01     | 노트북 |
| P02     | 마우스 |
+---------+--------+
```

### SQL 구현

```sql
-- 제품 테이블
CREATE TABLE products (
    product_id VARCHAR(10) PRIMARY KEY,
    product_name VARCHAR(50) NOT NULL
);

-- 주문상세 테이블
CREATE TABLE order_details (
    order_id VARCHAR(10),
    product_id VARCHAR(10),
    quantity INT NOT NULL,
    PRIMARY KEY (order_id, product_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);
```

---

## 5. 제3정규형 (3NF): 이행적 종속 제거

> 2NF를 만족하고, **기본키가 아닌 열들 간에 종속 관계(이행적 종속)가 없어야 합니다.**

### 이행적 종속이란?

```
A → B → C  (A가 B를 결정하고, B가 C를 결정)

예: 직원ID → 부서코드 → 부서명
```

### Before (3NF 위반)

**문제**: `부서명`이 기본키인 `직원ID`가 아닌 `부서코드`에 종속됨

```sql
+--------+--------+----------+--------+
| 직원ID | 이름   | 부서코드 | 부서명 |
+--------+--------+----------+--------+
| 101    | 김철수 | D01      | 인사팀 |
| 102    | 이영희 | D02      | 개발팀 |
| 103    | 박민준 | D01      | 인사팀 |
+--------+--------+----------+--------+
```

**종속 관계**:
```
직원ID → 부서코드  ✓
부서코드 → 부서명  ✓
직원ID → 부서명    ✓ (이행적 종속) ✗ 문제!
```

**문제점**:
- `부서명`이 중복 저장됨
- 부서명 변경 시 여러 행을 수정해야 함

### After (3NF 만족)

**해결**: 이행적 종속 제거를 위해 테이블 분리

```sql
-- 직원 테이블
+--------+--------+----------+
| 직원ID | 이름   | 부서코드 |
+--------+--------+----------+
| 101    | 김철수 | D01      |
| 102    | 이영희 | D02      |
| 103    | 박민준 | D01      |
+--------+--------+----------+

-- 부서 테이블
+----------+--------+
| 부서코드 | 부서명 |
+----------+--------+
| D01      | 인사팀 |
| D02      | 개발팀 |
+----------+--------+
```

### SQL 구현

```sql
-- 부서 테이블
CREATE TABLE departments (
    dept_code VARCHAR(10) PRIMARY KEY,
    dept_name VARCHAR(50) NOT NULL
);

-- 직원 테이블
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    dept_code VARCHAR(10),
    FOREIGN KEY (dept_code) REFERENCES departments(dept_code)
);
```

---

## 6. 정규화 단계 요약

```
정규화되지 않은 테이블
    ↓
【1NF】 원자값 확보
    → 반복되는 그룹 제거
    → 각 열은 단일 값만
    ↓
【2NF】 부분 종속 제거
    → 복합키의 일부에만 종속된 열 분리
    ↓
【3NF】 이행적 종속 제거
    → 기본키가 아닌 열 간 종속 제거
    ↓
정규화된 테이블
```

---

## 실습 문제

### 문제 1: 1NF 적용하기

다음 테이블을 1NF로 변환하세요.

```sql
+--------+--------+------------------+
| 학생ID | 이름   | 수강과목         |
+--------+--------+------------------+
| 1      | 홍길동 | 자바, 데이터베이스|
| 2      | 김영희 | 파이썬           |
+--------+--------+------------------+
```

**작성할 SQL**:
```sql
-- 학생 테이블


-- 수강 테이블
```

**예상 답**:
```sql
-- 학생 테이블
CREATE TABLE students (
    student_id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL
);

-- 수강 테이블
CREATE TABLE enrollments (
    enrollment_id INT PRIMARY KEY AUTO_INCREMENT,
    student_id INT NOT NULL,
    subject VARCHAR(50) NOT NULL,
    FOREIGN KEY (student_id) REFERENCES students(student_id)
);
```

### 문제 2: 2NF 적용하기

다음 테이블의 기본키는 `(학생ID, 과목코드)`입니다. 2NF로 변환하세요.

```sql
+---------+----------+----------+----------+------+
| 학생ID  | 과목코드 | 과목명   | 담당교수 | 성적 |
+---------+----------+----------+----------+------+
| 1       | CS101    | 자바     | 김교수   | A    |
| 1       | CS102    | DB       | 이교수   | B    |
| 2       | CS101    | 자바     | 김교수   | A+   |
+---------+----------+----------+----------+------+
```

**힌트**: 과목명과 담당교수는 과목코드에만 종속됩니다.

**예상 답**:
```sql
-- 과목 테이블
CREATE TABLE subjects (
    subject_code VARCHAR(10) PRIMARY KEY,
    subject_name VARCHAR(50) NOT NULL,
    professor VARCHAR(50) NOT NULL
);

-- 성적 테이블
CREATE TABLE grades (
    student_id INT,
    subject_code VARCHAR(10),
    grade VARCHAR(2),
    PRIMARY KEY (student_id, subject_code),
    FOREIGN KEY (subject_code) REFERENCES subjects(subject_code)
);
```

### 문제 3: 3NF 적용하기

다음 테이블을 3NF로 변환하세요.

```sql
+----------+--------+--------+----------+--------+
| 주문번호 | 고객ID | 고객명 | 고객등급 | 할인율 |
+----------+--------+--------+----------+--------+
| 1        | C001   | 홍길동 | Gold     | 10%    |
| 2        | C002   | 김영희 | Silver   | 5%     |
| 3        | C001   | 홍길동 | Gold     | 10%    |
+----------+--------+--------+----------+--------+
```

**종속 관계**:
```
주문번호 → 고객ID → 고객명, 고객등급
고객등급 → 할인율
```

**작성할 테이블**: 주문, 고객, 등급

**예상 답**:
```sql
-- 등급 테이블
CREATE TABLE membership_tiers (
    tier_name VARCHAR(20) PRIMARY KEY,
    discount_rate DECIMAL(5, 2) NOT NULL
);

-- 고객 테이블
CREATE TABLE customers (
    customer_id VARCHAR(10) PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    tier_name VARCHAR(20),
    FOREIGN KEY (tier_name) REFERENCES membership_tiers(tier_name)
);

-- 주문 테이블
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id VARCHAR(10) NOT NULL,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);
```

### 문제 4: 종합 문제

다음 정규화되지 않은 주문 테이블을 3NF까지 정규화하세요.

```sql
+----------+--------+--------+----------+------------------+---------+
| 주문번호 | 고객명 | 고객주소| 상품목록 | 상품가격         | 총금액  |
+----------+--------+--------+----------+------------------+---------+
| 1        | 홍길동 | 서울   | 노트북,마우스 | 1500000,25000 | 1525000|
| 2        | 김영희 | 부산   | 키보드   | 50000            | 50000  |
+----------+--------+--------+----------+------------------+---------+
```

**단계별로 정규화하세요**:
1. 1NF: 원자값 확보
2. 2NF: 부분 종속 제거
3. 3NF: 이행적 종속 제거

---

## 강사 가이드

### 핵심 포인트
1. **단계적 설명**: 1NF → 2NF → 3NF 순서대로 차근차근
2. **Before/After 비교**: 정규화 전후를 명확히 대비
3. **문제점 강조**: 왜 정규화가 필요한지 이상 현상 예시로 설명
4. **실습 중심**: 실제 테이블을 정규화하며 개념 체화

### 자주 하는 질문

**Q: 항상 3NF까지 정규화해야 하나요?**
A: 일반적으로 3NF까지 권장. 하지만 성능을 위해 의도적으로 역정규화하는 경우도 있음.

**Q: 정규화하면 테이블이 너무 많아지는데요?**
A: 맞음. 하지만 JOIN을 통해 필요한 데이터를 조합할 수 있고, 데이터 무결성이 더 중요.

**Q: 2NF는 언제 적용하나요?**
A: 복합 기본키를 사용하는 테이블에만 적용. 단일 기본키면 1NF → 3NF로 바로 이동 가능.

**Q: 실무에서 정규화를 얼마나 엄격하게 하나요?**
A: 초기 설계는 3NF까지, 이후 성능 문제 발생 시 선택적으로 역정규화.

### 실습 진행 방법
1. 정규화되지 않은 테이블 예시 제시
2. 발생하는 문제점 함께 찾기
3. 단계별로 정규화 진행
4. SQL로 테이블 생성 및 데이터 삽입
5. JOIN 쿼리로 원래 형태 복원 실습

---

## 요약

- **정규화**: 데이터 중복 제거, 무결성 보장을 위한 테이블 재구성
- **데이터 무결성**: 개체 무결성, 참조 무결성, 도메인 무결성
- **1NF (원자값)**: 각 열은 더 이상 분해할 수 없는 단일 값
  - 예: `자격증: "정보처리기사, SQLD"` → 별도 행으로 분리
- **2NF (완전 함수 종속)**: 복합키의 일부에만 종속된 열 제거
  - 예: `(주문번호, 제품번호)` 중 제품명은 제품번호에만 종속
- **3NF (이행적 종속 제거)**: 기본키가 아닌 열 간 종속 제거
  - 예: `직원ID → 부서코드 → 부서명` 이행 종속 제거
- **정규화 순서**: 비정규화 → 1NF → 2NF → 3NF

**다음 단계**: BCNF와 실무에서 사용하는 역정규화 기법을 배웁니다!
