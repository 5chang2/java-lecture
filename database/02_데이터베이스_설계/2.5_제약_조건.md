# 2.5. 제약 조건 (PRIMARY KEY, FOREIGN KEY, UNIQUE, NOT NULL)

> 데이터 무결성을 보장하는 다양한 제약 조건을 설정할 수 있다.

---

## 1. 제약 조건이란?

### 정의
**제약 조건(Constraint)**은 테이블에 저장되는 데이터의 **정확성과 일관성을 보장**하기 위한 규칙입니다.

**비유로 이해하기**
```
제약 조건 = 입장 규칙
  → 영화관: 19세 이상만 입장 가능 (나이 제약)
  → DB: 특정 조건을 만족하는 데이터만 저장 가능
```

### 왜 제약 조건이 필요한가?

**제약 조건 없이 데이터를 저장하면**:
```sql
-- 학생 테이블에 이상한 데이터 삽입 가능
INSERT INTO students (student_id, name, age) VALUES
(NULL, '홍길동', 20),      -- 학번이 NULL?
(1, '김영희', 20),
(1, '이철수', -5);          -- 중복 학번, 음수 나이?
```

**제약 조건으로 방지**:
```sql
CREATE TABLE students (
    student_id INT PRIMARY KEY,      -- NULL 불가, 중복 불가
    name VARCHAR(50) NOT NULL,       -- NULL 불가
    age INT CHECK (age >= 0),        -- 0 이상만 허용
    email VARCHAR(100) UNIQUE        -- 중복 불가
);
```

---

## 2. PRIMARY KEY (기본키)

### 정의
테이블에서 **각 행을 고유하게 식별**하는 열입니다.

### 특징
```
✓ NOT NULL: NULL 값을 가질 수 없음
✓ UNIQUE: 중복된 값을 가질 수 없음
✓ 테이블당 하나만: 하나의 테이블은 하나의 기본키만 가짐
```

### 사용 방법

**1. 열 정의 시 지정**
```sql
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    username VARCHAR(50) NOT NULL
);
```

**2. 테이블 정의 마지막에 지정**
```sql
CREATE TABLE users (
    user_id INT,
    username VARCHAR(50) NOT NULL,
    PRIMARY KEY (user_id)
);
```

**3. 복합 기본키 (여러 열 조합)**
```sql
CREATE TABLE order_details (
    order_id INT,
    product_id INT,
    quantity INT,
    PRIMARY KEY (order_id, product_id)  -- 복합키
);
```

### AUTO_INCREMENT

기본키를 자동으로 증가시키는 옵션입니다.

```sql
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,  -- 자동 증가
    username VARCHAR(50) NOT NULL
);

-- 데이터 삽입 시 user_id 생략 가능
INSERT INTO users (username) VALUES ('홍길동');  -- user_id = 1
INSERT INTO users (username) VALUES ('김영희');  -- user_id = 2
```

**데이터 확인**:
```sql
SELECT * FROM users;
+--------+-----------+
|user_id | username  |
+--------+-----------+
| 1      | 홍길동    |
| 2      | 김영희    |
+--------+-----------+
```

---

## 3. FOREIGN KEY (외래키)

### 정의
다른 테이블의 기본키를 참조하여 **테이블 간의 관계**를 설정하는 열입니다.

### 특징
```
✓ 참조 무결성: 외래키 값은 참조하는 테이블의 기본키 값이거나 NULL
✓ 관계 설정: 1:N, N:M 관계 구현
```

### 사용 방법

**기본 문법**:
```sql
CREATE TABLE posts (
    post_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255) NOT NULL,
    user_id INT,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

**외래키 이름 지정**:
```sql
CREATE TABLE posts (
    post_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255) NOT NULL,
    user_id INT,
    CONSTRAINT fk_user
        FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

### 참조 무결성 확인

**올바른 삽입**:
```sql
-- users 테이블에 user_id=1 존재
INSERT INTO posts (title, user_id) VALUES ('첫 글', 1);  -- ✓ 성공
```

**잘못된 삽입**:
```sql
-- users 테이블에 user_id=999 없음
INSERT INTO posts (title, user_id) VALUES ('글', 999);  -- ✗ 에러!
-- Error: Cannot add or update a child row: a foreign key constraint fails
```

### ON DELETE, ON UPDATE 옵션

외래키로 참조된 데이터가 삭제/수정될 때의 동작을 지정합니다.

**옵션 종류**:
- **CASCADE**: 참조된 행이 삭제/수정되면 함께 삭제/수정
- **SET NULL**: 참조된 행이 삭제/수정되면 NULL로 설정
- **RESTRICT**: 참조된 행이 삭제/수정되는 것을 금지 (기본값)
- **NO ACTION**: RESTRICT와 동일

**예시**:
```sql
CREATE TABLE posts (
    post_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255) NOT NULL,
    user_id INT,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
        ON DELETE CASCADE    -- 사용자 삭제 시 게시글도 삭제
        ON UPDATE CASCADE    -- 사용자 ID 변경 시 함께 변경
);
```

**CASCADE 동작**:
```sql
-- users 테이블
+--------+-----------+
|user_id | username  |
+--------+-----------+
| 1      | 홍길동    |
+--------+-----------+

-- posts 테이블
+--------+--------+--------+
|post_id | title  |user_id |
+--------+--------+--------+
| 1      | 첫 글  | 1      |
| 2      | 둘째글 | 1      |
+--------+--------+--------+

-- 사용자 삭제
DELETE FROM users WHERE user_id = 1;

-- posts 테이블 (CASCADE로 함께 삭제됨)
+--------+-------+--------+
|post_id | title |user_id |
+--------+-------+--------+
(Empty)
+--------+-------+--------+
```

**SET NULL 동작**:
```sql
CREATE TABLE posts (
    post_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255) NOT NULL,
    user_id INT,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
        ON DELETE SET NULL   -- 사용자 삭제 시 NULL로 설정
);

-- 사용자 삭제 후
+--------+--------+--------+
|post_id | title  |user_id |
+--------+--------+--------+
| 1      | 첫 글  | NULL   |
| 2      | 둘째글 | NULL   |
+--------+--------+--------+
```

---

## 4. UNIQUE (유일성)

### 정의
열의 값이 **중복되지 않도록** 보장합니다.

### 특징
```
✓ 중복 불가: 같은 값이 두 번 저장될 수 없음
✓ NULL 허용: PRIMARY KEY와 달리 NULL은 허용 (MySQL은 여러 개 NULL 가능)
✓ 여러 개 가능: 테이블에 여러 UNIQUE 제약 조건 설정 가능
```

### 사용 방법

**1. 열 정의 시 지정**:
```sql
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE  -- 이메일 중복 불가
);
```

**2. 테이블 정의 마지막에 지정**:
```sql
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100),
    UNIQUE (email)
);
```

**3. 복합 UNIQUE (여러 열 조합)**:
```sql
CREATE TABLE course_enrollments (
    enrollment_id INT PRIMARY KEY AUTO_INCREMENT,
    student_id INT,
    course_id INT,
    UNIQUE (student_id, course_id)  -- 같은 학생이 같은 과목 중복 수강 방지
);
```

### 동작 확인

```sql
-- 올바른 삽입
INSERT INTO users (username, email) VALUES ('홍길동', 'hong@email.com');  -- ✓
INSERT INTO users (username, email) VALUES ('김영희', 'kim@email.com');    -- ✓

-- 잘못된 삽입
INSERT INTO users (username, email) VALUES ('이철수', 'hong@email.com');  -- ✗ 에러!
-- Error: Duplicate entry 'hong@email.com' for key 'email'
```

---

## 5. NOT NULL (필수 값)

### 정의
열의 값이 **NULL이 될 수 없도록** 보장합니다.

### 특징
```
✓ NULL 불가: 반드시 값이 있어야 함
✓ 기본값: 별도 지정 없으면 NULL 허용
```

### 사용 방법

```sql
CREATE TABLE products (
    product_id INT PRIMARY KEY AUTO_INCREMENT,
    product_name VARCHAR(100) NOT NULL,  -- 필수
    price DECIMAL(10, 2) NOT NULL,       -- 필수
    description TEXT                     -- NULL 허용 (생략 가능)
);
```

### 동작 확인

```sql
-- 올바른 삽입
INSERT INTO products (product_name, price) VALUES ('노트북', 1500000);  -- ✓

-- 잘못된 삽입
INSERT INTO products (product_name) VALUES ('마우스');  -- ✗ 에러!
-- Error: Field 'price' doesn't have a default value
```

---

## 6. CHECK (값 범위 제한)

### 정의
열의 값이 **특정 조건을 만족**하도록 제한합니다.

### 특징
```
✓ 조건 지정: WHERE 절과 유사한 조건식 사용
✓ MySQL 8.0.16+: MySQL 8.0.16 이상부터 지원
```

### 사용 방법

**1. 단순 조건**:
```sql
CREATE TABLE students (
    student_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    age INT CHECK (age >= 0 AND age <= 150),  -- 0~150 사이
    gender CHAR(1) CHECK (gender IN ('M', 'F'))  -- M 또는 F만
);
```

**2. 이름 지정**:
```sql
CREATE TABLE products (
    product_id INT PRIMARY KEY AUTO_INCREMENT,
    product_name VARCHAR(100) NOT NULL,
    price DECIMAL(10, 2),
    stock INT,
    CONSTRAINT chk_price CHECK (price > 0),
    CONSTRAINT chk_stock CHECK (stock >= 0)
);
```

### 동작 확인

```sql
-- 올바른 삽입
INSERT INTO students (name, age, gender) VALUES ('홍길동', 20, 'M');  -- ✓

-- 잘못된 삽입
INSERT INTO students (name, age, gender) VALUES ('김영희', -5, 'F');  -- ✗ 에러!
-- Error: Check constraint 'students_chk_1' is violated.

INSERT INTO students (name, age, gender) VALUES ('이철수', 20, 'X');  -- ✗ 에러!
-- Error: Check constraint 'students_chk_2' is violated.
```

---

## 7. DEFAULT (기본값)

### 정의
값이 입력되지 않을 때 **자동으로 설정되는 기본값**입니다.

### 사용 방법

```sql
CREATE TABLE posts (
    post_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,  -- 현재 시간
    view_count INT DEFAULT 0,                        -- 기본값 0
    is_published BOOLEAN DEFAULT FALSE               -- 기본값 FALSE
);
```

### 동작 확인

```sql
-- created_at, view_count, is_published 생략
INSERT INTO posts (title, content) VALUES ('제목', '내용');

-- 결과
+--------+------+------+--------------------+-----------+-------------+
|post_id |title |content|created_at         |view_count |is_published |
+--------+------+------+--------------------+-----------+-------------+
| 1      |제목  |내용  |2024-01-20 10:30:00 | 0         | 0           |
+--------+------+------+--------------------+-----------+-------------+
```

---

## 8. 제약 조건 조합 예시

### 완전한 테이블 설계

```sql
-- 회원 테이블
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    age INT CHECK (age >= 14),  -- 14세 이상만 가입
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 게시글 테이블
CREATE TABLE posts (
    post_id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    view_count INT DEFAULT 0 CHECK (view_count >= 0),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
        ON DELETE CASCADE
        ON UPDATE CASCADE
);

-- 댓글 테이블
CREATE TABLE comments (
    comment_id INT PRIMARY KEY AUTO_INCREMENT,
    post_id INT NOT NULL,
    user_id INT NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (post_id) REFERENCES posts(post_id)
        ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
        ON DELETE CASCADE
);
```

---

## 실습 문제

### 문제 1: 제약 조건 설정하기

다음 요구사항에 맞는 테이블을 생성하세요.

**요구사항**: 직원 관리 시스템
- 직원번호는 자동 증가, 기본키
- 이름은 필수, 50자 이내
- 이메일은 필수, 중복 불가
- 나이는 18세 이상 65세 이하
- 입사일은 자동으로 현재 날짜 설정

**작성할 SQL**:
```sql
CREATE TABLE employees (
    -- 여기에 코드 작성
);
```

**예상 답**:
```sql
CREATE TABLE employees (
    emp_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE,
    age INT CHECK (age >= 18 AND age <= 65),
    hire_date DATE DEFAULT (CURRENT_DATE)
);
```

### 문제 2: 외래키 설정하기

다음 두 테이블의 관계를 설정하세요.

```sql
-- 부서 테이블
CREATE TABLE departments (
    dept_id INT PRIMARY KEY AUTO_INCREMENT,
    dept_name VARCHAR(50) NOT NULL
);

-- 직원 테이블 (부서 정보 추가)
CREATE TABLE employees (
    emp_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    dept_id INT,
    -- 외래키 설정
);
```

**요구사항**:
- 직원은 부서에 속함
- 부서 삭제 시 해당 부서의 직원 dept_id를 NULL로 설정

**답**:
```sql
CREATE TABLE employees (
    emp_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    dept_id INT,
    FOREIGN KEY (dept_id) REFERENCES departments(dept_id)
        ON DELETE SET NULL
);
```

### 문제 3: 제약 조건 문제 찾기

다음 SQL에서 잘못된 점을 찾으세요.

```sql
CREATE TABLE products (
    product_id INT,
    product_name VARCHAR(100),
    price DECIMAL(10, 2),
    stock INT DEFAULT -10
);
```

**문제점**:
1. product_id에 PRIMARY KEY 없음
2. product_name에 NOT NULL 없음
3. stock 기본값이 음수

**수정된 SQL**:
```sql
CREATE TABLE products (
    product_id INT PRIMARY KEY AUTO_INCREMENT,
    product_name VARCHAR(100) NOT NULL,
    price DECIMAL(10, 2) CHECK (price > 0),
    stock INT DEFAULT 0 CHECK (stock >= 0)
);
```

---

## 강사 가이드

### 핵심 포인트
1. **실제 에러 보여주기**: 제약 조건 위반 시 발생하는 에러 메시지 직접 확인
2. **CASCADE 주의**: ON DELETE CASCADE는 신중하게 사용해야 함
3. **제약 조건 조합**: 실무에서는 여러 제약 조건을 함께 사용
4. **기본값 활용**: DEFAULT로 코드 간소화

### 자주 하는 질문

**Q: PRIMARY KEY와 UNIQUE의 차이는?**
A: PRIMARY KEY는 NULL 불가, 테이블당 하나만. UNIQUE는 NULL 허용, 여러 개 가능.

**Q: ON DELETE CASCADE는 언제 사용하나요?**
A: 부모 데이터 삭제 시 자식 데이터도 삭제해도 되는 경우. (예: 게시글 삭제 시 댓글도 삭제)

**Q: CHECK 제약 조건이 작동하지 않아요.**
A: MySQL 8.0.16 이전 버전은 CHECK를 무시함. 버전 확인 필요.

**Q: 제약 조건을 나중에 추가할 수 있나요?**
A: 가능. ALTER TABLE 문으로 추가/삭제 가능.

### 실습 진행 방법
1. 제약 조건 없이 테이블 생성
2. 잘못된 데이터 삽입 시도
3. 제약 조건 추가
4. 다시 잘못된 데이터 삽입 시도 (에러 확인)
5. 실제 프로젝트 테이블에 제약 조건 설계

---

## 요약

- **PRIMARY KEY**: 기본키, NULL 불가, 중복 불가, 테이블당 하나
  - AUTO_INCREMENT로 자동 증가 가능
- **FOREIGN KEY**: 외래키, 테이블 간 관계 설정, 참조 무결성 보장
  - ON DELETE/UPDATE CASCADE, SET NULL, RESTRICT
- **UNIQUE**: 유일성, 중복 불가, NULL 허용, 여러 개 가능
- **NOT NULL**: 필수 값, NULL 불가
- **CHECK**: 값 범위 제한 (MySQL 8.0.16+)
- **DEFAULT**: 기본값 설정
- **제약 조건 조합**: 실무에서는 여러 제약 조건을 함께 사용하여 데이터 무결성 보장

**다음 단계**: 지금까지 배운 내용을 종합하여 실습 프로젝트를 진행합니다!
