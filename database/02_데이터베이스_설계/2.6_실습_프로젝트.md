# 2.6. 실습: 데이터베이스 설계 프로젝트

> 실제 시나리오를 바탕으로 ERD 작성부터 테이블 구현까지 전체 데이터베이스 설계 과정을 수행할 수 있다.

---

## 1. 프로젝트 개요

이 실습에서는 **도서관 관리 시스템**을 설계하고 구현합니다. 지금까지 배운 모든 개념을 종합적으로 적용하는 프로젝트입니다.

### 적용할 개념
- ERD 작성 (개체, 속성, 관계)
- 테이블 관계 설정 (1:1, 1:N, N:M)
- 정규화 (1NF ~ 3NF)
- 제약 조건 (PRIMARY KEY, FOREIGN KEY, UNIQUE, NOT NULL, CHECK, DEFAULT)

---

## 2. 요구사항 분석

### 도서관 시스템 요구사항

**회원 관리**
- 회원은 회원번호, 이름, 이메일, 전화번호, 가입일 정보를 가진다
- 이메일은 중복될 수 없다
- 회원은 여러 권의 책을 대출할 수 있다

**도서 관리**
- 도서는 ISBN, 제목, 출판사, 출판일, 가격 정보를 가진다
- ISBN은 도서를 고유하게 식별한다
- 한 권의 책은 여러 저자가 쓸 수 있다
- 한 저자는 여러 권의 책을 쓸 수 있다

**저자 관리**
- 저자는 저자번호, 이름, 국적 정보를 가진다

**대출 관리**
- 대출은 대출번호, 대출일, 반납예정일, 실제반납일 정보를 가진다
- 한 대출 기록은 한 명의 회원과 한 권의 책에 대한 것이다
- 대출일은 자동으로 현재 날짜가 입력된다
- 반납예정일은 대출일로부터 14일 후이다

---

## 3. 단계별 설계 과정

### 3.1. 개체 식별

요구사항에서 **명사**를 찾아 개체를 식별합니다.

```
📦 개체(Entity)
- 회원 (Member)
- 도서 (Book)
- 저자 (Author)
- 대출 (Loan)
```

### 3.2. 속성 식별

각 개체의 **속성**을 나열합니다.

```
회원 (Member)
- 회원번호 (member_id) [PK]
- 이름 (name)
- 이메일 (email) [UNIQUE]
- 전화번호 (phone)
- 가입일 (join_date)

도서 (Book)
- ISBN [PK]
- 제목 (title)
- 출판사 (publisher)
- 출판일 (publish_date)
- 가격 (price)

저자 (Author)
- 저자번호 (author_id) [PK]
- 이름 (name)
- 국적 (nationality)

대출 (Loan)
- 대출번호 (loan_id) [PK]
- 대출일 (loan_date)
- 반납예정일 (due_date)
- 실제반납일 (return_date)
- 회원번호 (member_id) [FK]
- ISBN [FK]
```

### 3.3. 관계 식별

개체 간의 **관계**를 파악합니다.

```
관계 정의:
1. 회원 --- 대출 (1:N)
   - 한 회원은 여러 대출 기록을 가질 수 있다
   - 한 대출은 한 명의 회원에 속한다

2. 도서 --- 대출 (1:N)
   - 한 도서는 여러 번 대출될 수 있다
   - 한 대출은 한 권의 도서에 대한 것이다

3. 저자 --- 도서 (N:M)
   - 한 저자는 여러 도서를 집필할 수 있다
   - 한 도서는 여러 저자가 공동 집필할 수 있다
   → 중간 테이블 필요: book_authors
```

### 3.4. ERD 작성

Crow's Foot Notation으로 ERD를 표현합니다.

```
         1         N
Member |-------< Loan >-------| Book
                               |
                               |
                               | N
                               |
                       book_authors
                               |
                               | N
                               |
                            Author
```

**텍스트 기반 ERD 상세**:
```
[Member]
- member_id (PK)
- name
- email (UNIQUE)
- phone
- join_date

[Book]
- isbn (PK)
- title
- publisher
- publish_date
- price

[Author]
- author_id (PK)
- name
- nationality

[Loan]
- loan_id (PK)
- member_id (FK → Member)
- isbn (FK → Book)
- loan_date
- due_date
- return_date

[book_authors]
- book_author_id (PK)
- isbn (FK → Book)
- author_id (FK → Author)
- author_order (저자 순서)
```

---

## 4. 테이블 구현

### 4.1. 회원 테이블

```sql
CREATE TABLE members (
    member_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE,
    phone VARCHAR(20),
    join_date DATE DEFAULT (CURRENT_DATE)
);
```

**제약 조건 설명**:
- `member_id`: 자동 증가 기본키
- `email`: UNIQUE - 중복 가입 방지
- `join_date`: DEFAULT - 자동으로 현재 날짜 입력

### 4.2. 저자 테이블

```sql
CREATE TABLE authors (
    author_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    nationality VARCHAR(50)
);
```

### 4.3. 도서 테이블

```sql
CREATE TABLE books (
    isbn VARCHAR(13) PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    publisher VARCHAR(100) NOT NULL,
    publish_date DATE,
    price DECIMAL(10, 2) CHECK (price >= 0)
);
```

**제약 조건 설명**:
- `isbn`: 13자리 문자열 (국제 표준 도서 번호)
- `price`: CHECK - 음수 가격 방지

### 4.4. 도서-저자 중간 테이블 (N:M 해소)

```sql
CREATE TABLE book_authors (
    book_author_id INT PRIMARY KEY AUTO_INCREMENT,
    isbn VARCHAR(13) NOT NULL,
    author_id INT NOT NULL,
    author_order INT DEFAULT 1,  -- 공동 저자 순서
    FOREIGN KEY (isbn) REFERENCES books(isbn)
        ON DELETE CASCADE,
    FOREIGN KEY (author_id) REFERENCES authors(author_id)
        ON DELETE CASCADE,
    UNIQUE (isbn, author_id)  -- 같은 책에 같은 저자 중복 방지
);
```

**핵심 포인트**:
- `author_order`: 공동 저자일 경우 순서 표시 (제1저자, 제2저자 등)
- `CASCADE`: 도서나 저자가 삭제되면 관계도 자동 삭제
- `UNIQUE (isbn, author_id)`: 복합 유니크 제약 조건

### 4.5. 대출 테이블

```sql
CREATE TABLE loans (
    loan_id INT PRIMARY KEY AUTO_INCREMENT,
    member_id INT NOT NULL,
    isbn VARCHAR(13) NOT NULL,
    loan_date DATE DEFAULT (CURRENT_DATE),
    due_date DATE NOT NULL,
    return_date DATE,
    FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE,
    FOREIGN KEY (isbn) REFERENCES books(isbn)
        ON DELETE RESTRICT,  -- 대출 중인 책은 삭제 불가
    CHECK (due_date > loan_date),
    CHECK (return_date IS NULL OR return_date >= loan_date)
);
```

**제약 조건 설명**:
- `ON DELETE RESTRICT`: 대출 중인 책은 삭제할 수 없음 (데이터 보호)
- `CHECK (due_date > loan_date)`: 반납예정일은 대출일 이후여야 함
- `CHECK (return_date >= loan_date)`: 실제반납일은 대출일 이후여야 함
- `return_date`: NULL 허용 - 아직 반납하지 않은 경우

---

## 5. 샘플 데이터 삽입

### 5.1. 회원 데이터

```sql
INSERT INTO members (name, email, phone) VALUES
('김철수', 'kim@email.com', '010-1234-5678'),
('이영희', 'lee@email.com', '010-2345-6789'),
('박민수', 'park@email.com', '010-3456-7890');
```

### 5.2. 저자 데이터

```sql
INSERT INTO authors (name, nationality) VALUES
('박경리', '한국'),
('조정래', '한국'),
('헤밍웨이', '미국'),
('무라카미 하루키', '일본');
```

### 5.3. 도서 데이터

```sql
INSERT INTO books (isbn, title, publisher, publish_date, price) VALUES
('9788936433598', '토지', '마로니에북스', '2012-01-01', 15000.00),
('9788936434489', '태백산맥', '한길사', '2013-05-01', 18000.00),
('9788937460012', '노인과 바다', '민음사', '2012-03-01', 12000.00),
('9788954620154', '1Q84', '문학동네', '2014-07-01', 20000.00);
```

### 5.4. 도서-저자 관계 데이터

```sql
INSERT INTO book_authors (isbn, author_id, author_order) VALUES
('9788936433598', 1, 1),  -- 토지 - 박경리
('9788936434489', 2, 1),  -- 태백산맥 - 조정래
('9788937460012', 3, 1),  -- 노인과 바다 - 헤밍웨이
('9788954620154', 4, 1);  -- 1Q84 - 무라카미 하루키
```

### 5.5. 대출 데이터

```sql
-- 대출일로부터 14일 후를 반납예정일로 계산
INSERT INTO loans (member_id, isbn, loan_date, due_date, return_date) VALUES
(1, '9788936433598', '2025-01-01', '2025-01-15', '2025-01-14'),  -- 반납 완료
(1, '9788937460012', '2025-01-10', '2025-01-24', NULL),           -- 대출 중
(2, '9788936434489', '2025-01-05', '2025-01-19', NULL),           -- 대출 중
(3, '9788954620154', '2025-01-08', '2025-01-22', NULL);           -- 대출 중
```

---

## 6. 유용한 쿼리 예시

### 6.1. 특정 회원의 대출 이력 조회

```sql
SELECT
    m.name AS 회원명,
    b.title AS 도서명,
    l.loan_date AS 대출일,
    l.due_date AS 반납예정일,
    l.return_date AS 실제반납일,
    CASE
        WHEN l.return_date IS NULL THEN '대출 중'
        WHEN l.return_date > l.due_date THEN '연체 반납'
        ELSE '정상 반납'
    END AS 반납상태
FROM loans l
JOIN members m ON l.member_id = m.member_id
JOIN books b ON l.isbn = b.isbn
WHERE m.member_id = 1;
```

### 6.2. 현재 대출 중인 도서 목록

```sql
SELECT
    b.title AS 도서명,
    m.name AS 대출자,
    l.loan_date AS 대출일,
    l.due_date AS 반납예정일,
    DATEDIFF(l.due_date, CURRENT_DATE) AS 남은일수
FROM loans l
JOIN books b ON l.isbn = b.isbn
JOIN members m ON l.member_id = m.member_id
WHERE l.return_date IS NULL;
```

### 6.3. 특정 도서의 저자 정보 조회

```sql
SELECT
    b.title AS 도서명,
    a.name AS 저자명,
    a.nationality AS 국적,
    ba.author_order AS 저자순서
FROM books b
JOIN book_authors ba ON b.isbn = ba.isbn
JOIN authors a ON ba.author_id = a.author_id
WHERE b.isbn = '9788936433598'
ORDER BY ba.author_order;
```

### 6.4. 연체 중인 대출 목록

```sql
SELECT
    m.name AS 회원명,
    m.email AS 이메일,
    b.title AS 도서명,
    l.due_date AS 반납예정일,
    DATEDIFF(CURRENT_DATE, l.due_date) AS 연체일수
FROM loans l
JOIN members m ON l.member_id = m.member_id
JOIN books b ON l.isbn = b.isbn
WHERE l.return_date IS NULL
  AND l.due_date < CURRENT_DATE
ORDER BY l.due_date;
```

### 6.5. 회원별 대출 통계

```sql
SELECT
    m.name AS 회원명,
    COUNT(*) AS 총대출횟수,
    SUM(CASE WHEN l.return_date IS NULL THEN 1 ELSE 0 END) AS 대출중,
    SUM(CASE WHEN l.return_date IS NOT NULL THEN 1 ELSE 0 END) AS 반납완료
FROM members m
LEFT JOIN loans l ON m.member_id = l.member_id
GROUP BY m.member_id, m.name
ORDER BY 총대출횟수 DESC;
```

---

## 7. 실습 문제

### 문제 1: 데이터베이스 생성 및 테이블 구현

위의 설계를 바탕으로 다음을 수행하세요.

1. `library_db` 데이터베이스 생성
2. 5개 테이블 모두 생성 (members, authors, books, book_authors, loans)
3. 샘플 데이터 삽입

**힌트**:
```sql
CREATE DATABASE library_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE library_db;

-- 여기에 테이블 생성 SQL 작성
```

### 문제 2: 추가 요구사항 구현

다음 요구사항을 반영하여 테이블을 수정하세요.

**요구사항**:
- 도서에 **재고 수량(stock)** 필드 추가
- 재고는 0 이상이어야 함
- 기본값은 5

**작성할 SQL**:
```sql
-- ALTER TABLE 사용


```

**예상 답**:
```sql
ALTER TABLE books
ADD COLUMN stock INT DEFAULT 5 CHECK (stock >= 0);
```

### 문제 3: 복잡한 조회 쿼리 작성

다음 질문에 답하는 SQL 쿼리를 작성하세요.

**질문 1**: 가장 많이 대출된 도서는 무엇인가요? (상위 3개)

```sql
-- 여기에 SQL 작성


```

**질문 2**: 대출 이력이 없는 회원은 누구인가요?

```sql
-- 여기에 SQL 작성


```

**예상 답 1**:
```sql
SELECT
    b.title AS 도서명,
    COUNT(l.loan_id) AS 대출횟수
FROM books b
LEFT JOIN loans l ON b.isbn = l.isbn
GROUP BY b.isbn, b.title
ORDER BY 대출횟수 DESC
LIMIT 3;
```

**예상 답 2**:
```sql
SELECT
    m.name AS 회원명,
    m.email
FROM members m
LEFT JOIN loans l ON m.member_id = l.member_id
WHERE l.loan_id IS NULL;
```

### 문제 4: 정규화 검증

현재 설계가 3NF를 만족하는지 검증하세요.

**검증 항목**:
1. 모든 속성이 원자값인가? (1NF)
2. 부분 함수 종속이 없는가? (2NF)
3. 이행적 함수 종속이 없는가? (3NF)

**예상 답**:
```
✅ 1NF 만족: 모든 속성이 원자값
   - 전화번호, 이메일 등 모두 분리 불가능한 단일 값

✅ 2NF 만족: 모든 기본키가 단일 속성이므로 부분 함수 종속 없음
   - members: member_id
   - books: isbn
   - authors: author_id
   - loans: loan_id
   - book_authors: book_author_id

✅ 3NF 만족: 이행적 종속 없음
   - loans 테이블에서 member_id → member_name 같은 이행적 종속 없음
   - 모든 비키 속성이 기본키에만 종속
```

---

## 8. 도전 과제

### 과제 1: 예약 시스템 추가

**요구사항**:
- 대출 중인 도서를 예약할 수 있는 기능 추가
- 예약은 선착순으로 처리

**힌트**:
- `reservations` 테이블 생성
- 예약일(reservation_date), 상태(status) 필드 필요

### 과제 2: 연체료 계산

**요구사항**:
- 연체료는 1일당 500원
- 최대 연체료는 10,000원

**힌트**:
```sql
SELECT
    LEAST(DATEDIFF(CURRENT_DATE, due_date) * 500, 10000) AS 연체료
FROM loans
WHERE return_date IS NULL
  AND due_date < CURRENT_DATE;
```

### 과제 3: 트리거 구현

**요구사항**:
- 도서 대출 시 재고 자동 감소
- 도서 반납 시 재고 자동 증가

**힌트**: MySQL 트리거 사용
```sql
DELIMITER //

CREATE TRIGGER after_loan_insert
AFTER INSERT ON loans
FOR EACH ROW
BEGIN
    UPDATE books
    SET stock = stock - 1
    WHERE isbn = NEW.isbn;
END//

DELIMITER ;
```

---

## 강사 가이드

### 수업 진행 방법

**1단계: 요구사항 분석 (20분)**
- 학생들과 함께 요구사항 읽기
- 개체, 속성, 관계를 함께 찾기
- 화이트보드에 ERD 스케치

**2단계: ERD 작성 (30분)**
- 도구 사용: draw.io, MySQL Workbench
- 관계 cardinality 명확히 표시
- N:M 관계 해소 과정 설명

**3단계: SQL 구현 (40분)**
- 테이블 생성 순서 중요: 외래키 참조 고려
- 제약 조건 하나씩 설명하며 추가
- 샘플 데이터 삽입 실습

**4단계: 쿼리 실습 (30분)**
- JOIN 쿼리 중심 실습
- 집계 함수 활용
- 실전 쿼리 예시 실행

### 핵심 포인트

1. **외래키 참조 순서**: 부모 테이블 먼저 생성
   - members, authors, books → book_authors, loans

2. **ON DELETE 옵션 차이**:
   - CASCADE: 연쇄 삭제 (book_authors)
   - RESTRICT: 삭제 방지 (loans)

3. **CHECK 제약 조건**:
   - MySQL 8.0.16 이상에서만 동작
   - 버전 확인: `SELECT VERSION();`

4. **정규화 실전 적용**:
   - 역정규화 필요 없음 (소규모 시스템)
   - 3NF로 충분

### 자주 하는 질문

**Q: ISBN을 INT로 하면 안 되나요?**
A: ISBN은 숫자지만 계산에 사용하지 않으므로 VARCHAR 권장. 0으로 시작하는 경우도 있음.

**Q: loan_id가 왜 필요한가요? member_id + isbn을 복합키로 하면 안 되나요?**
A: 같은 회원이 같은 책을 여러 번 대출할 수 있으므로 별도의 기본키 필요.

**Q: 대출일과 반납예정일을 자동 계산할 수 없나요?**
A: 가능. 트리거나 애플리케이션 레벨에서 구현. 이 실습에서는 명시적으로 입력.

**Q: 실제 도서관은 같은 책이 여러 권 있는데요?**
A: 맞습니다. 실무에서는 `books` (도서 정보)와 `book_copies` (실물 책) 테이블을 분리합니다. 이 실습은 개념 이해용 단순화 버전입니다.

### 시간이 남으면

- **뷰(VIEW) 생성**: 자주 사용하는 쿼리를 뷰로 저장
- **인덱스 추가**: email, isbn 등에 인덱스 추가하여 성능 향상
- **저장 프로시저**: 대출/반납 로직을 프로시저로 캡슐화

---

## 요약

이 실습에서 다룬 내용:

- ✅ **요구사항 분석**: 명사 → 개체, 동사 → 관계
- ✅ **ERD 작성**: Crow's Foot Notation, N:M 관계 해소
- ✅ **테이블 구현**: 5개 테이블 + 제약 조건
- ✅ **관계 구현**: 1:N (외래키), N:M (중간 테이블)
- ✅ **제약 조건**: PRIMARY KEY, FOREIGN KEY, UNIQUE, NOT NULL, CHECK, DEFAULT
- ✅ **CASCADE 옵션**: DELETE/UPDATE 연쇄 동작
- ✅ **실전 쿼리**: JOIN, 집계, 조건부 논리

**핵심 교훈**:
1. 설계가 구현보다 중요하다
2. 정규화를 통해 중복을 제거한다
3. 제약 조건으로 데이터 무결성을 보장한다
4. 외래키로 관계를 명확히 한다

**다음 단계**: SQL 기본 쿼리 작성을 본격적으로 배웁니다! (3장)
