# 8.6 실습: AI와 함께 쿼리 작성하기

> **학습 목표**
> - 실제 비즈니스 요구사항을 AI와 함께 SQL로 구현합니다
> - 단계별 접근법을 실습으로 체화합니다
> - AI 활용 능력을 종합적으로 향상시킵니다

---

## 실습 안내

### 사용 데이터베이스
- **sakila** 데이터베이스 사용
- MySQL 8.0+ 권장

### 실습 방법
1. 각 문제를 읽고 먼저 직접 생각해보기
2. AI에게 요청할 프롬프트 작성하기
3. AI와 대화하며 쿼리 작성하기
4. 결과 검증하기
5. 다른 학생들과 비교 및 토론하기

---

## 실습 1: 영화 대여 분석 (기초)

### 문제

> "sakila 데이터베이스에서 2005년 5월에 대여된 영화 중,
> 대여 횟수가 5회 이상인 영화의 제목과 대여 횟수를 조회하세요.
> 대여 횟수가 많은 순으로 정렬하여 상위 10개만 표시하세요."

### 힌트

- **사용 테이블**: `film`, `inventory`, `rental`
- **조인 관계**: film ← inventory ← rental
- **조건**: rental_date가 2005년 5월
- **집계**: COUNT() 사용
- **필터**: HAVING절 사용

### AI 프롬프트 예시

<details>
<summary>프롬프트 예시 보기</summary>

```
"sakila 데이터베이스에서 다음 작업을 해줘:

테이블 구조:
- film (film_id, title)
- inventory (inventory_id, film_id)
- rental (rental_id, inventory_id, rental_date)

요청:
1. 2005년 5월에 대여된 기록 찾기
2. 영화별로 대여 횟수 집계
3. 대여 횟수가 5회 이상인 영화만 필터링
4. 대여 횟수 많은 순으로 정렬
5. 상위 10개만 조회

필요한 컬럼: 영화 제목, 대여 횟수"
```

</details>

### 예상 결과

| title | rental_count |
|-------|--------------|
| BUCKET BROTHERHOOD | 34 |
| ROCKETEER MOTHER | 33 |
| SCALAWAG DUCK | 32 |
| ... | ... |

### 검증 체크리스트

- [ ] 2005년 5월 데이터만 포함되었는가?
- [ ] 모든 영화의 대여 횟수가 5회 이상인가?
- [ ] 정렬이 올바른가?
- [ ] 정확히 10개만 조회되었는가?

<details>
<summary>답안 예시 보기</summary>

```sql
USE sakila;
SELECT
    f.title,
    COUNT(r.rental_id) as rental_count
FROM film f
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id
WHERE r.rental_date >= '2005-05-01'
  AND r.rental_date < '2005-06-01'
GROUP BY f.film_id, f.title
HAVING rental_count >= 5
ORDER BY rental_count DESC
LIMIT 10;
```

</details>

---

## 실습 2: 고객 세분화 (중급)

### 문제

> "고객을 다음 세 그룹으로 분류하고 각 그룹의 고객 수와 평균 지불 금액을 계산하세요:
> - VIP: 총 지불 금액 200달러 이상
> - 일반: 총 지불 금액 100~199달러
> - 비활성: 총 지불 금액 100달러 미만"

### 힌트

- **사용 테이블**: `customer`, `payment`
- **CASE 문** 사용
- **GROUP BY** 그룹 레벨로 사용

### AI 프롬프트 예시

<details>
<summary>프롬프트 예시 보기</summary>

```
"sakila에서:
1. customer와 payment 테이블을 조인
2. 각 고객의 총 지불 금액을 계산
3. 금액에 따라 고객을 세 그룹으로 분류:
   - VIP: 200달러 이상
   - 일반: 100~199달러
   - 비활성: 100달러 미만
4. 각 그룹별 고객 수와 평균 지불 금액 계산
5. 그룹명으로 정렬"
```

</details>

### 예상 결과

| customer_group | customer_count | avg_payment |
|----------------|----------------|-------------|
| VIP | 42 | 215.50 |
| 일반 | 158 | 145.23 |
| 비활성 | 399 | 75.60 |

<details>
<summary>답안 예시 보기</summary>

```sql
USE sakila;
WITH CustomerTotals AS (
    SELECT
        c.customer_id,
        SUM(p.amount) as total_payment
    FROM customer c
    LEFT JOIN payment p ON c.customer_id = p.customer_id
    GROUP BY c.customer_id
)
SELECT
    CASE
        WHEN total_payment >= 200 THEN 'VIP'
        WHEN total_payment >= 100 THEN '일반'
        ELSE '비활성'
    END as customer_group,
    COUNT(*) as customer_count,
    ROUND(AVG(total_payment), 2) as avg_payment
FROM CustomerTotals
GROUP BY customer_group
ORDER BY
    CASE customer_group
        WHEN 'VIP' THEN 1
        WHEN '일반' THEN 2
        ELSE 3
    END;
```

</details>

---

## 실습 3: 시계열 분석 (고급)

### 문제

> "2005년 각 월별로 다음 정보를 계산하세요:
> 1. 해당 월의 총 대여 횟수
> 2. 해당 월의 총 매출
> 3. 전월 대비 대여 횟수 증감률
> 4. 전월 대비 매출 증감률
> 5. 누적 매출"

### 힌트

- **윈도우 함수** 사용: LAG(), SUM() OVER()
- **WITH (CTE)** 사용 권장
- **DATE_FORMAT** 또는 **EXTRACT** 사용

### AI 프롬프트 예시

<details>
<summary>프롬프트 예시 보기</summary>

```
"sakila의 rental과 payment 테이블을 사용해서:

1. 2005년 데이터만 사용
2. 월별로 다음을 계산:
   - 대여 횟수 (COUNT)
   - 총 매출 (SUM)
3. 윈도우 함수를 사용해서:
   - 전월 대여 횟수 (LAG)
   - 전월 매출 (LAG)
   - 대여 증감률 계산: (이번달 - 전달) / 전달 * 100
   - 매출 증감률 계산
   - 누적 매출 (SUM OVER)
4. 월 순서대로 정렬"
```

</details>

### 예상 결과

| month | rental_count | revenue | rental_growth | revenue_growth | cumulative_revenue |
|-------|--------------|---------|---------------|----------------|-------------------|
| 2005-05 | 1156 | 4824.43 | NULL | NULL | 4824.43 |
| 2005-06 | 2311 | 9631.88 | 99.91% | 99.67% | 14456.31 |
| 2005-07 | 6709 | 28373.89 | 190.26% | 194.56% | 42830.20 |
| ... | ... | ... | ... | ... | ... |

<details>
<summary>답안 예시 보기</summary>

```sql
USE sakila;
WITH MonthlyStats AS (
    SELECT
        DATE_FORMAT(r.rental_date, '%Y-%m') as month,
        COUNT(r.rental_id) as rental_count,
        SUM(p.amount) as revenue
    FROM rental r
    JOIN payment p ON r.rental_id = p.rental_id
    WHERE YEAR(r.rental_date) = 2005
    GROUP BY month
)
SELECT
    month,
    rental_count,
    revenue,
    LAG(rental_count) OVER (ORDER BY month) as prev_rental_count,
    LAG(revenue) OVER (ORDER BY month) as prev_revenue,
    ROUND(
        (rental_count - LAG(rental_count) OVER (ORDER BY month)) /
        LAG(rental_count) OVER (ORDER BY month) * 100,
        2
    ) as rental_growth_pct,
    ROUND(
        (revenue - LAG(revenue) OVER (ORDER BY month)) /
        LAG(revenue) OVER (ORDER BY month) * 100,
        2
    ) as revenue_growth_pct,
    SUM(revenue) OVER (ORDER BY month) as cumulative_revenue
FROM MonthlyStats
ORDER BY month;
```

</details>

---

## 실습 4: 복합 분석 (심화)

### 문제

> "각 영화 카테고리별로 다음 분석을 수행하세요:
> 1. 카테고리명
> 2. 총 영화 수
> 3. 평균 대여료
> 4. 해당 카테고리에서 가장 인기 있는 영화 (대여 횟수 기준) 3개의 제목
> 5. 해당 카테고리의 총 매출
>
> 조건:
> - 총 매출이 1000달러 이상인 카테고리만 조회
> - 총 매출 높은 순으로 정렬"

### 힌트

- **다중 테이블 JOIN** 필요
- **GROUP_CONCAT** 또는 **서브쿼리** 사용
- **윈도우 함수** (ROW_NUMBER) 활용 가능

### AI 프롬프트 전략

1단계 프롬프트:
```
"sakila에서 카테고리별 기본 통계를 계산해줘:
- category, film, film_category 조인
- 카테고리별 영화 수, 평균 대여료"
```

2단계 프롬프트:
```
"위 쿼리에 대여 정보를 추가해서 총 매출도 계산해줘"
```

3단계 프롬프트:
```
"각 카테고리별로 가장 인기 있는 영화 3개를 함께 표시해줘"
```

<details>
<summary>답안 예시 보기</summary>

```sql
USE sakila;
WITH CategoryStats AS (
    SELECT
        c.category_id,
        c.name as category_name,
        COUNT(DISTINCT f.film_id) as film_count,
        ROUND(AVG(f.rental_rate), 2) as avg_rental_rate,
        SUM(p.amount) as total_revenue
    FROM category c
    JOIN film_category fc ON c.category_id = fc.category_id
    JOIN film f ON fc.film_id = f.film_id
    JOIN inventory i ON f.film_id = i.film_id
    JOIN rental r ON i.inventory_id = r.inventory_id
    JOIN payment p ON r.rental_id = p.rental_id
    GROUP BY c.category_id, c.name
    HAVING total_revenue >= 1000
),
TopFilms AS (
    SELECT
        c.category_id,
        f.title,
        COUNT(r.rental_id) as rental_count,
        ROW_NUMBER() OVER (
            PARTITION BY c.category_id
            ORDER BY COUNT(r.rental_id) DESC
        ) as rn
    FROM category c
    JOIN film_category fc ON c.category_id = fc.category_id
    JOIN film f ON fc.film_id = f.film_id
    JOIN inventory i ON f.film_id = i.film_id
    JOIN rental r ON i.inventory_id = r.inventory_id
    GROUP BY c.category_id, f.film_id, f.title
)
SELECT
    cs.category_name,
    cs.film_count,
    cs.avg_rental_rate,
    GROUP_CONCAT(
        DISTINCT CASE WHEN tf.rn <= 3 THEN tf.title END
        ORDER BY tf.rn
        SEPARATOR ', '
    ) as top_3_films,
    cs.total_revenue
FROM CategoryStats cs
LEFT JOIN TopFilms tf ON cs.category_id = tf.category_id AND tf.rn <= 3
GROUP BY cs.category_id, cs.category_name, cs.film_count,
         cs.avg_rental_rate, cs.total_revenue
ORDER BY cs.total_revenue DESC;
```

</details>

---

## 도전 과제

### 과제 1: 고객 이탈 분석

> "마지막 대여일이 180일 이상 지난 고객을 찾고,
> 해당 고객들의 과거 대여 패턴 (평균 대여 간격, 선호 카테고리 등)을 분석하세요."

### 과제 2: ABC 분석

> "파레토 법칙을 적용하여 고객을 A, B, C 등급으로 분류하세요:
> - A 등급: 매출 상위 20% 기여 고객
> - B 등급: 다음 30% 기여 고객
> - C 등급: 나머지 50% 고객"

### 과제 3: 코호트 분석

> "가입 월별로 고객을 그룹화하고,
> 각 코호트의 월별 retention rate를 계산하세요."

---

## 실습 후 활동

### 1. 코드 리뷰

다른 학생들과 작성한 쿼리를 공유하고 비교하세요:
- 같은 결과를 얻는 다른 방법은?
- 어떤 방법이 더 효율적인가?
- 가독성은 어떤가?

### 2. 성능 비교

```sql
-- EXPLAIN으로 실행 계획 비교
EXPLAIN SELECT ...
```

- 인덱스를 사용하는가?
- 어떤 JOIN 타입을 사용하는가?
- 몇 개의 행을 스캔하는가?

### 3. AI와 토론

```
"내가 작성한 쿼리를 개선할 방법이 있을까?"
"다른 접근 방법을 3가지 제안해줘"
"이 쿼리의 장단점을 분석해줘"
```

---

## 정리

### 오늘 배운 내용

1. **단계별 접근법**
   - 복잡한 문제를 작은 단계로 분해
   - AI와 대화하며 점진적으로 구축

2. **실무 시나리오**
   - 비즈니스 요구사항을 SQL로 변환
   - 여러 테이블을 조합한 복잡한 분석

3. **AI 활용 전략**
   - 명확한 프롬프트 작성
   - 단계별 검증
   - 결과 이해 및 개선

### 다음 학습 방향

1. **SQL 기초 강화**
   - JOIN, GROUP BY, 윈도우 함수 깊이 있게 학습
   - 성능 최적화 기법 습득

2. **AI 활용 능력 향상**
   - 다양한 프롬프트 패턴 익히기
   - AI 결과 검증 능력 키우기

3. **실무 프로젝트 경험**
   - 실제 데이터로 프로젝트 진행
   - GitHub에 쿼리 정리 및 공유

---

## 강사 가이드

### 강의 진행 방법

**1. 실습 전 (15분)**
- 문제 읽고 이해하기
- 필요한 테이블 구조 확인
- 접근 방법 토론

**2. 실습 중 (60분)**
- 학생들이 직접 AI와 대화하며 쿼리 작성
- 막히는 학생들에게 힌트 제공
- 중간 점검 및 피드백

**3. 실습 후 (15분)**
- 다양한 답안 공유
- 최적의 솔루션 토론
- 학습 포인트 정리

### 평가 기준

- **정확성** (40%): 올바른 결과를 반환하는가?
- **효율성** (30%): 성능이 좋은가?
- **가독성** (20%): 이해하기 쉬운가?
- **과정** (10%): AI를 효과적으로 활용했는가?

### 추가 자료

- 샘플 데이터 생성 스크립트
- 성능 측정 도구
- 쿼리 최적화 가이드

---

**[이전: 8.5 AI 활용 시 주의사항과 한계](./8.5_AI_활용_시_주의사항과_한계.md)** | **[다음: 챕터 9로 이동](../09_챕터명/)**

**[목차로 돌아가기](../목차.md)**
