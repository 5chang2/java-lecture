# 8.2 AI에게 효과적으로 SQL 요청하기

> **학습 목표**
> - AI에게 명확하게 요청하는 방법을 배웁니다
> - 프롬프트 작성 기술을 익힙니다
> - 테이블 구조를 효과적으로 전달하는 방법을 알아봅니다

---

## 1. 좋은 프롬프트 vs 나쁜 프롬프트

### 1.1 나쁜 예시들

#### ❌ 너무 모호한 요청
```
"고객 정보 좀 보여줘"
```

**문제점**:
- 어떤 테이블인지 불명확
- 어떤 컬럼을 원하는지 모름
- 조건이 없음

**AI가 할 수 있는 것**:
- 추측으로 답변 (틀릴 가능성 높음)

---

#### ❌ 맥락 없는 요청
```
"영화 10개만 가져와"
```

**문제점**:
- 어떤 기준으로 10개?
- 어떤 정보를 원하는지 불명확

---

### 1.2 좋은 예시들

#### ✅ 명확하고 구체적인 요청
```
"sakila 데이터베이스의 film 테이블에서
대여료(rental_rate)가 4.99 이상인 영화의
제목(title), 대여료(rental_rate), 등급(rating)을
대여료가 높은 순서대로 10개만 조회하는 쿼리를 작성해줘"
```

**좋은 점**:
- 데이터베이스 이름 명시
- 테이블 이름 명시
- 원하는 컬럼 명시
- 조건 명확
- 정렬 기준 제시
- 개수 제한 명시

**AI의 응답**:
```sql
USE sakila;
SELECT title, rental_rate, rating
FROM film
WHERE rental_rate >= 4.99
ORDER BY rental_rate DESC
LIMIT 10;
```

---

## 2. 효과적인 프롬프트 작성 공식

### 2.1 기본 공식

```
[데이터베이스] + [테이블] + [컬럼] + [조건] + [정렬/제한]
```

#### 예시 1: 단순 조회
```
"sakila 데이터베이스의 customer 테이블에서
active 상태가 1인 고객의
first_name, last_name, email을 조회해줘"
```

**결과**:
```sql
USE sakila;
SELECT first_name, last_name, email
FROM customer
WHERE active = 1;
```

---

#### 예시 2: 집계 쿼리
```
"sakila의 payment 테이블에서
고객별(customer_id) 총 지불 금액(amount)을
계산하되, 100달러 이상 지불한 고객만 보여주고
금액이 높은 순서대로 정렬해줘"
```

**결과**:
```sql
USE sakila;
SELECT
    customer_id,
    SUM(amount) as total_payment
FROM payment
GROUP BY customer_id
HAVING SUM(amount) >= 100
ORDER BY total_payment DESC;
```

---

### 2.2 고급 공식: 테이블 구조 포함

복잡한 쿼리를 요청할 때는 테이블 구조를 함께 제공하세요.

```
"다음 테이블 구조를 가진 sakila 데이터베이스에서 쿼리를 작성해줘:

film 테이블:
- film_id (INT, PK)
- title (VARCHAR)
- rental_rate (DECIMAL)

inventory 테이블:
- inventory_id (INT, PK)
- film_id (INT, FK -> film)

rental 테이블:
- rental_id (INT, PK)
- inventory_id (INT, FK -> inventory)
- rental_date (DATETIME)

요청: 2005년 6월에 대여된 영화의 제목과 대여 횟수를 조회해줘"
```

**결과**:
```sql
USE sakila;
SELECT
    f.title,
    COUNT(r.rental_id) as rental_count
FROM film f
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id
WHERE r.rental_date >= '2005-06-01'
  AND r.rental_date < '2005-07-01'
GROUP BY f.film_id, f.title
ORDER BY rental_count DESC;
```

---

## 3. 단계별 프롬프트 전략

복잡한 요청은 단계별로 나누어 요청하세요.

### 3.1 1단계: 기본 쿼리 요청

```
"sakila에서 film 테이블의 모든 데이터를 조회하는 쿼리를 작성해줘"
```

**결과**:
```sql
SELECT * FROM film;
```

---

### 3.2 2단계: 조건 추가

```
"위 쿼리에 rental_rate가 2.99 이상인 조건을 추가해줘"
```

**결과**:
```sql
SELECT * FROM film
WHERE rental_rate >= 2.99;
```

---

### 3.3 3단계: 정렬 및 제한

```
"위 쿼리를 rental_rate 높은 순으로 정렬하고 10개만 가져오도록 수정해줘"
```

**결과**:
```sql
SELECT * FROM film
WHERE rental_rate >= 2.99
ORDER BY rental_rate DESC
LIMIT 10;
```

---

### 3.4 4단계: 최적화 요청

```
"위 쿼리에서 필요한 컬럼만 선택하도록 최적화해줘: title, rental_rate, rating"
```

**결과**:
```sql
SELECT title, rental_rate, rating
FROM film
WHERE rental_rate >= 2.99
ORDER BY rental_rate DESC
LIMIT 10;
```

---

## 4. 시나리오별 프롬프트 예시

### 4.1 JOIN 쿼리 요청

**요청**:
```
"sakila 데이터베이스에서:
- customer 테이블 (customer_id, first_name, last_name)
- payment 테이블 (payment_id, customer_id, amount)

위 두 테이블을 customer_id로 조인하여
각 고객의 이름과 총 지불 금액을 조회해줘"
```

**결과**:
```sql
USE sakila;
SELECT
    c.customer_id,
    c.first_name,
    c.last_name,
    SUM(p.amount) as total_payment
FROM customer c
JOIN payment p ON c.customer_id = p.customer_id
GROUP BY c.customer_id, c.first_name, c.last_name;
```

---

### 4.2 서브쿼리 요청

**요청**:
```
"sakila에서 평균 대여료보다 비싼 영화의 제목과 대여료를 조회해줘"
```

**결과**:
```sql
USE sakila;
SELECT title, rental_rate
FROM film
WHERE rental_rate > (
    SELECT AVG(rental_rate)
    FROM film
);
```

---

### 4.3 복잡한 집계 요청

**요청**:
```
"sakila의 rental과 payment 테이블을 사용해서:
1. 각 월별 대여 횟수와 총 매출을 계산
2. 2005년 데이터만
3. 매출이 높은 순으로 정렬"
```

**결과**:
```sql
USE sakila;
SELECT
    DATE_FORMAT(r.rental_date, '%Y-%m') as month,
    COUNT(r.rental_id) as rental_count,
    SUM(p.amount) as total_revenue
FROM rental r
JOIN payment p ON r.rental_id = p.rental_id
WHERE YEAR(r.rental_date) = 2005
GROUP BY month
ORDER BY total_revenue DESC;
```

---

## 5. 프롬프트 체크리스트

요청하기 전에 이 체크리스트를 확인하세요:

### ✅ 필수 정보
- [ ] 데이터베이스 이름 (sakila, world 등)
- [ ] 테이블 이름
- [ ] 원하는 컬럼 이름
- [ ] 조건 (WHERE절)
- [ ] 정렬 기준 (ORDER BY)

### ✅ 선택 정보
- [ ] 개수 제한 (LIMIT)
- [ ] 그룹화 기준 (GROUP BY)
- [ ] 집계 조건 (HAVING)
- [ ] JOIN할 테이블

### ✅ 맥락 정보
- [ ] 사용 중인 DBMS (MySQL, PostgreSQL 등)
- [ ] 테이블 구조 (복잡한 쿼리 시)
- [ ] 예상 결과 형태

---

## 6. 실전 예제

### 예제 1: 기본 프롬프트

**나쁜 요청**:
```
"영화 정보 줘"
```

**좋은 요청**:
```
"sakila 데이터베이스의 film 테이블에서
title, release_year, rating 컬럼을
release_year가 2006년인 영화들만 조회해줘"
```

---

### 예제 2: JOIN 프롬프트

**나쁜 요청**:
```
"영화와 배우 정보를 함께 보여줘"
```

**좋은 요청**:
```
"sakila에서:
- film 테이블 (film_id, title)
- film_actor 테이블 (film_id, actor_id) - 중간 테이블
- actor 테이블 (actor_id, first_name, last_name)

이 세 테이블을 조인해서 각 영화 제목과
출연한 배우들의 이름을 함께 보여줘"
```

---

### 예제 3: 최적화 요청

**기본 요청**:
```
"sakila에서 고객별 대여 횟수를 조회해줘"
```

**AI 결과**:
```sql
SELECT customer_id, COUNT(*) as cnt
FROM rental
GROUP BY customer_id;
```

**최적화 요청**:
```
"위 쿼리를 개선해줘:
1. 고객 이름도 함께 표시
2. 대여 횟수가 30회 이상인 고객만
3. 대여 횟수 많은 순으로 정렬"
```

**AI 결과**:
```sql
USE sakila;
SELECT
    c.customer_id,
    CONCAT(c.first_name, ' ', c.last_name) as customer_name,
    COUNT(r.rental_id) as rental_count
FROM customer c
JOIN rental r ON c.customer_id = r.customer_id
GROUP BY c.customer_id, c.first_name, c.last_name
HAVING rental_count >= 30
ORDER BY rental_count DESC;
```

---

## 7. 테이블 구조 전달 방법

### 7.1 DESCRIBE 결과 공유

```sql
-- MySQL에서 실행
DESCRIBE film;
```

결과를 AI에게 전달:
```
"다음은 film 테이블의 구조야:

Field         | Type          | Null | Key | Default
------------- | ------------- | ---- | --- | -------
film_id       | smallint      | NO   | PRI | NULL
title         | varchar(128)  | NO   |     | NULL
rental_rate   | decimal(4,2)  | NO   |     | 4.99
rating        | enum(...)     | YES  |     | G

이 테이블에서 rental_rate가 4.99보다 비싼 영화를 조회해줘"
```

---

### 7.2 CREATE TABLE 문 공유

```sql
SHOW CREATE TABLE film;
```

결과를 AI에게 전달하면 더 정확한 쿼리 생성 가능

---

## 실습 문제

### 문제 1: 프롬프트 개선하기

다음 나쁜 프롬프트를 좋은 프롬프트로 개선하세요:

**나쁜 프롬프트**:
```
"배우 정보 좀 가져와"
```

<details>
<summary>답안 예시</summary>

**좋은 프롬프트**:
```
"sakila 데이터베이스의 actor 테이블에서
first_name과 last_name을 조회하되,
last_name이 'A'로 시작하는 배우만
성(last_name) 알파벳 순으로 정렬해서 보여줘"
```

</details>

---

### 문제 2: 복잡한 요청 단계별로 나누기

다음 복잡한 요청을 단계별로 나누어 작성하세요:

**최종 목표**:
"2005년에 가장 많이 대여된 영화 5개의 제목과 대여 횟수를 조회"

<details>
<summary>답안 예시</summary>

**1단계**:
```
"sakila의 rental 테이블에서 2005년 대여 기록을 조회해줘"
```

**2단계**:
```
"위 결과를 inventory와 film 테이블과 조인해서
영화 제목도 함께 표시해줘"
```

**3단계**:
```
"영화별로 대여 횟수를 집계해줘"
```

**4단계**:
```
"대여 횟수가 많은 순으로 정렬하고 상위 5개만 보여줘"
```

</details>

---

## 정리

### 핵심 요약

1. **명확하게 요청하기**
   - 데이터베이스, 테이블, 컬럼 명시
   - 조건과 정렬 기준 포함

2. **프롬프트 공식**
   ```
   [데이터베이스] + [테이블] + [컬럼] + [조건] + [정렬/제한]
   ```

3. **복잡한 요청은 단계별로**
   - 기본 쿼리부터 시작
   - 점진적으로 조건 추가

4. **테이블 구조 제공**
   - DESCRIBE 결과 공유
   - 복잡한 JOIN시 관계 명시

### 다음 단계

다음 섹션에서는 **AI가 생성한 쿼리를 검증하고 수정하는 방법**을 배웁니다!

---

## 강사 가이드

### 강의 진행 팁

**1. 실시간 비교**
- 나쁜 프롬프트와 좋은 프롬프트를 실제로 AI에 입력
- 결과 차이를 학생들이 직접 확인하도록

**2. 학생 참여**
- 학생들이 직접 프롬프트 작성해보기
- 서로의 프롬프트를 평가하고 개선

**3. 실패 경험**
- 모호한 프롬프트로 틀린 결과 받아보기
- 어떻게 개선할지 함께 토론

### 예상 질문과 답변

**Q: 프롬프트가 너무 길어지는데 괜찮나요?**
A: 네, 자세할수록 좋습니다. AI는 긴 프롬프트도 잘 처리합니다.

**Q: 테이블 구조를 매번 알려줘야 하나요?**
A: 같은 대화 세션 내에서는 한 번만 알려주면 됩니다. AI가 맥락을 기억합니다.

---

**[이전: 8.1 AI 도구 소개와 활용 배경](./8.1_AI_도구_소개와_활용_배경.md)** | **[다음: 8.3 AI 생성 쿼리 검증 및 수정](./8.3_AI_생성_쿼리_검증_및_수정.md)**
