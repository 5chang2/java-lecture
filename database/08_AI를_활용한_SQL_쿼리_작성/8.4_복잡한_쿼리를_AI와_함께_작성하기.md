# 8.4 복잡한 쿼리를 AI와 함께 작성하기

> **학습 목표**
> - 복잡한 비즈니스 요구사항을 SQL로 변환하는 과정을 배웁니다
> - AI와 대화하며 단계적으로 쿼리를 개선하는 방법을 익힙니다
> - 실무 시나리오를 SQL 쿼리로 구현할 수 있습니다

---

## 1. 복잡한 쿼리 작성 전략

### 1.1 단계별 접근법

복잡한 쿼리는 한 번에 작성하지 말고, 단계별로 구축하세요.

```
1단계: 기본 쿼리 (단일 테이블)
↓
2단계: JOIN 추가
↓
3단계: 조건 추가 (WHERE)
↓
4단계: 그룹화 및 집계 (GROUP BY, HAVING)
↓
5단계: 정렬 및 제한 (ORDER BY, LIMIT)
↓
6단계: 최적화
```

---

## 2. 실무 시나리오 1: 고객 분석

### 시나리오

> "2005년 6월에 10회 이상 대여한 VIP 고객의 이름, 대여 횟수, 총 지불 금액을 조회하고,
> 총 지불 금액이 높은 순으로 정렬하여 상위 10명을 보여주세요."

---

### 2.1 1단계: 기본 쿼리

**AI에게 요청**:
```
"sakila에서 2005년 6월에 대여한 기록을 조회해줘.
rental 테이블 사용"
```

**AI 응답**:
```sql
USE sakila;
SELECT *
FROM rental
WHERE rental_date >= '2005-06-01'
  AND rental_date < '2005-07-01';
```

**결과 확인**: 약 2,000건의 대여 기록

---

### 2.2 2단계: 고객 정보 JOIN

**AI에게 요청**:
```
"위 쿼리에 customer 테이블을 조인해서
고객 이름(first_name, last_name)도 함께 보여줘"
```

**AI 응답**:
```sql
USE sakila;
SELECT
    r.*,
    c.first_name,
    c.last_name
FROM rental r
JOIN customer c ON r.customer_id = c.customer_id
WHERE r.rental_date >= '2005-06-01'
  AND r.rental_date < '2005-07-01';
```

---

### 2.3 3단계: 대여 횟수 집계

**AI에게 요청**:
```
"위 결과를 고객별로 그룹화하고,
각 고객의 대여 횟수를 세어줘"
```

**AI 응답**:
```sql
USE sakila;
SELECT
    c.customer_id,
    c.first_name,
    c.last_name,
    COUNT(r.rental_id) as rental_count
FROM rental r
JOIN customer c ON r.customer_id = c.customer_id
WHERE r.rental_date >= '2005-06-01'
  AND r.rental_date < '2005-07-01'
GROUP BY c.customer_id, c.first_name, c.last_name;
```

---

### 2.4 4단계: VIP 조건 추가

**AI에게 요청**:
```
"위 쿼리에서 대여 횟수가 10회 이상인 고객만 필터링해줘"
```

**AI 응답**:
```sql
USE sakila;
SELECT
    c.customer_id,
    c.first_name,
    c.last_name,
    COUNT(r.rental_id) as rental_count
FROM rental r
JOIN customer c ON r.customer_id = c.customer_id
WHERE r.rental_date >= '2005-06-01'
  AND r.rental_date < '2005-07-01'
GROUP BY c.customer_id, c.first_name, c.last_name
HAVING rental_count >= 10;
```

---

### 2.5 5단계: 지불 금액 추가

**AI에게 요청**:
```
"payment 테이블도 조인해서 총 지불 금액(SUM(amount))도 계산해줘"
```

**AI 응답**:
```sql
USE sakila;
SELECT
    c.customer_id,
    c.first_name,
    c.last_name,
    COUNT(r.rental_id) as rental_count,
    SUM(p.amount) as total_payment
FROM rental r
JOIN customer c ON r.customer_id = c.customer_id
JOIN payment p ON r.rental_id = p.rental_id
WHERE r.rental_date >= '2005-06-01'
  AND r.rental_date < '2005-07-01'
GROUP BY c.customer_id, c.first_name, c.last_name
HAVING rental_count >= 10;
```

---

### 2.6 6단계: 정렬 및 제한

**AI에게 요청**:
```
"총 지불 금액이 높은 순으로 정렬하고 상위 10명만 보여줘"
```

**AI 응답 (최종)**:
```sql
USE sakila;
SELECT
    c.customer_id,
    CONCAT(c.first_name, ' ', c.last_name) as customer_name,
    COUNT(r.rental_id) as rental_count,
    SUM(p.amount) as total_payment
FROM rental r
JOIN customer c ON r.customer_id = c.customer_id
JOIN payment p ON r.rental_id = p.rental_id
WHERE r.rental_date >= '2005-06-01'
  AND r.rental_date < '2005-07-01'
GROUP BY c.customer_id, c.first_name, c.last_name
HAVING rental_count >= 10
ORDER BY total_payment DESC
LIMIT 10;
```

---

## 3. 실무 시나리오 2: 영화 인기도 분석

### 시나리오

> "카테고리별로 평균 대여료가 가장 높은 영화 3개와 가장 낮은 영화 3개를 함께 조회하세요."

### 3.1 문제 분석

**AI에게 먼저 물어보기**:
```
"다음 요구사항을 SQL로 구현하려면 어떤 단계로 나누면 좋을까?

'카테고리별로 평균 대여료가 가장 높은 영화 3개와
가장 낮은 영화 3개를 함께 조회'"
```

**AI 응답**:
```
다음 단계로 나누는 것을 추천합니다:

1. film, film_category, category 테이블 조인
2. 카테고리별로 영화와 대여료 조회
3. 각 카테고리별로 상위 3개 쿼리 작성 (윈도우 함수 or 서브쿼리)
4. 각 카테고리별로 하위 3개 쿼리 작성
5. UNION으로 결합
```

---

### 3.2 1단계: 기본 조인

**AI에게 요청**:
```
"sakila에서 영화 제목, 카테고리명, 대여료를 조회해줘.
film, film_category, category 테이블 조인"
```

**AI 응답**:
```sql
USE sakila;
SELECT
    c.name as category_name,
    f.title,
    f.rental_rate
FROM film f
JOIN film_category fc ON f.film_id = fc.film_id
JOIN category c ON fc.category_id = c.category_id;
```

---

### 3.3 2단계: 윈도우 함수로 순위 부여

**AI에게 요청**:
```
"위 쿼리를 개선해서 각 카테고리 내에서
대여료 높은 순으로 순위(ROW_NUMBER)를 부여해줘"
```

**AI 응답**:
```sql
USE sakila;
SELECT
    c.name as category_name,
    f.title,
    f.rental_rate,
    ROW_NUMBER() OVER (
        PARTITION BY c.category_id
        ORDER BY f.rental_rate DESC
    ) as high_rank,
    ROW_NUMBER() OVER (
        PARTITION BY c.category_id
        ORDER BY f.rental_rate ASC
    ) as low_rank
FROM film f
JOIN film_category fc ON f.film_id = fc.film_id
JOIN category c ON fc.category_id = c.category_id;
```

---

### 3.4 3단계: 상위/하위 3개 필터링

**AI에게 요청**:
```
"위 결과를 CTE로 만들고,
high_rank <= 3 OR low_rank <= 3 조건으로 필터링해줘"
```

**AI 응답 (최종)**:
```sql
USE sakila;
WITH RankedFilms AS (
    SELECT
        c.name as category_name,
        f.title,
        f.rental_rate,
        ROW_NUMBER() OVER (
            PARTITION BY c.category_id
            ORDER BY f.rental_rate DESC
        ) as high_rank,
        ROW_NUMBER() OVER (
            PARTITION BY c.category_id
            ORDER BY f.rental_rate ASC
        ) as low_rank
    FROM film f
    JOIN film_category fc ON f.film_id = fc.film_id
    JOIN category c ON fc.category_id = c.category_id
)
SELECT
    category_name,
    title,
    rental_rate,
    CASE
        WHEN high_rank <= 3 THEN '상위'
        WHEN low_rank <= 3 THEN '하위'
    END as rank_type
FROM RankedFilms
WHERE high_rank <= 3 OR low_rank <= 3
ORDER BY category_name, rental_rate DESC;
```

---

## 4. 실무 시나리오 3: 월별 매출 분석

### 시나리오

> "2005년 각 월별 매출과 전월 대비 증감률을 계산하세요."

### 4.1 AI와 대화하며 작성

**사용자**:
```
"sakila의 payment 테이블에서 2005년 월별 매출을 계산해줘"
```

**AI**:
```sql
USE sakila;
SELECT
    DATE_FORMAT(payment_date, '%Y-%m') as month,
    SUM(amount) as monthly_revenue
FROM payment
WHERE YEAR(payment_date) = 2005
GROUP BY month
ORDER BY month;
```

---

**사용자**:
```
"위 쿼리를 CTE로 만들고, LAG 윈도우 함수를 사용해서
전월 매출도 함께 보여줘"
```

**AI**:
```sql
USE sakila;
WITH MonthlyRevenue AS (
    SELECT
        DATE_FORMAT(payment_date, '%Y-%m') as month,
        SUM(amount) as revenue
    FROM payment
    WHERE YEAR(payment_date) = 2005
    GROUP BY month
)
SELECT
    month,
    revenue,
    LAG(revenue) OVER (ORDER BY month) as prev_month_revenue
FROM MonthlyRevenue
ORDER BY month;
```

---

**사용자**:
```
"전월 대비 증감률(%)도 계산해줘.
공식: (이번달 - 전달) / 전달 * 100"
```

**AI (최종)**:
```sql
USE sakila;
WITH MonthlyRevenue AS (
    SELECT
        DATE_FORMAT(payment_date, '%Y-%m') as month,
        SUM(amount) as revenue
    FROM payment
    WHERE YEAR(payment_date) = 2005
    GROUP BY month
)
SELECT
    month,
    revenue,
    LAG(revenue) OVER (ORDER BY month) as prev_month_revenue,
    ROUND(
        (revenue - LAG(revenue) OVER (ORDER BY month)) /
        LAG(revenue) OVER (ORDER BY month) * 100,
        2
    ) as growth_rate_pct
FROM MonthlyRevenue
ORDER BY month;
```

---

## 5. 복잡한 쿼리 최적화 요청

### 5.1 성능 개선 요청

**사용자**:
```
"이 쿼리가 너무 느린데 최적화해줘:

SELECT c.customer_id, COUNT(*)
FROM customer c
JOIN rental r ON c.customer_id = r.customer_id
WHERE DATE(r.rental_date) = '2005-06-15'
GROUP BY c.customer_id;"
```

**AI**:
```sql
-- DATE() 함수 제거로 인덱스 활용
SELECT c.customer_id, COUNT(*)
FROM customer c
JOIN rental r ON c.customer_id = r.customer_id
WHERE r.rental_date >= '2005-06-15 00:00:00'
  AND r.rental_date < '2005-06-16 00:00:00'
GROUP BY c.customer_id;

-- 또는 인덱스 추가 제안:
-- CREATE INDEX idx_rental_date ON rental(rental_date);
```

---

### 5.2 가독성 개선 요청

**사용자**:
```
"이 쿼리를 더 읽기 쉽게 개선해줘"
```

**AI**:
- 적절한 들여쓰기
- 주석 추가
- 별칭 명확화
- CTE 사용

---

## 6. 디버깅: AI와 함께 문제 해결

### 6.1 에러 발생 시

**사용자**:
```
"이 쿼리에서 에러가 나는데 도와줘:

Error Code: 1055. Expression #2 of SELECT list is not in GROUP BY clause

SELECT customer_id, first_name, COUNT(*)
FROM customer
JOIN rental ON customer.customer_id = rental.customer_id
GROUP BY customer_id;"
```

**AI**:
```
"GROUP BY절에 first_name을 추가해야 합니다:

SELECT customer_id, first_name, COUNT(*)
FROM customer
JOIN rental ON customer.customer_id = rental.customer_id
GROUP BY customer_id, first_name;

또는 집계 함수 사용:
SELECT customer_id, MAX(first_name) as first_name, COUNT(*)
FROM customer
JOIN rental ON customer.customer_id = rental.customer_id
GROUP BY customer_id;"
```

---

## 실습 문제

### 문제: VIP 고객 대시보드

다음 요구사항을 단계별로 AI와 함께 구현하세요:

**요구사항**:
```
1. 2005년 전체 기간 동안 총 지불 금액 상위 20% 고객 선정
2. 해당 고객들의 다음 정보 조회:
   - 고객 이름
   - 총 대여 횟수
   - 총 지불 금액
   - 평균 대여 주기 (일 단위)
   - 가장 많이 대여한 영화 카테고리
3. 총 지불 금액 높은 순으로 정렬
```

<details>
<summary>힌트 보기</summary>

**단계별 접근**:
1. 전체 고객의 총 지불 금액 계산
2. 상위 20% 기준값 계산 (PERCENT_RANK 또는 서브쿼리)
3. 해당 고객들의 상세 정보 조회 (JOIN + 집계)
4. 가장 많이 대여한 카테고리 찾기 (윈도우 함수 또는 서브쿼리)

</details>

---

## 정리

### 핵심 요약

1. **단계별 접근**
   - 복잡한 쿼리는 한 번에 작성하지 말고 단계적으로
   - 각 단계마다 결과 확인

2. **AI와 대화**
   - 명확하게 요청
   - 결과 확인 후 다음 단계 요청
   - 에러 발생 시 AI에게 도움 요청

3. **최적화**
   - 성능 개선 요청
   - 가독성 개선 요청

### 다음 단계

다음 섹션에서는 **AI 활용 시 주의사항과 한계**를 배웁니다!

---

## 강사 가이드

### 강의 진행 팁

**1. 라이브 코딩**
- 실제로 AI와 대화하며 쿼리 작성
- 학생들이 과정을 직접 보도록

**2. 실패 경험**
- 한 번에 복잡하게 요청했을 때의 실패
- 단계별로 나눴을 때의 성공 비교

**3. 학생 참여**
- 각 단계마다 학생들이 다음 요청 제안
- 서로 다른 접근 방법 비교

---

**[이전: 8.3 AI 생성 쿼리 검증 및 수정](./8.3_AI_생성_쿼리_검증_및_수정.md)** | **[다음: 8.5 AI 활용 시 주의사항과 한계](./8.5_AI_활용_시_주의사항과_한계.md)**
