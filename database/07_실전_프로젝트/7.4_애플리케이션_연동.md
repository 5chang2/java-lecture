# 7.4. 애플리케이션과 DB 연동 (Java/Node.js)

## 학습 목표
- JDBC를 사용하여 Java 애플리케이션과 MySQL을 연동할 수 있다
- Connection, Statement, ResultSet을 올바르게 사용할 수 있다
- Prepared Statement로 SQL Injection을 방지할 수 있다
- Connection Pool을 이해하고 적용할 수 있다
- (선택) Node.js로 데이터베이스를 연동할 수 있다

---

## 1. JDBC 기초

### 1.1. JDBC란?

**JDBC (Java Database Connectivity)**
- Java에서 데이터베이스에 접근하기 위한 API
- 다양한 DBMS를 동일한 방식으로 사용

```
Java Application
       ↓
   JDBC API
       ↓
  JDBC Driver
       ↓
   Database (MySQL)
```

### 1.2. MySQL Connector 설치

**Maven (pom.xml)**
```xml
<dependencies>
    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <version>8.2.0</version>
    </dependency>
</dependencies>
```

**Gradle (build.gradle)**
```gradle
dependencies {
    implementation 'com.mysql:mysql-connector-j:8.2.0'
}
```

**수동 다운로드**
- https://dev.mysql.com/downloads/connector/j/
- JAR 파일을 프로젝트 classpath에 추가

---

## 2. 데이터베이스 연결

### 2.1. Connection 생성

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class DBConnection {
    private static final String URL = "jdbc:mysql://localhost:3306/eshop";
    private static final String USER = "root";
    private static final String PASSWORD = "your_password";

    public static Connection getConnection() throws SQLException {
        return DriverManager.getConnection(URL, USER, PASSWORD);
    }

    public static void main(String[] args) {
        try (Connection conn = getConnection()) {
            System.out.println("✅ 데이터베이스 연결 성공!");
        } catch (SQLException e) {
            System.err.println("❌ 연결 실패: " + e.getMessage());
        }
    }
}
```

### 2.2. Connection URL 구조

```
jdbc:mysql://[host]:[port]/[database]?[parameters]

예시:
jdbc:mysql://localhost:3306/eshop?useSSL=false&serverTimezone=UTC
```

**주요 파라미터:**
- `useSSL=false`: SSL 비활성화 (개발 환경)
- `serverTimezone=UTC`: 타임존 설정
- `characterEncoding=UTF-8`: 문자 인코딩

---

## 3. CRUD 구현

### 3.1. SELECT - 조회

```java
import java.sql.*;

public class ProductDAO {

    // 모든 상품 조회
    public void getAllProducts() {
        String sql = "SELECT * FROM Products";

        try (Connection conn = DBConnection.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {

            while (rs.next()) {
                int id = rs.getInt("product_id");
                String name = rs.getString("name");
                double price = rs.getDouble("price");
                int stock = rs.getInt("stock");

                System.out.printf("%d | %s | %.0f원 | 재고: %d%n",
                    id, name, price, stock);
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

### 3.2. INSERT - 삽입

```java
public class UserDAO {

    // 회원 가입
    public int registerUser(String email, String password, String name, String phone) {
        String sql = "INSERT INTO Users (email, password, name, phone) VALUES (?, ?, SHA2(?, 256), ?)";

        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            pstmt.setString(1, email);
            pstmt.setString(2, password);
            pstmt.setString(3, name);
            pstmt.setString(4, phone);

            int affectedRows = pstmt.executeUpdate();

            if (affectedRows > 0) {
                try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        int userId = generatedKeys.getInt(1);
                        System.out.println("✅ 회원 가입 성공! User ID: " + userId);
                        return userId;
                    }
                }
            }

        } catch (SQLException e) {
            System.err.println("❌ 회원 가입 실패: " + e.getMessage());
        }

        return -1;
    }
}
```

### 3.3. UPDATE - 수정

```java
public class ProductDAO {

    // 재고 업데이트
    public boolean updateStock(int productId, int quantity) {
        String sql = "UPDATE Products SET stock = stock + ? WHERE product_id = ?";

        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, quantity);
            pstmt.setInt(2, productId);

            int rowsAffected = pstmt.executeUpdate();

            if (rowsAffected > 0) {
                System.out.println("✅ 재고 업데이트 성공!");
                return true;
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }

        return false;
    }
}
```

### 3.4. DELETE - 삭제

```java
public class CartDAO {

    // 장바구니에서 제거
    public boolean removeFromCart(int cartId) {
        String sql = "DELETE FROM Carts WHERE cart_id = ?";

        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, cartId);

            int rowsAffected = pstmt.executeUpdate();

            if (rowsAffected > 0) {
                System.out.println("✅ 장바구니에서 삭제 완료!");
                return true;
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }

        return false;
    }
}
```

---

## 4. SQL Injection 방지

### 4.1. 취약한 코드 (❌)

```java
// ❌ 절대 사용 금지!
public User login(String email, String password) {
    String sql = "SELECT * FROM Users WHERE email = '" + email +
                 "' AND password = SHA2('" + password + "', 256)";

    // SQL Injection 공격 가능:
    // email = "admin@example.com' OR '1'='1"
    // → SELECT * FROM Users WHERE email = 'admin@example.com' OR '1'='1' AND ...
}
```

### 4.2. 안전한 코드 (✅)

```java
// ✅ Prepared Statement 사용
public User login(String email, String password) {
    String sql = "SELECT * FROM Users WHERE email = ? AND password = SHA2(?, 256)";

    try (Connection conn = DBConnection.getConnection();
         PreparedStatement pstmt = conn.prepareStatement(sql)) {

        pstmt.setString(1, email);
        pstmt.setString(2, password);

        try (ResultSet rs = pstmt.executeQuery()) {
            if (rs.next()) {
                return new User(
                    rs.getInt("user_id"),
                    rs.getString("email"),
                    rs.getString("name"),
                    rs.getString("phone")
                );
            }
        }

    } catch (SQLException e) {
        e.printStackTrace();
    }

    return null;
}
```

---

## 5. 트랜잭션 처리

### 5.1. 주문 생성 (트랜잭션)

```java
public class OrderDAO {

    public boolean createOrder(int userId, int addressId, List<OrderItem> items) {
        Connection conn = null;

        try {
            conn = DBConnection.getConnection();
            conn.setAutoCommit(false);  // 자동 커밋 비활성화

            // 1. 주문 생성
            String orderSql = "INSERT INTO Orders (user_id, address_id, total_amount, status) VALUES (?, ?, ?, 'pending')";
            PreparedStatement orderStmt = conn.prepareStatement(orderSql, Statement.RETURN_GENERATED_KEYS);

            double totalAmount = items.stream()
                .mapToDouble(item -> item.getPrice() * item.getQuantity())
                .sum();

            orderStmt.setInt(1, userId);
            orderStmt.setInt(2, addressId);
            orderStmt.setDouble(3, totalAmount);
            orderStmt.executeUpdate();

            // 주문 ID 가져오기
            ResultSet rs = orderStmt.getGeneratedKeys();
            int orderId = 0;
            if (rs.next()) {
                orderId = rs.getInt(1);
            }

            // 2. 주문 상세 추가
            String itemSql = "INSERT INTO Order_Items (order_id, product_id, quantity, price) VALUES (?, ?, ?, ?)";
            PreparedStatement itemStmt = conn.prepareStatement(itemSql);

            for (OrderItem item : items) {
                itemStmt.setInt(1, orderId);
                itemStmt.setInt(2, item.getProductId());
                itemStmt.setInt(3, item.getQuantity());
                itemStmt.setDouble(4, item.getPrice());
                itemStmt.addBatch();
            }
            itemStmt.executeBatch();

            // 3. 재고 감소
            String stockSql = "UPDATE Products SET stock = stock - ? WHERE product_id = ?";
            PreparedStatement stockStmt = conn.prepareStatement(stockSql);

            for (OrderItem item : items) {
                stockStmt.setInt(1, item.getQuantity());
                stockStmt.setInt(2, item.getProductId());
                stockStmt.addBatch();
            }
            stockStmt.executeBatch();

            // 4. 커밋
            conn.commit();
            System.out.println("✅ 주문 생성 완료! Order ID: " + orderId);
            return true;

        } catch (SQLException e) {
            // 롤백
            if (conn != null) {
                try {
                    conn.rollback();
                    System.err.println("❌ 주문 생성 실패, 롤백 완료");
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }
            e.printStackTrace();
            return false;

        } finally {
            // 자동 커밋 복원
            if (conn != null) {
                try {
                    conn.setAutoCommit(true);
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

---

## 6. Connection Pool

### 6.1. HikariCP 사용

**Maven 의존성 추가:**
```xml
<dependency>
    <groupId>com.zaxxer</groupId>
    <artifactId>HikariCP</artifactId>
    <version>5.1.0</version>
</dependency>
```

**Connection Pool 설정:**
```java
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import java.sql.Connection;
import java.sql.SQLException;

public class DBConnectionPool {
    private static HikariDataSource dataSource;

    static {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:mysql://localhost:3306/eshop");
        config.setUsername("root");
        config.setPassword("your_password");

        // Connection Pool 설정
        config.setMaximumPoolSize(10);
        config.setMinimumIdle(5);
        config.setConnectionTimeout(30000);

        dataSource = new HikariDataSource(config);
    }

    public static Connection getConnection() throws SQLException {
        return dataSource.getConnection();
    }

    public static void close() {
        if (dataSource != null) {
            dataSource.close();
        }
    }
}
```

**장점:**
- 연결 재사용으로 성능 향상
- 동시 요청 처리 향상
- 자동 연결 관리

---

## 7. 실전 예제: 상품 검색 및 주문

### 7.1. 상품 검색

```java
public class ProductService {

    public List<Product> searchProducts(String keyword, Integer categoryId) {
        List<Product> products = new ArrayList<>();
        StringBuilder sql = new StringBuilder("SELECT * FROM Products WHERE 1=1");

        if (keyword != null && !keyword.isEmpty()) {
            sql.append(" AND name LIKE ?");
        }

        if (categoryId != null) {
            sql.append(" AND category_id = ?");
        }

        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql.toString())) {

            int paramIndex = 1;

            if (keyword != null && !keyword.isEmpty()) {
                pstmt.setString(paramIndex++, "%" + keyword + "%");
            }

            if (categoryId != null) {
                pstmt.setInt(paramIndex++, categoryId);
            }

            try (ResultSet rs = pstmt.executeQuery()) {
                while (rs.next()) {
                    products.add(new Product(
                        rs.getInt("product_id"),
                        rs.getString("name"),
                        rs.getDouble("price"),
                        rs.getInt("stock")
                    ));
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }

        return products;
    }
}
```

### 7.2. 주문 조회

```java
public class OrderService {

    public List<OrderDTO> getOrdersByUser(int userId) {
        List<OrderDTO> orders = new ArrayList<>();

        String sql = """
            SELECT
                o.order_id,
                o.total_amount,
                o.status,
                o.ordered_at,
                p.method AS payment_method,
                p.status AS payment_status
            FROM Orders o
            LEFT JOIN Payments p ON o.order_id = p.order_id
            WHERE o.user_id = ?
            ORDER BY o.ordered_at DESC
        """;

        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, userId);

            try (ResultSet rs = pstmt.executeQuery()) {
                while (rs.next()) {
                    orders.add(new OrderDTO(
                        rs.getInt("order_id"),
                        rs.getDouble("total_amount"),
                        rs.getString("status"),
                        rs.getTimestamp("ordered_at"),
                        rs.getString("payment_method"),
                        rs.getString("payment_status")
                    ));
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }

        return orders;
    }
}
```

---

## 8. Node.js 연동 (선택)

### 8.1. 설치

```bash
npm install mysql2
```

### 8.2. 연결 설정

```javascript
// db.js
const mysql = require('mysql2/promise');

const pool = mysql.createPool({
    host: 'localhost',
    user: 'root',
    password: 'your_password',
    database: 'eshop',
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0
});

module.exports = pool;
```

### 8.3. CRUD 예제

```javascript
// productService.js
const pool = require('./db');

// 모든 상품 조회
async function getAllProducts() {
    const [rows] = await pool.query('SELECT * FROM Products');
    return rows;
}

// 상품 추가
async function addProduct(categoryId, name, price, stock) {
    const sql = 'INSERT INTO Products (category_id, name, price, stock) VALUES (?, ?, ?, ?)';
    const [result] = await pool.query(sql, [categoryId, name, price, stock]);
    return result.insertId;
}

// 주문 생성 (트랜잭션)
async function createOrder(userId, addressId, items) {
    const connection = await pool.getConnection();

    try {
        await connection.beginTransaction();

        // 1. 주문 생성
        const totalAmount = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
        const [orderResult] = await connection.query(
            'INSERT INTO Orders (user_id, address_id, total_amount, status) VALUES (?, ?, ?, "pending")',
            [userId, addressId, totalAmount]
        );

        const orderId = orderResult.insertId;

        // 2. 주문 상세 추가
        for (const item of items) {
            await connection.query(
                'INSERT INTO Order_Items (order_id, product_id, quantity, price) VALUES (?, ?, ?, ?)',
                [orderId, item.productId, item.quantity, item.price]
            );

            // 3. 재고 감소
            await connection.query(
                'UPDATE Products SET stock = stock - ? WHERE product_id = ?',
                [item.quantity, item.productId]
            );
        }

        await connection.commit();
        console.log('✅ 주문 생성 성공!', orderId);
        return orderId;

    } catch (error) {
        await connection.rollback();
        console.error('❌ 주문 생성 실패:', error);
        throw error;

    } finally {
        connection.release();
    }
}

module.exports = { getAllProducts, addProduct, createOrder };
```

---

## 9. 실습 문제

### Mission 1: 로그인 기능 구현 (⭐⭐⭐)

**문제:**
이메일과 비밀번호로 로그인하는 메서드를 작성하세요.

**요구사항:**
- Prepared Statement 사용
- SQL Injection 방지
- 로그인 성공 시 User 객체 반환

**정답:**
```java
public class UserService {

    public User login(String email, String password) {
        String sql = "SELECT * FROM Users WHERE email = ? AND password = SHA2(?, 256)";

        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setString(1, email);
            pstmt.setString(2, password);

            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    return new User(
                        rs.getInt("user_id"),
                        rs.getString("email"),
                        rs.getString("name"),
                        rs.getString("phone")
                    );
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }

        return null;
    }
}
```

---

### Mission 2: 장바구니 추가 (⭐⭐⭐⭐)

**문제:**
장바구니에 상품을 추가하는 메서드를 작성하세요.

**요구사항:**
- 이미 담긴 상품이면 수량만 증가
- 새로운 상품이면 INSERT

**정답:**
```java
public class CartService {

    public boolean addToCart(int userId, int productId, int quantity) {
        Connection conn = null;

        try {
            conn = DBConnection.getConnection();

            // 1. 기존 항목 확인
            String checkSql = "SELECT cart_id, quantity FROM Carts WHERE user_id = ? AND product_id = ?";
            PreparedStatement checkStmt = conn.prepareStatement(checkSql);
            checkStmt.setInt(1, userId);
            checkStmt.setInt(2, productId);

            ResultSet rs = checkStmt.executeQuery();

            if (rs.next()) {
                // 2-1. 기존 항목: 수량 증가
                int cartId = rs.getInt("cart_id");
                int currentQuantity = rs.getInt("quantity");

                String updateSql = "UPDATE Carts SET quantity = ? WHERE cart_id = ?";
                PreparedStatement updateStmt = conn.prepareStatement(updateSql);
                updateStmt.setInt(1, currentQuantity + quantity);
                updateStmt.setInt(2, cartId);
                updateStmt.executeUpdate();

            } else {
                // 2-2. 새 항목: INSERT
                String insertSql = "INSERT INTO Carts (user_id, product_id, quantity) VALUES (?, ?, ?)";
                PreparedStatement insertStmt = conn.prepareStatement(insertSql);
                insertStmt.setInt(1, userId);
                insertStmt.setInt(2, productId);
                insertStmt.setInt(3, quantity);
                insertStmt.executeUpdate();
            }

            System.out.println("✅ 장바구니에 추가 완료!");
            return true;

        } catch (SQLException e) {
            e.printStackTrace();
            return false;

        } finally {
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

---

### Mission 3: 인기 상품 조회 (⭐⭐⭐⭐⭐)

**문제:**
주문 횟수가 많은 상위 10개 상품을 조회하세요.

**요구사항:**
- JOIN 사용
- 주문 횟수 기준 정렬
- 상품명, 가격, 주문 횟수 출력

**정답:**
```java
public class ProductService {

    public List<PopularProduct> getTopProducts(int limit) {
        List<PopularProduct> products = new ArrayList<>();

        String sql = """
            SELECT
                p.product_id,
                p.name,
                p.price,
                COUNT(oi.order_item_id) AS order_count
            FROM Products p
            JOIN Order_Items oi ON p.product_id = oi.product_id
            GROUP BY p.product_id, p.name, p.price
            ORDER BY order_count DESC
            LIMIT ?
        """;

        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, limit);

            try (ResultSet rs = pstmt.executeQuery()) {
                while (rs.next()) {
                    products.add(new PopularProduct(
                        rs.getInt("product_id"),
                        rs.getString("name"),
                        rs.getDouble("price"),
                        rs.getInt("order_count")
                    ));
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }

        return products;
    }
}
```

---

## 강사 가이드

### 수업 진행 팁

**1. JDBC 기초 (40분)**
- Connection, Statement, ResultSet 개념
- try-with-resources 강조
- 예외 처리의 중요성

**2. SQL Injection 방지 (20분)**
- 취약한 코드 시연
- Prepared Statement 필요성
- 실제 공격 예시 보여주기

**3. 트랜잭션 실습 (30분)**
- setAutoCommit(false)
- commit/rollback
- 주문 생성 예제 함께 작성

**4. Connection Pool (15분)**
- 성능 향상 이유
- HikariCP 설정
- 실무 권장 설정

### 자주 하는 질문

**Q1: Statement와 PreparedStatement의 차이는?**
> A: Statement는 매번 SQL을 파싱하고 SQL Injection에 취약합니다. PreparedStatement는 미리 컴파일되고 안전하므로 항상 사용하세요.

**Q2: Connection을 매번 생성해야 하나요?**
> A: Connection Pool을 사용하면 연결을 재사용하여 성능이 향상됩니다. HikariCP 같은 라이브러리를 사용하세요.

**Q3: 트랜잭션은 언제 사용하나요?**
> A: 여러 작업이 모두 성공하거나 모두 실패해야 할 때 사용합니다 (예: 주문 생성, 계좌 이체).

**Q4: ResultSet을 close 안 하면 어떻게 되나요?**
> A: 메모리 누수와 커넥션 고갈이 발생합니다. 반드시 try-with-resources를 사용하세요.

### 실습 중 흔한 실수

**1. 리소스 누수**
```java
// ❌ 잘못된 코드
Connection conn = DriverManager.getConnection(...);
// close() 안 함!

// ✅ 올바른 코드
try (Connection conn = DriverManager.getConnection(...)) {
    // ...
}  // 자동으로 close()
```

**2. SQL Injection**
```java
// ❌ 위험
String sql = "SELECT * FROM Users WHERE email = '" + email + "'";

// ✅ 안전
String sql = "SELECT * FROM Users WHERE email = ?";
pstmt.setString(1, email);
```

**3. 트랜잭션 롤백 누락**
```java
// ❌ 롤백 안 함
try {
    conn.setAutoCommit(false);
    // ...
    conn.commit();
} catch (SQLException e) {
    // 롤백 누락!
}

// ✅ 올바른 처리
try {
    conn.setAutoCommit(false);
    // ...
    conn.commit();
} catch (SQLException e) {
    conn.rollback();
}
```

---

## 요약

### JDBC 핵심

**연결:**
```java
Connection conn = DriverManager.getConnection(url, user, password);
```

**CRUD:**
- SELECT: `executeQuery()` → `ResultSet`
- INSERT/UPDATE/DELETE: `executeUpdate()` → `int`

**보안:**
- ✅ Prepared Statement 사용
- ❌ String 연결로 SQL 생성 금지

**트랜잭션:**
```java
conn.setAutoCommit(false);
// 작업 수행
conn.commit();  // 또는 conn.rollback();
```

**Connection Pool:**
- HikariCP 사용
- 연결 재사용으로 성능 향상

### 다음 단계
다음 시간에는 **복잡한 쿼리 작성 실습 (7.5)**을 진행합니다.

---

**애플리케이션 연동 완료!** 이제 복잡한 비즈니스 로직을 구현해봅시다.
