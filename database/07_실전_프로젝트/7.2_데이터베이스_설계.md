# 7.2. 데이터베이스 설계 (ERD 작성)

## 학습 목표
- E-Shop 프로젝트의 ERD를 작성할 수 있다
- 엔티티 간의 관계를 명확히 정의할 수 있다
- 정규화를 적용하여 데이터 중복을 최소화한다
- 제약조건을 설계에 반영할 수 있다

---

## 1. ERD 설계 개요

### 1.1. ERD 도구 추천
- **draw.io** (https://draw.io) - 무료, 웹 기반
- **dbdiagram.io** (https://dbdiagram.io) - 코드로 ERD 생성
- **MySQL Workbench** - 데이터베이스 설계 및 생성
- **ERDCloud** (https://www.erdcloud.com) - 한글 지원

### 1.2. 설계 순서
```
1. 비즈니스 요구사항 분석
2. 엔티티 도출
3. 속성 정의
4. 관계 설정
5. 정규화
6. ERD 작성
```

---

## 2. 엔티티 설계

### 2.1. Users (회원)

**목적:** 쇼핑몰 회원 정보 관리

| 속성명 | 데이터 타입 | 제약조건 | 설명 |
|--------|------------|---------|------|
| user_id | INT | PK, AUTO_INCREMENT | 회원 ID |
| email | VARCHAR(100) | UNIQUE, NOT NULL | 이메일 (로그인 ID) |
| password | VARCHAR(255) | NOT NULL | 비밀번호 (해시) |
| name | VARCHAR(50) | NOT NULL | 이름 |
| phone | VARCHAR(20) | | 전화번호 |
| created_at | DATETIME | DEFAULT CURRENT_TIMESTAMP | 가입일 |
| updated_at | DATETIME | ON UPDATE CURRENT_TIMESTAMP | 수정일 |

### 2.2. Addresses (배송지)

**목적:** 회원의 배송지 정보 관리

| 속성명 | 데이터 타입 | 제약조건 | 설명 |
|--------|------------|---------|------|
| address_id | INT | PK, AUTO_INCREMENT | 배송지 ID |
| user_id | INT | FK, NOT NULL | 회원 ID |
| recipient_name | VARCHAR(50) | NOT NULL | 수령인 |
| phone | VARCHAR(20) | NOT NULL | 연락처 |
| address | VARCHAR(255) | NOT NULL | 주소 |
| zipcode | VARCHAR(10) | | 우편번호 |
| is_default | BOOLEAN | DEFAULT FALSE | 기본 배송지 여부 |

### 2.3. Categories (카테고리)

**목적:** 상품 분류 관리

| 속성명 | 데이터 타입 | 제약조건 | 설명 |
|--------|------------|---------|------|
| category_id | INT | PK, AUTO_INCREMENT | 카테고리 ID |
| name | VARCHAR(50) | NOT NULL, UNIQUE | 카테고리명 |
| description | TEXT | | 설명 |

### 2.4. Products (상품)

**목적:** 판매 상품 정보 관리

| 속성명 | 데이터 타입 | 제약조건 | 설명 |
|--------|------------|---------|------|
| product_id | INT | PK, AUTO_INCREMENT | 상품 ID |
| category_id | INT | FK, NOT NULL | 카테고리 ID |
| name | VARCHAR(100) | NOT NULL | 상품명 |
| description | TEXT | | 상세 설명 |
| price | DECIMAL(10,2) | NOT NULL, CHECK(price >= 0) | 가격 |
| stock | INT | DEFAULT 0, CHECK(stock >= 0) | 재고 수량 |
| created_at | DATETIME | DEFAULT CURRENT_TIMESTAMP | 등록일 |

### 2.5. Carts (장바구니)

**목적:** 장바구니 기능

| 속성명 | 데이터 타입 | 제약조건 | 설명 |
|--------|------------|---------|------|
| cart_id | INT | PK, AUTO_INCREMENT | 장바구니 ID |
| user_id | INT | FK, NOT NULL | 회원 ID |
| product_id | INT | FK, NOT NULL | 상품 ID |
| quantity | INT | DEFAULT 1, CHECK(quantity > 0) | 수량 |
| added_at | DATETIME | DEFAULT CURRENT_TIMESTAMP | 추가일 |

### 2.6. Orders (주문)

**목적:** 주문 정보 관리

| 속성명 | 데이터 타입 | 제약조건 | 설명 |
|--------|------------|---------|------|
| order_id | INT | PK, AUTO_INCREMENT | 주문 ID |
| user_id | INT | FK, NOT NULL | 회원 ID |
| address_id | INT | FK, NOT NULL | 배송지 ID |
| total_amount | DECIMAL(10,2) | NOT NULL | 총 주문 금액 |
| status | ENUM('pending', 'paid', 'shipped', 'delivered', 'cancelled') | DEFAULT 'pending' | 주문 상태 |
| ordered_at | DATETIME | DEFAULT CURRENT_TIMESTAMP | 주문일 |

### 2.7. Order_Items (주문 상세)

**목적:** 주문별 상품 내역 관리

| 속성명 | 데이터 타입 | 제약조건 | 설명 |
|--------|------------|---------|------|
| order_item_id | INT | PK, AUTO_INCREMENT | 주문 상세 ID |
| order_id | INT | FK, NOT NULL | 주문 ID |
| product_id | INT | FK, NOT NULL | 상품 ID |
| quantity | INT | NOT NULL, CHECK(quantity > 0) | 주문 수량 |
| price | DECIMAL(10,2) | NOT NULL | 주문 당시 가격 |

### 2.8. Payments (결제)

**목적:** 결제 정보 관리

| 속성명 | 데이터 타입 | 제약조건 | 설명 |
|--------|------------|---------|------|
| payment_id | INT | PK, AUTO_INCREMENT | 결제 ID |
| order_id | INT | FK, UNIQUE, NOT NULL | 주문 ID (1:1) |
| method | ENUM('card', 'bank', 'kakao', 'naver') | NOT NULL | 결제 수단 |
| amount | DECIMAL(10,2) | NOT NULL | 결제 금액 |
| status | ENUM('pending', 'completed', 'failed', 'refunded') | DEFAULT 'pending' | 결제 상태 |
| paid_at | DATETIME | | 결제 완료 시각 |

### 2.9. Reviews (리뷰)

**목적:** 상품 리뷰 및 평점 관리

| 속성명 | 데이터 타입 | 제약조건 | 설명 |
|--------|------------|---------|------|
| review_id | INT | PK, AUTO_INCREMENT | 리뷰 ID |
| user_id | INT | FK, NOT NULL | 작성자 ID |
| product_id | INT | FK, NOT NULL | 상품 ID |
| order_id | INT | FK, NOT NULL | 주문 ID |
| rating | INT | CHECK(rating BETWEEN 1 AND 5) | 평점 (1~5) |
| content | TEXT | | 리뷰 내용 |
| created_at | DATETIME | DEFAULT CURRENT_TIMESTAMP | 작성일 |

---

## 3. 관계 설정

### 3.1. ERD 관계도

```
[Users] 1 ────── N [Addresses]
  │
  ├── 1 ────── N [Carts]
  │
  ├── 1 ────── N [Orders]
  │
  └── 1 ────── N [Reviews]

[Categories] 1 ────── N [Products]

[Products] 1 ────── N [Carts]
  │
  ├── 1 ────── N [Order_Items]
  │
  └── 1 ────── N [Reviews]

[Orders] 1 ────── N [Order_Items]
  │
  └── 1 ────── 1 [Payments]
```

### 3.2. 관계 상세

**1. Users ↔ Addresses (1:N)**
- 한 회원은 여러 배송지를 등록할 수 있다
- 외래 키: Addresses.user_id → Users.user_id

**2. Users ↔ Carts (1:N)**
- 한 회원은 여러 상품을 장바구니에 담을 수 있다
- 외래 키: Carts.user_id → Users.user_id

**3. Users ↔ Orders (1:N)**
- 한 회원은 여러 주문을 할 수 있다
- 외래 키: Orders.user_id → Users.user_id

**4. Categories ↔ Products (1:N)**
- 한 카테고리에 여러 상품이 속한다
- 외래 키: Products.category_id → Categories.category_id

**5. Products ↔ Carts (1:N)**
- 한 상품은 여러 회원의 장바구니에 담길 수 있다
- 외래 키: Carts.product_id → Products.product_id

**6. Orders ↔ Order_Items (1:N)**
- 한 주문은 여러 상품을 포함한다
- 외래 키: Order_Items.order_id → Orders.order_id

**7. Products ↔ Order_Items (1:N)**
- 한 상품은 여러 주문에 포함될 수 있다
- 외래 키: Order_Items.product_id → Products.product_id

**8. Orders ↔ Payments (1:1)**
- 한 주문은 하나의 결제 정보를 가진다
- 외래 키: Payments.order_id → Orders.order_id (UNIQUE)

**9. Users/Products/Orders ↔ Reviews (N:1)**
- 한 회원/상품/주문은 여러 리뷰를 가질 수 있다
- 외래 키: Reviews.user_id, Reviews.product_id, Reviews.order_id

---

## 4. 정규화 적용

### 4.1. 제1정규형 (1NF)

**문제:** 주문 테이블에 상품 정보를 직접 저장하면 반복 그룹 발생

❌ **비정규화 예시:**
```
Orders (order_id, user_id, products, quantities, prices)
→ products: "노트북,마우스,키보드" (반복 그룹)
```

✅ **1NF 적용:**
```
Orders (order_id, user_id, address_id, total_amount, status)
Order_Items (order_item_id, order_id, product_id, quantity, price)
```

### 4.2. 제2정규형 (2NF)

**문제:** 부분 함수 종속 제거

❌ **2NF 위반 예시:**
```
Order_Items (order_id, product_id, product_name, quantity, price)
→ product_name은 product_id에만 종속 (부분 종속)
```

✅ **2NF 적용:**
```
Order_Items (order_item_id, order_id, product_id, quantity, price)
Products (product_id, name, category_id, description, price, stock)
```

### 4.3. 제3정규형 (3NF)

**문제:** 이행 함수 종속 제거

❌ **3NF 위반 예시:**
```
Products (product_id, name, category_id, category_name)
→ category_name은 category_id를 통해 간접 종속 (이행 종속)
```

✅ **3NF 적용:**
```
Products (product_id, name, category_id, description, price)
Categories (category_id, name, description)
```

---

## 5. 제약조건 설계

### 5.1. Primary Key (기본 키)
- 모든 테이블에 AUTO_INCREMENT PK 설정
- 단일 컬럼 PK 사용으로 성능 최적화

### 5.2. Foreign Key (외래 키)
```sql
-- 예시: Orders 테이블
FOREIGN KEY (user_id) REFERENCES Users(user_id) ON DELETE CASCADE
FOREIGN KEY (address_id) REFERENCES Addresses(address_id)
```

**ON DELETE 전략:**
- `CASCADE`: 회원 삭제 시 주문도 함께 삭제
- `RESTRICT`: 주문이 있으면 회원 삭제 불가
- `SET NULL`: 회원 삭제 시 user_id를 NULL로 설정

### 5.3. UNIQUE 제약조건
- `Users.email`: 이메일 중복 방지
- `Payments.order_id`: 한 주문에 하나의 결제만 가능

### 5.4. CHECK 제약조건
```sql
-- 가격은 0 이상
CHECK (price >= 0)

-- 재고는 0 이상
CHECK (stock >= 0)

-- 평점은 1~5 사이
CHECK (rating BETWEEN 1 AND 5)

-- 수량은 1 이상
CHECK (quantity > 0)
```

### 5.5. DEFAULT 값
```sql
created_at DATETIME DEFAULT CURRENT_TIMESTAMP
status ENUM(...) DEFAULT 'pending'
is_default BOOLEAN DEFAULT FALSE
```

---

## 6. 실습 문제

### Mission 1: ERD 작성 (⭐⭐⭐)

**문제:**
draw.io 또는 dbdiagram.io를 사용하여 E-Shop ERD를 작성하세요.

**요구사항:**
- 모든 엔티티(9개) 포함
- 관계선과 카디널리티 표시
- PK, FK 명시

**힌트:**
```
[Users] ──┬── [Addresses]
          ├── [Carts]
          ├── [Orders] ── [Payments]
          └── [Reviews]

[Categories] ── [Products] ──┬── [Carts]
                              ├── [Order_Items]
                              └── [Reviews]
```

---

### Mission 2: 정규화 점검 (⭐⭐⭐⭐)

**문제:**
다음 테이블이 3NF를 만족하는지 확인하고, 위반 시 수정하세요.

```sql
Orders (
    order_id,
    user_id,
    user_name,           -- ?
    user_email,          -- ?
    product_id,
    product_name,        -- ?
    product_price,       -- ?
    quantity,
    total_amount
)
```

**정답:**
```sql
-- 3NF 위반: user_name, user_email, product_name, product_price는 이행 종속
-- 수정 후:

Users (user_id, name, email)
Products (product_id, name, price)
Orders (order_id, user_id, total_amount)
Order_Items (order_item_id, order_id, product_id, quantity, price)
```

---

### Mission 3: 제약조건 설계 (⭐⭐⭐⭐)

**문제:**
다음 비즈니스 규칙을 제약조건으로 표현하세요.

1. 주문 금액은 0보다 커야 한다
2. 한 회원은 하나의 기본 배송지만 가질 수 있다
3. 리뷰는 실제 구매한 상품에만 작성 가능
4. 재고는 음수가 될 수 없다

**정답:**
```sql
-- 1. 주문 금액 체크
ALTER TABLE Orders ADD CONSTRAINT chk_total_amount CHECK (total_amount > 0);

-- 2. 기본 배송지 제약 (트리거 또는 애플리케이션 로직 필요)
-- UNIQUE (user_id, is_default) WHERE is_default = TRUE

-- 3. 리뷰 제약 (FK로 보장)
FOREIGN KEY (order_id) REFERENCES Orders(order_id)

-- 4. 재고 체크
ALTER TABLE Products ADD CONSTRAINT chk_stock CHECK (stock >= 0);
```

---

### Mission 4: 역정규화 결정 (⭐⭐⭐⭐⭐)

**문제:**
다음 쿼리의 성능을 개선하기 위해 역정규화를 고려해야 합니다.
어떤 컬럼을 추가할지 제안하고, 장단점을 설명하세요.

```sql
-- 자주 실행되는 쿼리
SELECT p.product_id, p.name, AVG(r.rating) as avg_rating
FROM Products p
LEFT JOIN Reviews r ON p.product_id = r.product_id
GROUP BY p.product_id, p.name;
```

**정답:**
```sql
-- Products 테이블에 avg_rating 컬럼 추가 (역정규화)
ALTER TABLE Products ADD COLUMN avg_rating DECIMAL(3,2);

-- 장점:
-- - 조회 성능 향상 (JOIN, GROUP BY 제거)
-- - 인기 상품 정렬이 빠름

-- 단점:
-- - 데이터 중복 (리뷰 변경 시 업데이트 필요)
-- - 트리거 또는 애플리케이션 로직으로 동기화

-- 트리거 예시:
CREATE TRIGGER update_avg_rating
AFTER INSERT ON Reviews
FOR EACH ROW
BEGIN
    UPDATE Products
    SET avg_rating = (
        SELECT AVG(rating) FROM Reviews WHERE product_id = NEW.product_id
    )
    WHERE product_id = NEW.product_id;
END;
```

---

## 강사 가이드

### 수업 진행 팁

**1. ERD 작성 실습 (40분)**
- 학생들에게 draw.io 또는 dbdiagram.io 사용법 설명
- 엔티티부터 하나씩 추가하며 함께 작성
- 관계선 표시 시 카디널리티 명확히 설명

**2. 정규화 과정 강조 (30분)**
- 비정규화된 예시부터 시작
- 1NF → 2NF → 3NF 단계별 개선
- 각 단계의 필요성 설명

**3. 제약조건 설계 (20분)**
- CHECK, UNIQUE, FK의 실무 활용
- ON DELETE CASCADE vs RESTRICT 차이
- DEFAULT 값 설정의 중요성

**4. 역정규화 토론 (15분)**
- 성능 vs 무결성 트레이드오프
- 실무에서 역정규화가 필요한 경우
- 동기화 방법 (트리거, 애플리케이션)

### 자주 하는 질문

**Q1: 모든 테이블에 created_at, updated_at을 추가해야 하나요?**
> A: 권장합니다. 특히 Users, Orders, Products 같은 주요 테이블은 필수입니다. 디버깅과 감사(audit)에 유용합니다.

**Q2: 복합 키(Composite Key)를 사용해야 할 때는?**
> A: 이 프로젝트에서는 단일 PK(AUTO_INCREMENT)를 권장합니다. 복합 키는 다대다(N:M) 관계 테이블에서 고려할 수 있지만, 성능상 단일 PK가 유리합니다.

**Q3: ENUM vs VARCHAR 중 어떤 것을 선택해야 하나요?**
> A: 값이 고정되고 변경이 거의 없으면 ENUM (예: status). 값이 자주 추가/변경되면 별도 테이블이나 VARCHAR를 사용하세요.

**Q4: ON DELETE CASCADE를 언제 사용하나요?**
> A: 부모 삭제 시 자식도 함께 삭제해도 되는 경우에만 사용하세요. 예: 주문 삭제 시 주문 상세도 삭제. 하지만 회원 삭제 시 주문까지 삭제하면 안 됩니다.

**Q5: 가격을 DECIMAL(10,2)로 하는 이유는?**
> A: 금액은 정확한 계산이 필요하므로 FLOAT/DOUBLE이 아닌 DECIMAL을 사용합니다. (10,2)는 최대 99,999,999.99까지 표현 가능합니다.

### 실습 중 흔한 실수

**1. 외래 키 순환 참조**
```sql
-- 잘못된 예
Users.default_address_id → Addresses.address_id
Addresses.user_id → Users.user_id  -- 순환!

-- 올바른 예
Addresses 테이블에 is_default BOOLEAN 컬럼 추가
```

**2. 잘못된 정규화**
```sql
-- 과도한 정규화
UserProfiles (user_id, name)
UserContacts (user_id, email, phone)
→ 너무 분리하면 오히려 비효율적

-- 적절한 정규화
Users (user_id, name, email, phone)
```

**3. CHECK 제약조건 누락**
```sql
-- 문제: 음수 수량 허용
quantity INT

-- 수정
quantity INT CHECK (quantity > 0)
```

---

## 요약

### ERD 핵심 구성요소

**9개 엔티티:**
- Users, Addresses, Categories, Products
- Carts, Orders, Order_Items, Payments, Reviews

**관계:**
- 1:N 관계: Users-Addresses, Users-Orders, Categories-Products 등
- 1:1 관계: Orders-Payments
- N:1 관계: Reviews-Products

**정규화:**
- 1NF: 반복 그룹 제거
- 2NF: 부분 함수 종속 제거
- 3NF: 이행 함수 종속 제거

**제약조건:**
- PK: AUTO_INCREMENT
- FK: ON DELETE 전략 설정
- CHECK: 데이터 유효성 검증
- UNIQUE: 중복 방지

### 다음 단계
다음 시간에는 **테이블 생성 및 샘플 데이터 삽입 (7.3)**을 진행합니다.

---

**ERD 설계 완료!** 이제 실제로 SQL로 테이블을 생성해봅시다.
