# 7.5. 복잡한 쿼리 작성 실습

## 학습 목표
- 비즈니스 요구사항을 SQL 쿼리로 구현할 수 있다
- 다중 테이블 JOIN을 활용할 수 있다
- 서브쿼리와 집계 함수를 적절히 사용할 수 있다
- Window Function으로 고급 분석을 수행할 수 있다

---

## 1. 매출 및 통계 쿼리

### 1.1. 일별 매출 조회

```sql
SELECT
    DATE(ordered_at) AS 주문일,
    COUNT(DISTINCT order_id) AS 주문수,
    SUM(total_amount) AS 총매출,
    AVG(total_amount) AS 평균주문금액
FROM Orders
WHERE status != 'cancelled'
GROUP BY DATE(ordered_at)
ORDER BY 주문일 DESC;
```

**결과:**
```
주문일      | 주문수 | 총매출    | 평균주문금액
2025-01-15 |   1   | 89000    | 89000
2025-01-13 |   1   | 2500000  | 2500000
2025-01-12 |   1   | 1300000  | 1300000
2025-01-10 |   1   | 1535000  | 1535000
```

### 1.2. 월별 매출 통계

```sql
SELECT
    DATE_FORMAT(ordered_at, '%Y-%m') AS 월,
    COUNT(order_id) AS 주문수,
    SUM(total_amount) AS 총매출,
    AVG(total_amount) AS 평균주문금액,
    MAX(total_amount) AS 최대주문금액,
    MIN(total_amount) AS 최소주문금액
FROM Orders
WHERE status != 'cancelled'
GROUP BY DATE_FORMAT(ordered_at, '%Y-%m')
ORDER BY 월 DESC;
```

### 1.3. 카테고리별 매출

```sql
SELECT
    c.name AS 카테고리,
    COUNT(DISTINCT o.order_id) AS 주문수,
    SUM(oi.quantity * oi.price) AS 총매출
FROM Categories c
JOIN Products p ON c.category_id = p.category_id
JOIN Order_Items oi ON p.product_id = oi.product_id
JOIN Orders o ON oi.order_id = o.order_id
WHERE o.status != 'cancelled'
GROUP BY c.category_id, c.name
ORDER BY 총매출 DESC;
```

---

## 2. 상품 분석 쿼리

### 2.1. 인기 상품 Top 10

```sql
SELECT
    p.product_id,
    p.name AS 상품명,
    p.price AS 가격,
    COUNT(oi.order_item_id) AS 판매횟수,
    SUM(oi.quantity) AS 총판매수량,
    SUM(oi.quantity * oi.price) AS 총매출
FROM Products p
JOIN Order_Items oi ON p.product_id = oi.product_id
JOIN Orders o ON oi.order_id = o.order_id
WHERE o.status != 'cancelled'
GROUP BY p.product_id, p.name, p.price
ORDER BY 총매출 DESC
LIMIT 10;
```

### 2.2. 평점 높은 상품

```sql
SELECT
    p.product_id,
    p.name AS 상품명,
    AVG(r.rating) AS 평균평점,
    COUNT(r.review_id) AS 리뷰수
FROM Products p
LEFT JOIN Reviews r ON p.product_id = r.product_id
GROUP BY p.product_id, p.name
HAVING 리뷰수 >= 1
ORDER BY 평균평점 DESC, 리뷰수 DESC
LIMIT 10;
```

### 2.3. 재고 부족 상품 (재고 < 10)

```sql
SELECT
    p.product_id,
    p.name AS 상품명,
    c.name AS 카테고리,
    p.stock AS 현재재고,
    CASE
        WHEN p.stock = 0 THEN '품절'
        WHEN p.stock < 5 THEN '긴급'
        WHEN p.stock < 10 THEN '주의'
    END AS 상태
FROM Products p
JOIN Categories c ON p.category_id = c.category_id
WHERE p.stock < 10
ORDER BY p.stock ASC;
```

---

## 3. 고객 분석 쿼리

### 3.1. VIP 고객 (구매 금액 상위)

```sql
SELECT
    u.user_id,
    u.name AS 고객명,
    u.email,
    COUNT(DISTINCT o.order_id) AS 주문횟수,
    SUM(o.total_amount) AS 총구매금액,
    AVG(o.total_amount) AS 평균주문금액
FROM Users u
JOIN Orders o ON u.user_id = o.user_id
WHERE o.status != 'cancelled'
GROUP BY u.user_id, u.name, u.email
ORDER BY 총구매금액 DESC
LIMIT 10;
```

### 3.2. 고객별 최근 주문 조회

```sql
SELECT
    u.user_id,
    u.name AS 고객명,
    o.order_id,
    o.total_amount AS 주문금액,
    o.status AS 주문상태,
    o.ordered_at AS 주문일시
FROM Users u
JOIN Orders o ON u.user_id = o.user_id
WHERE o.order_id = (
    SELECT order_id
    FROM Orders
    WHERE user_id = u.user_id
    ORDER BY ordered_at DESC
    LIMIT 1
)
ORDER BY o.ordered_at DESC;
```

### 3.3. 구매 이력이 없는 고객

```sql
SELECT
    u.user_id,
    u.name AS 고객명,
    u.email,
    u.created_at AS 가입일
FROM Users u
LEFT JOIN Orders o ON u.user_id = o.user_id
WHERE o.order_id IS NULL
ORDER BY u.created_at DESC;
```

---

## 4. Window Function 활용

### 4.1. 카테고리 내 상품 순위

```sql
SELECT
    c.name AS 카테고리,
    p.name AS 상품명,
    p.price AS 가격,
    RANK() OVER (PARTITION BY c.category_id ORDER BY p.price DESC) AS 가격순위
FROM Products p
JOIN Categories c ON p.category_id = c.category_id
ORDER BY c.name, 가격순위;
```

### 4.2. 월별 누적 매출

```sql
SELECT
    DATE_FORMAT(ordered_at, '%Y-%m') AS 월,
    SUM(total_amount) AS 월매출,
    SUM(SUM(total_amount)) OVER (ORDER BY DATE_FORMAT(ordered_at, '%Y-%m')) AS 누적매출
FROM Orders
WHERE status != 'cancelled'
GROUP BY DATE_FORMAT(ordered_at, '%Y-%m')
ORDER BY 월;
```

### 4.3. 고객별 주문 번호 부여

```sql
SELECT
    u.name AS 고객명,
    o.order_id,
    o.total_amount AS 주문금액,
    o.ordered_at AS 주문일시,
    ROW_NUMBER() OVER (PARTITION BY u.user_id ORDER BY o.ordered_at) AS 주문번호
FROM Orders o
JOIN Users u ON o.user_id = u.user_id
ORDER BY u.name, 주문번호;
```

---

## 5. 서브쿼리 활용

### 5.1. 평균 주문금액보다 높은 주문

```sql
SELECT
    o.order_id,
    u.name AS 고객명,
    o.total_amount AS 주문금액,
    (SELECT AVG(total_amount) FROM Orders WHERE status != 'cancelled') AS 평균주문금액
FROM Orders o
JOIN Users u ON o.user_id = u.user_id
WHERE o.total_amount > (
    SELECT AVG(total_amount)
    FROM Orders
    WHERE status != 'cancelled'
)
ORDER BY o.total_amount DESC;
```

### 5.2. 각 카테고리에서 가장 비싼 상품

```sql
SELECT
    c.name AS 카테고리,
    p.name AS 상품명,
    p.price AS 가격
FROM Products p
JOIN Categories c ON p.category_id = c.category_id
WHERE p.price = (
    SELECT MAX(price)
    FROM Products
    WHERE category_id = p.category_id
)
ORDER BY c.name;
```

### 5.3. 베스트셀러를 주문한 고객

```sql
WITH BestSeller AS (
    SELECT product_id
    FROM Order_Items
    GROUP BY product_id
    ORDER BY COUNT(*) DESC
    LIMIT 1
)
SELECT DISTINCT
    u.user_id,
    u.name AS 고객명,
    u.email
FROM Users u
JOIN Orders o ON u.user_id = o.user_id
JOIN Order_Items oi ON o.order_id = oi.order_id
WHERE oi.product_id = (SELECT product_id FROM BestSeller);
```

---

## 6. 복합 비즈니스 쿼리

### 6.1. 주문 상세 내역 (송장 형식)

```sql
SELECT
    o.order_id AS 주문번호,
    u.name AS 주문자,
    u.email,
    u.phone,
    a.recipient_name AS 수령인,
    a.phone AS 수령인연락처,
    a.address AS 배송지,
    o.ordered_at AS 주문일시,
    o.status AS 주문상태,
    p.method AS 결제수단,
    p.status AS 결제상태,
    prod.name AS 상품명,
    oi.quantity AS 수량,
    oi.price AS 단가,
    (oi.quantity * oi.price) AS 소계
FROM Orders o
JOIN Users u ON o.user_id = u.user_id
JOIN Addresses a ON o.address_id = a.address_id
LEFT JOIN Payments p ON o.order_id = p.order_id
JOIN Order_Items oi ON o.order_id = oi.order_id
JOIN Products prod ON oi.product_id = prod.product_id
WHERE o.order_id = 1;
```

### 6.2. 상품별 리뷰 요약

```sql
SELECT
    p.product_id,
    p.name AS 상품명,
    COUNT(r.review_id) AS 리뷰수,
    AVG(r.rating) AS 평균평점,
    COUNT(CASE WHEN r.rating = 5 THEN 1 END) AS 별5개,
    COUNT(CASE WHEN r.rating = 4 THEN 1 END) AS 별4개,
    COUNT(CASE WHEN r.rating = 3 THEN 1 END) AS 별3개,
    COUNT(CASE WHEN r.rating = 2 THEN 1 END) AS 별2개,
    COUNT(CASE WHEN r.rating = 1 THEN 1 END) AS 별1개
FROM Products p
LEFT JOIN Reviews r ON p.product_id = r.product_id
GROUP BY p.product_id, p.name
HAVING 리뷰수 > 0
ORDER BY 평균평점 DESC;
```

### 6.3. 장바구니 요약 (특정 사용자)

```sql
SELECT
    u.name AS 고객명,
    COUNT(c.cart_id) AS 상품수,
    SUM(c.quantity) AS 총수량,
    SUM(c.quantity * p.price) AS 총금액
FROM Users u
LEFT JOIN Carts c ON u.user_id = c.user_id
LEFT JOIN Products p ON c.product_id = p.product_id
WHERE u.user_id = 1
GROUP BY u.user_id, u.name;

-- 상세 내역
SELECT
    p.name AS 상품명,
    p.price AS 단가,
    c.quantity AS 수량,
    (p.price * c.quantity) AS 소계
FROM Carts c
JOIN Products p ON c.product_id = p.product_id
WHERE c.user_id = 1;
```

---

## 7. 실습 문제

### Mission 1: 미배송 주문 조회 (⭐⭐⭐)

**문제:**
결제는 완료되었으나 배송되지 않은 주문을 조회하세요.

**요구사항:**
- 주문번호, 고객명, 주문금액, 주문일, 결제수단 출력
- 주문일 기준 오래된 순서

**정답:**
```sql
SELECT
    o.order_id AS 주문번호,
    u.name AS 고객명,
    o.total_amount AS 주문금액,
    o.ordered_at AS 주문일,
    p.method AS 결제수단
FROM Orders o
JOIN Users u ON o.user_id = u.user_id
JOIN Payments p ON o.order_id = p.order_id
WHERE o.status = 'paid'
  AND p.status = 'completed'
ORDER BY o.ordered_at ASC;
```

---

### Mission 2: 한 번도 판매되지 않은 상품 (⭐⭐⭐⭐)

**문제:**
등록되었지만 한 번도 주문되지 않은 상품을 조회하세요.

**요구사항:**
- 상품명, 카테고리, 가격, 재고 출력
- 카테고리별로 정렬

**정답:**
```sql
SELECT
    p.product_id,
    p.name AS 상품명,
    c.name AS 카테고리,
    p.price AS 가격,
    p.stock AS 재고
FROM Products p
JOIN Categories c ON p.category_id = c.category_id
LEFT JOIN Order_Items oi ON p.product_id = oi.product_id
WHERE oi.order_item_id IS NULL
ORDER BY c.name, p.name;
```

---

### Mission 3: 월별 신규 고객 수 (⭐⭐⭐⭐)

**문제:**
월별로 신규 가입 고객 수를 조회하세요.

**요구사항:**
- 년-월, 신규고객수 출력
- 최근 6개월 데이터

**정답:**
```sql
SELECT
    DATE_FORMAT(created_at, '%Y-%m') AS 월,
    COUNT(user_id) AS 신규고객수
FROM Users
WHERE created_at >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH)
GROUP BY DATE_FORMAT(created_at, '%Y-%m')
ORDER BY 월 DESC;
```

---

### Mission 4: 재구매 고객 분석 (⭐⭐⭐⭐⭐)

**문제:**
2회 이상 주문한 고객과 그들의 평균 재구매 간격을 조회하세요.

**요구사항:**
- 고객명, 주문횟수, 평균재구매간격(일) 출력
- 주문횟수 많은 순서

**정답:**
```sql
WITH OrderDates AS (
    SELECT
        user_id,
        ordered_at,
        LEAD(ordered_at) OVER (PARTITION BY user_id ORDER BY ordered_at) AS next_order
    FROM Orders
    WHERE status != 'cancelled'
)
SELECT
    u.name AS 고객명,
    COUNT(DISTINCT o.order_id) AS 주문횟수,
    ROUND(AVG(DATEDIFF(od.next_order, od.ordered_at)), 1) AS 평균재구매간격_일
FROM Users u
JOIN Orders o ON u.user_id = o.user_id
LEFT JOIN OrderDates od ON u.user_id = od.user_id AND od.next_order IS NOT NULL
WHERE o.status != 'cancelled'
GROUP BY u.user_id, u.name
HAVING 주문횟수 >= 2
ORDER BY 주문횟수 DESC;
```

---

### Mission 5: 카테고리별 매출 비중 (⭐⭐⭐⭐⭐)

**문제:**
카테고리별 매출과 전체 매출 대비 비중을 계산하세요.

**요구사항:**
- 카테고리명, 매출, 비중(%) 출력
- 비중 기준 내림차순

**정답:**
```sql
WITH CategorySales AS (
    SELECT
        c.name AS 카테고리,
        SUM(oi.quantity * oi.price) AS 매출
    FROM Categories c
    JOIN Products p ON c.category_id = p.category_id
    JOIN Order_Items oi ON p.product_id = oi.product_id
    JOIN Orders o ON oi.order_id = o.order_id
    WHERE o.status != 'cancelled'
    GROUP BY c.category_id, c.name
),
TotalSales AS (
    SELECT SUM(매출) AS 총매출
    FROM CategorySales
)
SELECT
    cs.카테고리,
    cs.매출,
    ROUND((cs.매출 / ts.총매출) * 100, 2) AS 비중_퍼센트
FROM CategorySales cs, TotalSales ts
ORDER BY 비중_퍼센트 DESC;
```

---

## 8. 성능 고려사항

### 8.1. 인덱스 활용

```sql
-- 자주 조회하는 컬럼에 인덱스
CREATE INDEX idx_orders_user_id ON Orders(user_id);
CREATE INDEX idx_orders_status ON Orders(status);
CREATE INDEX idx_order_items_product_id ON Order_Items(product_id);

-- 복합 인덱스
CREATE INDEX idx_orders_user_status ON Orders(user_id, status);
```

### 8.2. 쿼리 최적화

```sql
-- ❌ 비효율적
SELECT * FROM Orders WHERE YEAR(ordered_at) = 2025;

-- ✅ 효율적 (인덱스 활용 가능)
SELECT * FROM Orders
WHERE ordered_at >= '2025-01-01'
  AND ordered_at < '2026-01-01';
```

### 8.3. EXPLAIN 사용

```sql
EXPLAIN SELECT
    u.name,
    COUNT(o.order_id) AS 주문수
FROM Users u
LEFT JOIN Orders o ON u.user_id = o.user_id
GROUP BY u.user_id, u.name;
```

---

## 강사 가이드

### 수업 진행 팁

**1. 비즈니스 요구사항 → SQL (40분)**
- "월별 매출을 보고 싶다" → SQL로 변환
- 학생들이 먼저 시도하게 유도
- 단계별로 쿼리 작성 (FROM → WHERE → GROUP BY → SELECT)

**2. Window Function 실습 (30분)**
- RANK, ROW_NUMBER, LEAD/LAG
- 실무 활용 사례 강조
- OVER 절의 PARTITION BY와 ORDER BY 설명

**3. 서브쿼리 vs JOIN (20분)**
- 언제 서브쿼리를 사용할지
- 성능 비교 (EXPLAIN)
- CTE(WITH) 활용

**4. 실습 문제 풀이 (40분)**
- Mission 1~5 함께 풀이
- 다양한 풀이 방법 비교
- 학생들의 다른 접근법 공유

### 자주 하는 질문

**Q1: LEFT JOIN vs INNER JOIN 언제 사용하나요?**
> A: 관계가 필수면 INNER JOIN, 선택이면 LEFT JOIN. 예: 주문-결제는 필수(INNER), 상품-리뷰는 선택(LEFT)

**Q2: Window Function이 GROUP BY보다 느린가요?**
> A: 일반적으로 비슷하지만, 각 행의 개별 정보가 필요하면 Window Function이 더 적합합니다.

**Q3: 서브쿼리를 JOIN으로 바꿀 수 있나요?**
> A: 대부분 가능합니다. 하지만 가독성을 위해 서브쿼리가 나을 때도 있습니다.

**Q4: CTE(WITH)와 서브쿼리의 차이는?**
> A: CTE는 가독성이 좋고 재사용 가능하지만, 성능은 비슷합니다. 복잡한 쿼리는 CTE를 권장합니다.

### 실습 중 흔한 실수

**1. GROUP BY 누락**
```sql
-- ❌ 에러 발생
SELECT name, COUNT(*) FROM Orders;

-- ✅ 올바른 쿼리
SELECT name, COUNT(*) FROM Orders GROUP BY name;
```

**2. 집계 함수와 일반 컬럼 혼용**
```sql
-- ❌ 잘못된 쿼리
SELECT user_id, name, SUM(total_amount)
FROM Orders;

-- ✅ GROUP BY 추가
SELECT user_id, name, SUM(total_amount)
FROM Orders
GROUP BY user_id, name;
```

**3. HAVING과 WHERE 혼동**
```sql
-- ❌ WHERE에서 집계 함수 사용 불가
SELECT category_id, COUNT(*)
FROM Products
WHERE COUNT(*) > 5
GROUP BY category_id;

-- ✅ HAVING 사용
SELECT category_id, COUNT(*)
FROM Products
GROUP BY category_id
HAVING COUNT(*) > 5;
```

---

## 요약

### 핵심 쿼리 패턴

**매출 통계:**
- 일별/월별 GROUP BY
- SUM, AVG, COUNT 활용

**순위 및 분석:**
- RANK, ROW_NUMBER
- PARTITION BY

**복합 조건:**
- 서브쿼리 (WHERE, FROM, SELECT)
- CTE (WITH)

**성능 최적화:**
- 인덱스 활용
- EXPLAIN 분석
- 불필요한 SELECT * 지양

### 다음 단계
다음 시간에는 **성능 최적화 및 인덱스 적용 (7.6)**을 진행합니다.

---

**복잡한 쿼리 작성 완료!** 이제 성능을 최적화해봅시다.
