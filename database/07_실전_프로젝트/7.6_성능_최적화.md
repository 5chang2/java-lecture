# 7.6. 성능 최적화 및 인덱스 적용

## 학습 목표
- 데이터베이스 성능 병목을 진단할 수 있다
- 적절한 인덱스 전략을 수립할 수 있다
- EXPLAIN을 사용하여 쿼리 실행 계획을 분석할 수 있다
- 쿼리 최적화 기법을 적용할 수 있다

---

## 1. 성능 진단

### 1.1. Slow Query Log 활성화

```sql
-- Slow Query Log 설정 확인
SHOW VARIABLES LIKE 'slow_query%';

-- Slow Query Log 활성화
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 2;  -- 2초 이상 쿼리 기록

-- 로그 파일 위치
SHOW VARIABLES LIKE 'slow_query_log_file';
```

### 1.2. 실행 시간 측정

```sql
-- 실행 시간 측정
SET profiling = 1;

-- 쿼리 실행
SELECT * FROM Orders WHERE user_id = 1;

-- 프로파일링 결과 확인
SHOW PROFILES;

-- 상세 분석
SHOW PROFILE FOR QUERY 1;
```

### 1.3. 현재 실행 중인 쿼리 확인

```sql
-- 실행 중인 프로세스 확인
SHOW PROCESSLIST;

-- 느린 쿼리 강제 종료
KILL [process_id];
```

---

## 2. 인덱스 전략

### 2.1. 인덱스가 필요한 경우

✅ **인덱스를 생성해야 하는 경우:**
- WHERE 절에 자주 사용되는 컬럼
- JOIN 조건에 사용되는 컬럼 (FK)
- ORDER BY, GROUP BY에 사용되는 컬럼
- UNIQUE 제약이 필요한 컬럼

❌ **인덱스가 불필요한 경우:**
- 테이블 크기가 작은 경우 (< 1000 rows)
- 컬럼 값의 종류가 적은 경우 (예: 성별)
- INSERT/UPDATE가 빈번한 테이블

### 2.2. E-Shop 프로젝트 인덱스 설계

```sql
-- 1. Users 테이블
CREATE INDEX idx_users_email ON Users(email);  -- 로그인 조회

-- 2. Orders 테이블
CREATE INDEX idx_orders_user_id ON Orders(user_id);  -- 회원별 주문 조회
CREATE INDEX idx_orders_status ON Orders(status);    -- 상태별 조회
CREATE INDEX idx_orders_ordered_at ON Orders(ordered_at);  -- 날짜별 조회

-- 복합 인덱스
CREATE INDEX idx_orders_user_status ON Orders(user_id, status);

-- 3. Order_Items 테이블
CREATE INDEX idx_order_items_order_id ON Order_Items(order_id);
CREATE INDEX idx_order_items_product_id ON Order_Items(product_id);

-- 4. Products 테이블
CREATE INDEX idx_products_category_id ON Products(category_id);
CREATE INDEX idx_products_name ON Products(name);  -- 상품명 검색

-- 5. Carts 테이블
CREATE INDEX idx_carts_user_id ON Carts(user_id);
CREATE INDEX idx_carts_product_id ON Carts(product_id);

-- 6. Reviews 테이블
CREATE INDEX idx_reviews_product_id ON Reviews(product_id);
CREATE INDEX idx_reviews_user_id ON Reviews(user_id);

-- 7. Payments 테이블
CREATE INDEX idx_payments_order_id ON Payments(order_id);
CREATE INDEX idx_payments_status ON Payments(status);
```

### 2.3. 인덱스 확인

```sql
-- 테이블의 인덱스 목록
SHOW INDEX FROM Orders;

-- 인덱스 사용 통계
SELECT
    TABLE_NAME,
    INDEX_NAME,
    SEQ_IN_INDEX,
    COLUMN_NAME,
    CARDINALITY
FROM information_schema.STATISTICS
WHERE TABLE_SCHEMA = 'eshop'
ORDER BY TABLE_NAME, INDEX_NAME, SEQ_IN_INDEX;
```

---

## 3. EXPLAIN 분석

### 3.1. EXPLAIN 기본 사용

```sql
EXPLAIN SELECT * FROM Orders WHERE user_id = 1;
```

**주요 컬럼 해석:**
- `type`: 조인 타입 (const > eq_ref > ref > range > index > ALL)
- `possible_keys`: 사용 가능한 인덱스
- `key`: 실제 사용된 인덱스
- `rows`: 검사할 예상 행 수
- `Extra`: 추가 정보

### 3.2. 인덱스 전후 비교

**인덱스 없을 때:**
```sql
DROP INDEX idx_orders_user_id ON Orders;

EXPLAIN SELECT * FROM Orders WHERE user_id = 1;
```

**결과:**
```
type: ALL
rows: 5
Extra: Using where
```
→ 전체 테이블 스캔 (느림)

**인덱스 생성 후:**
```sql
CREATE INDEX idx_orders_user_id ON Orders(user_id);

EXPLAIN SELECT * FROM Orders WHERE user_id = 1;
```

**결과:**
```
type: ref
key: idx_orders_user_id
rows: 2
```
→ 인덱스 사용 (빠름)

### 3.3. 복합 쿼리 분석

```sql
EXPLAIN
SELECT
    u.name,
    COUNT(o.order_id) AS 주문수,
    SUM(o.total_amount) AS 총금액
FROM Users u
LEFT JOIN Orders o ON u.user_id = o.user_id
WHERE o.status = 'delivered'
GROUP BY u.user_id, u.name;
```

**최적화 전:**
```
type: ALL (Users), ALL (Orders)
Extra: Using temporary; Using filesort
```

**최적화 후 (인덱스 추가):**
```sql
CREATE INDEX idx_orders_user_status ON Orders(user_id, status);

-- 다시 EXPLAIN
```

**결과:**
```
type: index (Users), ref (Orders)
key: idx_orders_user_status
Extra: Using index
```

---

## 4. 쿼리 최적화 기법

### 4.1. SELECT * 지양

```sql
-- ❌ 비효율적
SELECT * FROM Products WHERE category_id = 1;

-- ✅ 필요한 컬럼만 선택
SELECT product_id, name, price FROM Products WHERE category_id = 1;
```

### 4.2. WHERE 절 최적화

```sql
-- ❌ 함수 사용 시 인덱스 무효화
SELECT * FROM Orders WHERE YEAR(ordered_at) = 2025;

-- ✅ 인덱스 활용 가능
SELECT * FROM Orders
WHERE ordered_at >= '2025-01-01'
  AND ordered_at < '2026-01-01';
```

### 4.3. JOIN 최적화

```sql
-- ❌ 서브쿼리 (느림)
SELECT *
FROM Products
WHERE category_id IN (
    SELECT category_id FROM Categories WHERE name = '전자기기'
);

-- ✅ JOIN (빠름)
SELECT p.*
FROM Products p
JOIN Categories c ON p.category_id = c.category_id
WHERE c.name = '전자기기';
```

### 4.4. LIMIT 활용

```sql
-- ❌ 모든 데이터 조회
SELECT * FROM Orders ORDER BY ordered_at DESC;

-- ✅ 필요한 만큼만
SELECT * FROM Orders ORDER BY ordered_at DESC LIMIT 10;
```

### 4.5. EXISTS vs IN

```sql
-- ❌ IN (대량 데이터 시 느림)
SELECT *
FROM Users
WHERE user_id IN (
    SELECT user_id FROM Orders WHERE status = 'delivered'
);

-- ✅ EXISTS (빠름)
SELECT *
FROM Users u
WHERE EXISTS (
    SELECT 1 FROM Orders o
    WHERE o.user_id = u.user_id AND o.status = 'delivered'
);
```

---

## 5. 인덱스 최적화

### 5.1. 복합 인덱스 순서

**원칙: 선택도가 높은 컬럼을 앞에**

```sql
-- ❌ 잘못된 순서
CREATE INDEX idx_orders_bad ON Orders(status, user_id);
-- status는 선택도가 낮음 (pending, paid, shipped, delivered, cancelled)

-- ✅ 올바른 순서
CREATE INDEX idx_orders_good ON Orders(user_id, status);
-- user_id는 선택도가 높음 (사용자별로 구분)
```

**테스트:**
```sql
-- user_id, status 순서의 인덱스 활용
EXPLAIN SELECT * FROM Orders WHERE user_id = 1 AND status = 'delivered';
-- ✅ 인덱스 사용

EXPLAIN SELECT * FROM Orders WHERE status = 'delivered' AND user_id = 1;
-- ✅ 인덱스 사용 (MySQL은 순서 자동 최적화)

EXPLAIN SELECT * FROM Orders WHERE status = 'delivered';
-- ❌ 인덱스 사용 불가 (첫 번째 컬럼이 아님)
```

### 5.2. 커버링 인덱스

**커버링 인덱스:** 쿼리가 인덱스만으로 처리 가능

```sql
-- 인덱스 생성
CREATE INDEX idx_products_category_name_price ON Products(category_id, name, price);

-- 커버링 인덱스 활용
EXPLAIN SELECT name, price FROM Products WHERE category_id = 1;
-- Extra: Using index (테이블 접근 없이 인덱스만 사용)
```

### 5.3. 불필요한 인덱스 제거

```sql
-- 중복 인덱스 확인
SELECT
    TABLE_NAME,
    INDEX_NAME,
    GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) AS COLUMNS
FROM information_schema.STATISTICS
WHERE TABLE_SCHEMA = 'eshop'
GROUP BY TABLE_NAME, INDEX_NAME;

-- 사용되지 않는 인덱스 제거
DROP INDEX idx_unused ON Products;
```

---

## 6. 대용량 데이터 처리

### 6.1. 배치 처리

```sql
-- ❌ 한 번에 처리 (메모리 부족 위험)
UPDATE Products SET stock = stock * 1.1;

-- ✅ 배치 처리
UPDATE Products SET stock = stock * 1.1 WHERE product_id BETWEEN 1 AND 1000;
UPDATE Products SET stock = stock * 1.1 WHERE product_id BETWEEN 1001 AND 2000;
-- ...
```

### 6.2. 파티셔닝 (선택)

```sql
-- 주문 테이블을 월별로 파티셔닝
ALTER TABLE Orders
PARTITION BY RANGE (YEAR(ordered_at) * 100 + MONTH(ordered_at)) (
    PARTITION p202501 VALUES LESS THAN (202502),
    PARTITION p202502 VALUES LESS THAN (202503),
    PARTITION p202503 VALUES LESS THAN (202504),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

---

## 7. 실습 문제

### Mission 1: 느린 쿼리 최적화 (⭐⭐⭐)

**문제:**
다음 쿼리를 최적화하세요.

```sql
SELECT * FROM Orders WHERE MONTH(ordered_at) = 1 AND YEAR(ordered_at) = 2025;
```

**정답:**
```sql
-- 1. 인덱스 활용 가능하도록 수정
SELECT * FROM Orders
WHERE ordered_at >= '2025-01-01'
  AND ordered_at < '2025-02-01';

-- 2. 필요한 컬럼만 선택
SELECT order_id, user_id, total_amount, status
FROM Orders
WHERE ordered_at >= '2025-01-01'
  AND ordered_at < '2025-02-01';

-- 3. 인덱스 생성
CREATE INDEX idx_orders_ordered_at ON Orders(ordered_at);
```

---

### Mission 2: 복합 인덱스 설계 (⭐⭐⭐⭐)

**문제:**
다음 쿼리를 위한 최적의 인덱스를 설계하세요.

```sql
SELECT product_id, name, price
FROM Products
WHERE category_id = 1 AND stock > 0
ORDER BY price DESC;
```

**정답:**
```sql
-- 최적의 복합 인덱스
CREATE INDEX idx_products_cat_stock_price ON Products(category_id, stock, price DESC);

-- 또는 커버링 인덱스
CREATE INDEX idx_products_covering ON Products(category_id, stock, price, product_id, name);

-- EXPLAIN으로 확인
EXPLAIN SELECT product_id, name, price
FROM Products
WHERE category_id = 1 AND stock > 0
ORDER BY price DESC;
-- Extra: Using index (커버링 인덱스 사용)
```

---

### Mission 3: EXISTS vs IN 성능 비교 (⭐⭐⭐⭐⭐)

**문제:**
리뷰를 작성한 사용자를 조회하는 두 쿼리의 성능을 비교하세요.

**쿼리 1 (IN):**
```sql
SELECT *
FROM Users
WHERE user_id IN (SELECT DISTINCT user_id FROM Reviews);
```

**쿼리 2 (EXISTS):**
```sql
SELECT *
FROM Users u
WHERE EXISTS (SELECT 1 FROM Reviews r WHERE r.user_id = u.user_id);
```

**정답:**
```sql
-- 1. 인덱스 생성
CREATE INDEX idx_reviews_user_id ON Reviews(user_id);

-- 2. EXPLAIN으로 비교
EXPLAIN SELECT * FROM Users WHERE user_id IN (SELECT DISTINCT user_id FROM Reviews);
-- type: ALL 또는 range

EXPLAIN SELECT * FROM Users u WHERE EXISTS (SELECT 1 FROM Reviews r WHERE r.user_id = u.user_id);
-- type: eq_ref (더 효율적)

-- 3. 실행 시간 측정
SET profiling = 1;

-- IN 쿼리
SELECT * FROM Users WHERE user_id IN (SELECT DISTINCT user_id FROM Reviews);

-- EXISTS 쿼리
SELECT * FROM Users u WHERE EXISTS (SELECT 1 FROM Reviews r WHERE r.user_id = u.user_id);

SHOW PROFILES;

-- 결론: EXISTS가 일반적으로 더 빠름 (특히 대용량 데이터)
```

---

## 8. 데이터베이스 설정 튜닝

### 8.1. InnoDB 버퍼 풀

```sql
-- 현재 설정 확인
SHOW VARIABLES LIKE 'innodb_buffer_pool_size';

-- my.cnf 또는 my.ini에서 설정
-- innodb_buffer_pool_size = 1G  (물리 메모리의 70-80%)
```

### 8.2. 쿼리 캐시 (MySQL 8.0 미만)

```sql
-- MySQL 5.7 이하에서만 사용 가능
SHOW VARIABLES LIKE 'query_cache%';

-- MySQL 8.0+는 쿼리 캐시 제거됨
-- 대신 애플리케이션 레벨 캐싱 (Redis, Memcached) 사용
```

### 8.3. 연결 수 설정

```sql
-- 최대 연결 수 확인
SHOW VARIABLES LIKE 'max_connections';

-- 현재 연결 수
SHOW STATUS LIKE 'Threads_connected';

-- my.cnf에서 설정
-- max_connections = 200
```

---

## 강사 가이드

### 수업 진행 팁

**1. 성능 진단 실습 (30분)**
- Slow Query Log 설정
- EXPLAIN 사용법
- 인덱스 전후 비교 시연

**2. 인덱스 전략 (40분)**
- 단일 vs 복합 인덱스
- 인덱스 순서의 중요성
- 커버링 인덱스 개념

**3. 쿼리 최적화 (30분)**
- 함수 사용 금지 (WHERE 절)
- JOIN vs 서브쿼리
- EXISTS vs IN

**4. 실전 문제 풀이 (30분)**
- Mission 1~3 함께 풀이
- 학생들의 다양한 해결책 공유

### 자주 하는 질문

**Q1: 모든 컬럼에 인덱스를 만들면 안 되나요?**
> A: 인덱스는 조회 속도를 높이지만 INSERT/UPDATE/DELETE는 느려집니다. 자주 조회하는 컬럼에만 생성하세요.

**Q2: 복합 인덱스 순서가 왜 중요한가요?**
> A: 첫 번째 컬럼으로 먼저 필터링하므로, 선택도가 높은 컬럼을 앞에 두어야 합니다.

**Q3: EXPLAIN의 type이 ALL이면 무조건 나쁜가요?**
> A: 테이블 크기가 작으면 괜찮습니다. 하지만 대용량 테이블에서는 인덱스를 고려하세요.

**Q4: 인덱스를 너무 많이 만들면 어떻게 되나요?**
> A: 저장 공간 낭비와 쓰기 성능 저하가 발생합니다. 꼭 필요한 인덱스만 유지하세요.

### 실습 중 흔한 실수

**1. 함수 사용으로 인덱스 무효화**
```sql
-- ❌ 인덱스 사용 불가
WHERE YEAR(ordered_at) = 2025

-- ✅ 인덱스 사용 가능
WHERE ordered_at >= '2025-01-01' AND ordered_at < '2026-01-01'
```

**2. 복합 인덱스 순서 무시**
```sql
-- 인덱스: (user_id, status)
-- ❌ 인덱스 사용 불가
WHERE status = 'delivered'

-- ✅ 인덱스 사용 가능
WHERE user_id = 1 AND status = 'delivered'
```

**3. SELECT * 남용**
```sql
-- ❌ 불필요한 컬럼까지 조회
SELECT * FROM Products WHERE category_id = 1;

-- ✅ 필요한 컬럼만
SELECT product_id, name, price FROM Products WHERE category_id = 1;
```

---

## 요약

### 인덱스 전략

**생성:**
- WHERE, JOIN, ORDER BY에 자주 사용되는 컬럼
- 복합 인덱스: 선택도 높은 컬럼 우선
- 커버링 인덱스: 쿼리에 필요한 모든 컬럼 포함

**제거:**
- 중복 인덱스
- 사용되지 않는 인덱스

### 쿼리 최적화

**피해야 할 것:**
- SELECT *
- WHERE 절에 함수 사용
- 불필요한 서브쿼리

**권장 사항:**
- 필요한 컬럼만 선택
- JOIN 활용
- EXISTS 사용 (IN 대신)
- LIMIT 활용

### EXPLAIN 주요 지표

- `type`: const > eq_ref > ref > range > index > ALL
- `key`: 인덱스 사용 여부
- `rows`: 검사할 행 수 (적을수록 좋음)
- `Extra`: Using index (커버링 인덱스), Using filesort (피해야 함)

### 다음 단계
다음 시간에는 **프로젝트 마무리 및 발표 (7.7)**를 진행합니다.

---

**성능 최적화 완료!** 이제 프로젝트를 마무리하고 발표 준비를 해봅시다.
