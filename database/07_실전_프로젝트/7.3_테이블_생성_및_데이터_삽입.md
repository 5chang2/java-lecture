# 7.3. 테이블 생성 및 샘플 데이터 삽입

## 학습 목표
- DDL을 사용하여 E-Shop 테이블을 생성할 수 있다
- 제약조건을 올바르게 설정할 수 있다
- 외래 키 순서를 고려하여 데이터를 삽입할 수 있다
- 샘플 데이터로 데이터베이스를 초기화할 수 있다

---

## 1. 데이터베이스 및 테이블 생성

### 1.1. 데이터베이스 생성

```sql
-- 기존 데이터베이스 삭제 (주의!)
DROP DATABASE IF EXISTS eshop;

-- 새 데이터베이스 생성
CREATE DATABASE eshop CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- 데이터베이스 선택
USE eshop;
```

### 1.2. Users 테이블

```sql
CREATE TABLE Users (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    email VARCHAR(100) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL COMMENT '해시된 비밀번호',
    name VARCHAR(50) NOT NULL,
    phone VARCHAR(20),
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) COMMENT '회원 정보';
```

### 1.3. Addresses 테이블

```sql
CREATE TABLE Addresses (
    address_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    recipient_name VARCHAR(50) NOT NULL,
    phone VARCHAR(20) NOT NULL,
    address VARCHAR(255) NOT NULL,
    zipcode VARCHAR(10),
    is_default BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (user_id) REFERENCES Users(user_id) ON DELETE CASCADE
) COMMENT '배송지 정보';
```

### 1.4. Categories 테이블

```sql
CREATE TABLE Categories (
    category_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    description TEXT
) COMMENT '상품 카테고리';
```

### 1.5. Products 테이블

```sql
CREATE TABLE Products (
    product_id INT AUTO_INCREMENT PRIMARY KEY,
    category_id INT NOT NULL,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    price DECIMAL(10,2) NOT NULL CHECK (price >= 0),
    stock INT DEFAULT 0 CHECK (stock >= 0),
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (category_id) REFERENCES Categories(category_id)
) COMMENT '상품 정보';
```

### 1.6. Carts 테이블

```sql
CREATE TABLE Carts (
    cart_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT DEFAULT 1 CHECK (quantity > 0),
    added_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES Users(user_id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES Products(product_id) ON DELETE CASCADE
) COMMENT '장바구니';
```

### 1.7. Orders 테이블

```sql
CREATE TABLE Orders (
    order_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    address_id INT NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL CHECK (total_amount > 0),
    status ENUM('pending', 'paid', 'shipped', 'delivered', 'cancelled') DEFAULT 'pending',
    ordered_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES Users(user_id),
    FOREIGN KEY (address_id) REFERENCES Addresses(address_id)
) COMMENT '주문 정보';
```

### 1.8. Order_Items 테이블

```sql
CREATE TABLE Order_Items (
    order_item_id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL CHECK (quantity > 0),
    price DECIMAL(10,2) NOT NULL COMMENT '주문 당시 가격',
    FOREIGN KEY (order_id) REFERENCES Orders(order_id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES Products(product_id)
) COMMENT '주문 상세';
```

### 1.9. Payments 테이블

```sql
CREATE TABLE Payments (
    payment_id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT UNIQUE NOT NULL,
    method ENUM('card', 'bank', 'kakao', 'naver') NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    status ENUM('pending', 'completed', 'failed', 'refunded') DEFAULT 'pending',
    paid_at DATETIME,
    FOREIGN KEY (order_id) REFERENCES Orders(order_id) ON DELETE CASCADE
) COMMENT '결제 정보';
```

### 1.10. Reviews 테이블

```sql
CREATE TABLE Reviews (
    review_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    product_id INT NOT NULL,
    order_id INT NOT NULL,
    rating INT CHECK (rating BETWEEN 1 AND 5),
    content TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES Users(user_id),
    FOREIGN KEY (product_id) REFERENCES Products(product_id),
    FOREIGN KEY (order_id) REFERENCES Orders(order_id)
) COMMENT '상품 리뷰';
```

---

## 2. 샘플 데이터 삽입

### 2.1. 삽입 순서
```
1. Users (외래 키 참조 없음)
2. Categories (외래 키 참조 없음)
3. Addresses (Users 참조)
4. Products (Categories 참조)
5. Carts (Users, Products 참조)
6. Orders (Users, Addresses 참조)
7. Order_Items (Orders, Products 참조)
8. Payments (Orders 참조)
9. Reviews (Users, Products, Orders 참조)
```

### 2.2. Users 데이터

```sql
INSERT INTO Users (email, password, name, phone) VALUES
('alice@example.com', SHA2('password123', 256), '홍길동', '010-1234-5678'),
('bob@example.com', SHA2('password123', 256), '김철수', '010-2345-6789'),
('charlie@example.com', SHA2('password123', 256), '이영희', '010-3456-7890'),
('david@example.com', SHA2('password123', 256), '박민수', '010-4567-8901'),
('eve@example.com', SHA2('password123', 256), '정수진', '010-5678-9012');
```

### 2.3. Categories 데이터

```sql
INSERT INTO Categories (name, description) VALUES
('전자기기', '노트북, 태블릿, 스마트폰 등'),
('가전제품', 'TV, 냉장고, 세탁기 등'),
('도서', '소설, 만화, 전문서적 등'),
('의류', '남성복, 여성복, 아동복 등'),
('식품', '과자, 음료, 건강식품 등');
```

### 2.4. Addresses 데이터

```sql
INSERT INTO Addresses (user_id, recipient_name, phone, address, zipcode, is_default) VALUES
(1, '홍길동', '010-1234-5678', '서울특별시 강남구 테헤란로 123', '06234', TRUE),
(1, '홍길동', '010-1234-5678', '서울특별시 서초구 반포대로 456', '06543', FALSE),
(2, '김철수', '010-2345-6789', '부산광역시 해운대구 해운대로 789', '48123', TRUE),
(3, '이영희', '010-3456-7890', '인천광역시 남동구 인주대로 321', '21543', TRUE),
(4, '박민수', '010-4567-8901', '대구광역시 중구 동성로 654', '41953', TRUE);
```

### 2.5. Products 데이터

```sql
INSERT INTO Products (category_id, name, description, price, stock) VALUES
-- 전자기기
(1, '삼성 노트북 갤럭시북', '15.6인치, 16GB RAM, 512GB SSD', 1500000, 10),
(1, 'LG 그램 17', '17인치 초경량 노트북', 2000000, 5),
(1, '아이패드 프로', '12.9인치, M2 칩', 1300000, 15),
(1, '갤럭시 탭 S9', '11인치 안드로이드 태블릿', 800000, 20),

-- 가전제품
(2, 'LG 올레드 TV', '55인치 4K OLED', 2500000, 8),
(2, '삼성 비스포크 냉장고', '4도어 냉장고', 3000000, 3),
(2, 'LG 트롬 세탁기', '21kg 드럼 세탁기', 1200000, 6),

-- 도서
(3, '이것이 자바다', 'Java 프로그래밍 기초', 35000, 50),
(3, '클린 코드', '애자일 소프트웨어 장인 정신', 29000, 40),
(3, '해리포터 세트', '전7권 박스 세트', 120000, 25),

-- 의류
(4, '남성 코트', '울 100% 겨울 코트', 250000, 30),
(4, '여성 원피스', '봄/가을 원피스', 89000, 45),

-- 식품
(5, '허니버터칩 10개입', '인기 스낵', 15000, 100),
(5, '프로틴 쉐이크', '헬스 보충제', 45000, 60);
```

### 2.6. Carts 데이터

```sql
INSERT INTO Carts (user_id, product_id, quantity) VALUES
(1, 1, 1),  -- 홍길동 → 삼성 노트북
(1, 8, 2),  -- 홍길동 → 이것이 자바다 2권
(2, 3, 1),  -- 김철수 → 아이패드 프로
(3, 5, 1),  -- 이영희 → LG TV
(4, 13, 3); -- 박민수 → 허니버터칩 3개
```

### 2.7. Orders 데이터

```sql
INSERT INTO Orders (user_id, address_id, total_amount, status) VALUES
(1, 1, 1535000, 'delivered'),  -- 홍길동 주문 (노트북 + 책)
(2, 3, 1300000, 'shipped'),    -- 김철수 주문 (아이패드)
(3, 4, 2500000, 'paid'),       -- 이영희 주문 (TV)
(4, 5, 250000, 'pending'),     -- 박민수 주문 (코트)
(5, 1, 89000, 'delivered');    -- 정수진 주문 (원피스) - 주의: 배송지는 임시
```

**주의:** 마지막 주문(정수진)은 배송지가 없으므로, 실제로는 Addresses 삽입이 필요합니다.

```sql
-- 정수진 배송지 추가
INSERT INTO Addresses (user_id, recipient_name, phone, address, zipcode, is_default)
VALUES (5, '정수진', '010-5678-9012', '광주광역시 서구 상무대로 999', '61943', TRUE);

-- Orders 수정
UPDATE Orders SET address_id = 6 WHERE order_id = 5;
```

### 2.8. Order_Items 데이터

```sql
INSERT INTO Order_Items (order_id, product_id, quantity, price) VALUES
-- 주문 1: 홍길동 (노트북 + 책)
(1, 1, 1, 1500000),
(1, 8, 1, 35000),

-- 주문 2: 김철수 (아이패드)
(2, 3, 1, 1300000),

-- 주문 3: 이영희 (TV)
(3, 5, 1, 2500000),

-- 주문 4: 박민수 (코트)
(4, 11, 1, 250000),

-- 주문 5: 정수진 (원피스)
(5, 12, 1, 89000);
```

### 2.9. Payments 데이터

```sql
INSERT INTO Payments (order_id, method, amount, status, paid_at) VALUES
(1, 'card', 1535000, 'completed', '2025-01-10 14:30:00'),
(2, 'kakao', 1300000, 'completed', '2025-01-12 10:15:00'),
(3, 'bank', 2500000, 'completed', '2025-01-13 16:45:00'),
(4, 'card', 250000, 'pending', NULL),
(5, 'naver', 89000, 'completed', '2025-01-15 09:20:00');
```

### 2.10. Reviews 데이터

```sql
INSERT INTO Reviews (user_id, product_id, order_id, rating, content) VALUES
(1, 1, 1, 5, '노트북 성능이 훌륭합니다! 배송도 빨랐어요.'),
(1, 8, 1, 4, 'Java 공부하기 좋은 책입니다.'),
(2, 3, 2, 5, '아이패드 프로 정말 만족스럽습니다.'),
(3, 5, 3, 4, 'TV 화질이 좋네요. 다만 가격이 조금 비쌉니다.'),
(5, 12, 5, 5, '원피스 디자인이 예뻐요!');
```

---

## 3. 데이터 검증

### 3.1. 테이블 목록 확인

```sql
SHOW TABLES;
```

**예상 결과:**
```
+------------------+
| Tables_in_eshop  |
+------------------+
| Addresses        |
| Carts            |
| Categories       |
| Order_Items      |
| Orders           |
| Payments         |
| Products         |
| Reviews          |
| Users            |
+------------------+
```

### 3.2. 각 테이블 데이터 개수 확인

```sql
SELECT 'Users' AS 테이블, COUNT(*) AS 개수 FROM Users
UNION ALL
SELECT 'Addresses', COUNT(*) FROM Addresses
UNION ALL
SELECT 'Categories', COUNT(*) FROM Categories
UNION ALL
SELECT 'Products', COUNT(*) FROM Products
UNION ALL
SELECT 'Carts', COUNT(*) FROM Carts
UNION ALL
SELECT 'Orders', COUNT(*) FROM Orders
UNION ALL
SELECT 'Order_Items', COUNT(*) FROM Order_Items
UNION ALL
SELECT 'Payments', COUNT(*) FROM Payments
UNION ALL
SELECT 'Reviews', COUNT(*) FROM Reviews;
```

**예상 결과:**
```
+--------------+------+
| 테이블        | 개수  |
+--------------+------+
| Users        |    5 |
| Addresses    |    6 |
| Categories   |    5 |
| Products     |   14 |
| Carts        |    5 |
| Orders       |    5 |
| Order_Items  |    6 |
| Payments     |    5 |
| Reviews      |    5 |
+--------------+------+
```

### 3.3. 외래 키 관계 확인

```sql
-- 주문과 사용자 조인
SELECT o.order_id, u.name, o.total_amount, o.status
FROM Orders o
JOIN Users u ON o.user_id = u.user_id;
```

### 3.4. 주문 상세 확인

```sql
SELECT
    o.order_id,
    u.name AS 주문자,
    p.name AS 상품명,
    oi.quantity AS 수량,
    oi.price AS 가격,
    (oi.quantity * oi.price) AS 소계
FROM Orders o
JOIN Users u ON o.user_id = u.user_id
JOIN Order_Items oi ON o.order_id = oi.order_id
JOIN Products p ON oi.product_id = p.product_id;
```

---

## 4. 실습 문제

### Mission 1: 전체 스크립트 실행 (⭐⭐)

**문제:**
위의 모든 SQL을 하나의 파일(`eshop_setup.sql`)로 만들고 실행하세요.

**파일 구조:**
```sql
-- 1. 데이터베이스 생성
DROP DATABASE IF EXISTS eshop;
CREATE DATABASE eshop CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE eshop;

-- 2. 테이블 생성 (9개)
-- ...

-- 3. 데이터 삽입 (순서대로)
-- ...

-- 4. 검증 쿼리
-- ...
```

**실행 방법:**
```bash
mysql -u root -p < eshop_setup.sql
```

---

### Mission 2: 재고 감소 구현 (⭐⭐⭐⭐)

**문제:**
주문이 생성될 때 상품 재고를 자동으로 감소시키는 트리거를 작성하세요.

**요구사항:**
- Order_Items에 INSERT 시 Products.stock 감소
- 재고가 부족하면 에러 발생

**정답:**
```sql
DELIMITER $$

CREATE TRIGGER decrease_stock
AFTER INSERT ON Order_Items
FOR EACH ROW
BEGIN
    DECLARE current_stock INT;

    -- 현재 재고 확인
    SELECT stock INTO current_stock
    FROM Products
    WHERE product_id = NEW.product_id;

    -- 재고 부족 체크
    IF current_stock < NEW.quantity THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '재고가 부족합니다';
    ELSE
        -- 재고 감소
        UPDATE Products
        SET stock = stock - NEW.quantity
        WHERE product_id = NEW.product_id;
    END IF;
END$$

DELIMITER ;
```

**테스트:**
```sql
-- 재고 확인
SELECT product_id, name, stock FROM Products WHERE product_id = 1;

-- 주문 생성 (재고가 충분한 경우)
INSERT INTO Order_Items (order_id, product_id, quantity, price)
VALUES (1, 1, 2, 1500000);

-- 재고 다시 확인
SELECT product_id, name, stock FROM Products WHERE product_id = 1;
-- stock이 2 감소했는지 확인
```

---

### Mission 3: 주문 금액 자동 계산 (⭐⭐⭐⭐⭐)

**문제:**
Order_Items가 추가될 때 Orders.total_amount를 자동으로 업데이트하는 트리거를 작성하세요.

**정답:**
```sql
DELIMITER $$

CREATE TRIGGER update_order_total
AFTER INSERT ON Order_Items
FOR EACH ROW
BEGIN
    UPDATE Orders
    SET total_amount = (
        SELECT SUM(quantity * price)
        FROM Order_Items
        WHERE order_id = NEW.order_id
    )
    WHERE order_id = NEW.order_id;
END$$

DELIMITER ;
```

**테스트:**
```sql
-- 새 주문 생성
INSERT INTO Orders (user_id, address_id, total_amount, status)
VALUES (1, 1, 0, 'pending');  -- total_amount는 임시로 0

SET @new_order_id = LAST_INSERT_ID();

-- 주문 항목 추가
INSERT INTO Order_Items (order_id, product_id, quantity, price)
VALUES (@new_order_id, 1, 1, 1500000);

INSERT INTO Order_Items (order_id, product_id, quantity, price)
VALUES (@new_order_id, 8, 2, 35000);

-- 총 금액 확인
SELECT order_id, total_amount FROM Orders WHERE order_id = @new_order_id;
-- 1570000이 되어야 함 (1500000 + 70000)
```

---

### Mission 4: 평균 평점 업데이트 (⭐⭐⭐⭐⭐)

**문제:**
Products 테이블에 `avg_rating` 컬럼을 추가하고, 리뷰가 작성될 때마다 자동으로 업데이트하세요.

**정답:**
```sql
-- 1. 컬럼 추가
ALTER TABLE Products ADD COLUMN avg_rating DECIMAL(3,2) DEFAULT 0;

-- 2. 트리거 생성
DELIMITER $$

CREATE TRIGGER update_avg_rating_insert
AFTER INSERT ON Reviews
FOR EACH ROW
BEGIN
    UPDATE Products
    SET avg_rating = (
        SELECT AVG(rating)
        FROM Reviews
        WHERE product_id = NEW.product_id
    )
    WHERE product_id = NEW.product_id;
END$$

CREATE TRIGGER update_avg_rating_delete
AFTER DELETE ON Reviews
FOR EACH ROW
BEGIN
    UPDATE Products
    SET avg_rating = IFNULL((
        SELECT AVG(rating)
        FROM Reviews
        WHERE product_id = OLD.product_id
    ), 0)
    WHERE product_id = OLD.product_id;
END$$

DELIMITER ;

-- 3. 기존 데이터 업데이트
UPDATE Products p
SET avg_rating = (
    SELECT AVG(rating) FROM Reviews WHERE product_id = p.product_id
);
```

---

## 강사 가이드

### 수업 진행 팁

**1. DDL 작성 실습 (40분)**
- 테이블 생성 순서의 중요성 강조
- 외래 키 제약조건 설명
- ENUM, CHECK, DEFAULT 활용

**2. 데이터 삽입 실습 (30분)**
- 외래 키 순서 고려
- SHA2()로 비밀번호 해시
- LAST_INSERT_ID() 활용

**3. 트리거 실습 (40분)**
- 재고 감소 자동화
- 주문 금액 자동 계산
- 평균 평점 업데이트

**4. 검증 및 디버깅 (20분)**
- SHOW TABLES, DESCRIBE
- JOIN으로 데이터 확인
- 트리거 동작 테스트

### 자주 하는 질문

**Q1: 트리거와 애플리케이션 로직 중 어느 것을 사용해야 하나요?**
> A: 간단한 자동화(재고 감소, 금액 계산)는 트리거가 편리하지만, 복잡한 비즈니스 로직은 애플리케이션에서 처리하는 것이 디버깅과 유지보수에 유리합니다.

**Q2: SHA2로 비밀번호를 저장하는 것이 안전한가요?**
> A: 실습용으로는 괜찮지만, 실무에서는 bcrypt, Argon2 같은 전문 해시 함수를 사용하세요. 또한 Salt를 추가해야 합니다.

**Q3: ON DELETE CASCADE를 모든 외래 키에 사용해도 되나요?**
> A: 아니요. 회원 삭제 시 주문까지 삭제되면 안 되므로, 중요한 데이터는 RESTRICT를 사용하세요.

**Q4: 트리거에서 SIGNAL은 언제 사용하나요?**
> A: 비즈니스 규칙 위반(재고 부족, 중복 주문 등) 시 에러를 발생시켜 트랜잭션을 롤백할 때 사용합니다.

### 실습 중 흔한 실수

**1. 외래 키 순서 오류**
```sql
-- 잘못된 순서
INSERT INTO Orders ...;  -- ❌ Addresses가 없음
INSERT INTO Addresses ...;

-- 올바른 순서
INSERT INTO Addresses ...;
INSERT INTO Orders ...;  -- ✅
```

**2. CHECK 제약조건 무시**
```sql
-- MySQL 8.0.16 이전 버전은 CHECK를 무시
-- 버전 확인
SELECT VERSION();
```

**3. 트리거 재귀 호출**
```sql
-- 잘못된 트리거
CREATE TRIGGER bad_trigger
AFTER UPDATE ON Products
FOR EACH ROW
BEGIN
    UPDATE Products SET stock = stock - 1;  -- ❌ 무한 루프!
END;
```

---

## 요약

### DDL 핵심

**테이블 생성 순서:**
1. Users, Categories (독립)
2. Addresses, Products (1단계 FK)
3. Carts, Orders (2단계 FK)
4. Order_Items, Payments, Reviews (3단계 FK)

**제약조건:**
- PRIMARY KEY: AUTO_INCREMENT
- FOREIGN KEY: ON DELETE CASCADE/RESTRICT
- CHECK: 데이터 검증
- UNIQUE: 중복 방지
- DEFAULT: 기본값 설정

**데이터 삽입:**
- 외래 키 순서 준수
- 비밀번호 해시 (SHA2)
- LAST_INSERT_ID() 활용

**트리거:**
- 재고 자동 감소
- 주문 금액 자동 계산
- 평균 평점 업데이트

### 다음 단계
다음 시간에는 **애플리케이션과 DB 연동 (7.4)**을 진행합니다.

---

**테이블 생성 완료!** 이제 Java 또는 Node.js로 연동해봅시다.
