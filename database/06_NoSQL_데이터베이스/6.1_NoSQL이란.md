# 6.1. NoSQL이란? SQL과의 차이점

## 학습 목표
- NoSQL의 개념과 등장 배경을 이해한다
- SQL과 NoSQL의 차이점을 학습한다
- NoSQL의 종류와 특징을 파악한다
- 각각의 장단점과 사용 사례를 이해한다

---

## 1. NoSQL이란?

**NoSQL (Not Only SQL)**은 전통적인 관계형 데이터베이스(RDBMS)가 아닌 **다양한 형태의 데이터베이스**를 총칭하는 용어입니다.

```
NoSQL = "SQL만이 아니다" (Not Only SQL)
- SQL을 사용하지 않는다는 의미가 아님
- 관계형 모델이 아닌 다른 방식으로 데이터를 저장
```

### 1.1. NoSQL의 등장 배경

**2000년대 후반, 웹 서비스의 폭발적 성장:**

```
문제점:
- 데이터 폭증 (빅데이터)
- 읽기/쓰기 요청 폭증 (초당 수백만 건)
- 다양한 형태의 데이터 (JSON, 이미지, 로그 등)
- 수평 확장의 어려움

기존 RDBMS의 한계:
- 스키마가 고정되어 유연성 부족
- 수평 확장(Scale-out)이 어려움
- JOIN 연산으로 인한 성능 저하
- 트랜잭션 오버헤드

→ NoSQL의 등장!
```

**대표적인 사례:**
- Google: Bigtable (2006)
- Amazon: Dynamo (2007)
- Facebook: Cassandra (2008)
- MongoDB (2009)

---

## 2. SQL vs NoSQL 비교

### 2.1. 데이터 모델

**SQL (관계형):**
```sql
-- 엄격한 스키마: 테이블, 행, 열
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100),
    age INT
);

INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', 25);
```

**NoSQL (문서형 - MongoDB 예시):**
```javascript
// 유연한 스키마: JSON 형태
db.users.insertOne({
    _id: 1,
    name: "Alice",
    email: "alice@example.com",
    age: 25,
    hobbies: ["reading", "coding"],  // 배열 가능
    address: {                       // 중첩 객체 가능
        city: "Seoul",
        country: "Korea"
    }
})
```

### 2.2. 스키마

| SQL | NoSQL |
|-----|-------|
| **고정된 스키마** | **유연한 스키마 (Schema-less)** |
| 미리 정의 필요 | 동적으로 추가 가능 |
| 모든 행이 같은 구조 | 각 문서가 다른 구조 가능 |
| 스키마 변경이 어려움 | 쉽게 필드 추가/삭제 |

```javascript
// NoSQL: 같은 컬렉션에 다른 구조 허용
db.users.insertOne({ name: "Bob", age: 30 })
db.users.insertOne({ name: "Charlie", email: "charlie@example.com", city: "Busan" })
// 각 문서가 다른 필드를 가져도 OK!
```

### 2.3. 확장성

**SQL: 수직 확장 (Scale-up)**
```
┌─────────────┐
│   단일 서버  │
│  CPU ↑      │  → 더 강력한 서버로 업그레이드
│  Memory ↑   │
│  Disk ↑     │
└─────────────┘

장점: 구조 단순
단점: 비용 급증, 한계 존재
```

**NoSQL: 수평 확장 (Scale-out)**
```
┌────┐  ┌────┐  ┌────┐  ┌────┐
│서버1│  │서버2│  │서버3│  │서버4│  → 서버 추가로 확장
└────┘  └────┘  └────┘  └────┘

장점: 비용 효율적, 무한 확장 가능
단점: 구조 복잡, 일관성 관리 어려움
```

### 2.4. 트랜잭션

**SQL:**
```sql
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;  -- ACID 보장
```

**NoSQL (전통적으로):**
```javascript
// 단일 문서만 원자성 보장
db.accounts.updateOne(
    { _id: 1 },
    { $inc: { balance: -100 } }
)  // 이것만 원자적

// 여러 문서 간 트랜잭션은 제한적
// (MongoDB 4.0+에서는 지원)
```

### 2.5. JOIN vs Embed/Reference

**SQL: JOIN으로 데이터 결합**
```sql
-- 사용자와 주문을 JOIN
SELECT u.name, o.order_id, o.total
FROM users u
JOIN orders o ON u.id = o.user_id;
```

**NoSQL: 임베드(내장) 또는 참조**
```javascript
// 방법 1: 임베드 (Embed)
{
    _id: 1,
    name: "Alice",
    orders: [                    // 주문을 내장
        { order_id: 101, total: 50000 },
        { order_id: 102, total: 30000 }
    ]
}

// 방법 2: 참조 (Reference)
// users 컬렉션
{ _id: 1, name: "Alice" }

// orders 컬렉션
{ order_id: 101, user_id: 1, total: 50000 }
{ order_id: 102, user_id: 1, total: 30000 }
```

---

## 3. NoSQL의 종류

### 3.1. 문서형 (Document Store)

**대표: MongoDB, CouchDB**

```javascript
// JSON/BSON 형태로 데이터 저장
{
    "_id": ObjectId("..."),
    "name": "Alice",
    "age": 25,
    "hobbies": ["reading", "coding"],
    "address": {
        "city": "Seoul",
        "zipcode": "12345"
    }
}
```

**특징:**
- JSON과 유사한 구조
- 유연한 스키마
- 복잡한 쿼리 지원

**사용 사례:**
- 콘텐츠 관리 시스템 (CMS)
- 사용자 프로필
- 카탈로그

### 3.2. 키-값 저장소 (Key-Value Store)

**대표: Redis, Amazon DynamoDB**

```
key: "user:1"    →    value: "{ name: 'Alice', age: 25 }"
key: "session:abc" →  value: "{ user_id: 1, expires: ... }"
```

**특징:**
- 가장 단순한 구조
- 매우 빠른 성능
- 제한적인 쿼리 (키로만 조회)

**사용 사례:**
- 캐싱
- 세션 관리
- 장바구니

### 3.3. 컬럼 패밀리 (Column-Family Store)

**대표: Apache Cassandra, HBase**

```
Row Key: "user:1"
  Column Family: profile
    name: "Alice"
    email: "alice@example.com"
  Column Family: stats
    login_count: 100
    last_login: "2025-01-15"
```

**특징:**
- 열 단위 저장
- 대량 쓰기에 최적화
- 높은 확장성

**사용 사례:**
- 시계열 데이터
- 로그 분석
- IoT 데이터

### 3.4. 그래프 (Graph Database)

**대표: Neo4j, Amazon Neptune**

```
(Alice)-[:FOLLOWS]->(Bob)
(Bob)-[:FOLLOWS]->(Charlie)
(Alice)-[:LIKES]->(Post1)
```

**특징:**
- 노드와 관계로 데이터 표현
- 복잡한 관계 쿼리에 최적화
- SNS, 추천 시스템에 적합

**사용 사례:**
- 소셜 네트워크
- 추천 엔진
- 네트워크 분석

---

## 4. SQL vs NoSQL 상세 비교

| 비교 항목 | SQL (RDBMS) | NoSQL |
|----------|-------------|-------|
| **데이터 모델** | 테이블 (행, 열) | 문서, 키-값, 컬럼, 그래프 |
| **스키마** | 고정 (Strict Schema) | 유연 (Schema-less) |
| **확장성** | 수직 확장 (Scale-up) | 수평 확장 (Scale-out) |
| **트랜잭션** | ACID 완벽 지원 | BASE (최종 일관성) |
| **JOIN** | 강력한 JOIN 지원 | 제한적 또는 없음 |
| **쿼리** | SQL (표준화됨) | DB마다 다름 |
| **성능** | 복잡한 쿼리에 강함 | 단순 읽기/쓰기에 빠름 |
| **일관성** | 강한 일관성 | 최종 일관성 (Eventual Consistency) |
| **사용 사례** | 금융, ERP, 복잡한 비즈니스 로직 | 소셜 미디어, 실시간 분석, IoT |

---

## 5. ACID vs BASE

### 5.1. ACID (SQL)

**SQL 데이터베이스의 트랜잭션 모델**

- **A**tomicity: 원자성 (All or Nothing)
- **C**onsistency: 일관성
- **I**solation: 격리성
- **D**urability: 지속성

```sql
-- 모든 작업이 성공하거나 모두 실패
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;  -- 둘 다 성공하거나 둘 다 실패
```

### 5.2. BASE (NoSQL)

**NoSQL 데이터베이스의 일관성 모델**

- **B**asically Available: 기본적으로 가용성 보장
- **S**oft state: 유연한 상태
- **E**ventually consistent: **최종 일관성**

```javascript
// MongoDB 예시
db.users.updateOne({ _id: 1 }, { $set: { status: "active" } })

// 즉시 모든 서버에 반영되지 않을 수 있음
// 하지만 결국(Eventually)에는 모든 서버가 같은 상태가 됨
```

**최종 일관성 (Eventual Consistency) 예시:**
```
시간 →

서버 1: [데이터 변경] → 즉시 반영
서버 2: [이전 데이터] → 약간 후 반영
서버 3: [이전 데이터] → 약간 후 반영

(몇 초~몇 분 후)

서버 1: [새 데이터]
서버 2: [새 데이터]  ← 결국 모두 동일
서버 3: [새 데이터]
```

---

## 6. NoSQL의 장단점

### 6.1. 장점

**1. 유연한 스키마**
```javascript
// 필드를 자유롭게 추가
db.users.insertOne({ name: "Alice", age: 25 })
db.users.insertOne({ name: "Bob", city: "Seoul", hobbies: ["gaming"] })
// 스키마 변경 없이 가능!
```

**2. 수평 확장 용이**
- 서버를 추가하여 성능 향상
- 비용 효율적

**3. 빠른 읽기/쓰기**
- JOIN 없이 한 번에 데이터 조회
- 단순한 구조로 빠른 성능

**4. 대용량 데이터 처리**
- 빅데이터, 로그, IoT 데이터 처리에 적합

### 6.2. 단점

**1. 복잡한 쿼리 제한**
```sql
-- SQL: 강력한 JOIN과 집계
SELECT u.name, COUNT(o.id), SUM(o.total)
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.name;

-- NoSQL: 이런 쿼리가 어렵거나 불가능
```

**2. 트랜잭션 제한**
- 여러 문서/테이블 간 ACID 트랜잭션 어려움
- 데이터 일관성 보장이 약함

**3. 표준화 부족**
- DB마다 쿼리 언어가 다름
- 이식성 낮음

**4. 데이터 중복**
- JOIN 대신 데이터 중복 저장
- 업데이트 시 여러 곳 수정 필요

---

## 7. 언제 SQL을 사용하고 언제 NoSQL을 사용할까?

### 7.1. SQL 사용 권장

✅ **다음과 같은 경우 SQL 선택:**

- 복잡한 관계가 많은 데이터
- 강력한 트랜잭션 필요 (금융, 결제)
- 복잡한 쿼리와 집계 필요
- 데이터 일관성이 중요
- 스키마가 안정적이고 잘 정의됨

**예시:**
- 은행 시스템
- ERP, CRM
- 전자상거래 주문 시스템
- 회계 시스템

### 7.2. NoSQL 사용 권장

✅ **다음과 같은 경우 NoSQL 선택:**

- 대용량 데이터 (빅데이터)
- 빠른 읽기/쓰기 필요
- 스키마가 자주 변경됨
- 수평 확장이 필요
- 최종 일관성으로 충분

**예시:**
- 소셜 미디어 (Facebook, Twitter)
- 실시간 분석 (로그, 클릭스트림)
- IoT 센서 데이터
- 콘텐츠 관리 시스템
- 캐싱, 세션 저장

### 7.3. 혼합 사용 (Polyglot Persistence)

실무에서는 **SQL과 NoSQL을 함께 사용**하는 경우가 많습니다.

```
애플리케이션
    │
    ├── MySQL (주문, 결제) ← 트랜잭션 필요
    ├── MongoDB (상품 카탈로그) ← 유연한 스키마
    ├── Redis (캐시, 세션) ← 빠른 성능
    └── Elasticsearch (검색) ← 전문 검색
```

---

## 8. 실습 준비

다음 시간부터 **MongoDB**를 사용하여 NoSQL을 학습합니다.

### 왜 MongoDB인가?

- 가장 인기 있는 NoSQL DB
- 문서형(Document Store)으로 이해하기 쉬움
- 강력한 쿼리 기능
- 풍부한 생태계와 자료

---

## 강사 가이드

### 수업 진행 팁

1. **SQL과 대비하며 설명** (20분)
   - 학생들이 SQL을 이미 학습했으므로 대조하며 설명
   - "SQL에서는 이렇게 했지만, NoSQL에서는..."
   - 같은 데이터를 SQL과 NoSQL로 표현해보기

2. **등장 배경 강조** (10분)
   - 2000년대 후반 웹 서비스의 급성장
   - Facebook, Google의 데이터 규모 설명
   - "RDBMS로는 감당 못 함" 강조

3. **NoSQL의 종류 소개** (15분)
   - 문서형, 키-값, 컬럼 패밀리, 그래프
   - 각각의 대표 DB와 사용 사례
   - "상황에 맞는 도구 선택"

4. **ACID vs BASE** (15분)
   - 최종 일관성(Eventual Consistency) 개념 중요
   - 실생활 비유: SNS 좋아요 수가 조금 늦게 업데이트되는 것
   - "트레이드오프" 강조

5. **사용 사례 토론** (10분)
   - 학생들에게 질문: "이런 경우 SQL? NoSQL?"
   - 실제 서비스 사례 분석

### 자주 하는 질문

**Q1: NoSQL이 SQL을 대체하나요?**
> A: 아니요. NoSQL은 SQL을 대체하는 것이 아니라 **보완**하는 것입니다. 각각의 장단점이 있고, 상황에 맞게 선택하거나 함께 사용합니다.

**Q2: NoSQL은 트랜잭션을 전혀 지원하지 않나요?**
> A: 아니요. MongoDB 4.0+, Cassandra 등은 제한적이지만 트랜잭션을 지원합니다. 다만 RDBMS만큼 강력하지는 않습니다.

**Q3: NoSQL은 스키마가 없나요?**
> A: "Schema-less"는 **엄격한 스키마가 없다**는 의미입니다. 실무에서는 애플리케이션 레벨에서 스키마를 정의하고 검증합니다.

**Q4: 기존 SQL 지식이 NoSQL에서 쓸모없나요?**
> A: 전혀 아닙니다! 데이터 모델링, 인덱싱, 쿼리 최적화 등 많은 개념이 공통적으로 적용됩니다.

**Q5: 어느 것이 더 빠른가요?**
> A: 상황에 따라 다릅니다. 단순 읽기/쓰기는 NoSQL이 빠르지만, 복잡한 집계는 SQL이 더 효율적일 수 있습니다.

---

## 요약

### 핵심 개념

**NoSQL = Not Only SQL**
- 관계형이 아닌 다양한 형태의 데이터베이스

**SQL vs NoSQL 핵심 차이**

| | SQL | NoSQL |
|-|-----|-------|
| **스키마** | 고정 | 유연 |
| **확장** | 수직 | 수평 |
| **트랜잭션** | ACID | BASE |
| **관계** | JOIN | Embed/Reference |

**NoSQL의 종류**
1. 문서형 (MongoDB)
2. 키-값 (Redis)
3. 컬럼 패밀리 (Cassandra)
4. 그래프 (Neo4j)

**선택 기준**
- 복잡한 관계, 트랜잭션 → SQL
- 대용량, 유연성, 수평 확장 → NoSQL
- 실무에서는 혼합 사용

### 다음 단계

다음 시간에는 **MongoDB 설치 및 기본 명령어**를 학습합니다:
- MongoDB 설치 및 설정
- mongo shell 사용법
- 데이터베이스와 컬렉션 생성
- 기본 CRUD 명령어 소개

---

**연습 권장사항:**
- 주변 웹 서비스들이 어떤 DB를 사용하는지 조사
- SQL로 설계했던 데이터를 NoSQL로 어떻게 표현할지 고민
- MongoDB 공식 문서 읽어보기
- NoSQL 사용 사례 찾아보기
