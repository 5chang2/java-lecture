# 5.6. 데드락(Deadlock) 핵심 요약

### 1. 데드락(Deadlock) 기본 개념

- **데드락 (Deadlock, 교착 상태)**
  - 두 개 이상의 트랜잭션이 서로가 보유한 락(Lock)이 해제되기를 기다리면서, 아무것도 처리하지 못하고 무한히 대기하는 상태.

- **데드락 발생 예시**
  - **트랜잭션 1**: 데이터 A에 락을 걸고, 데이터 B의 락을 기다림.
  - **트랜잭션 2**: 데이터 B에 락을 걸고, 데이터 A의 락을 기다림.
  - → 두 트랜잭션은 서로를 영원히 기다리게 됨.

---

### 2. 데드락 발생의 4가지 조건

- 아래 4가지 조건이 **모두 충족**되어야 데드락이 발생함.

1.  **상호 배제 (Mutual Exclusion)**: 한 번에 하나의 트랜잭션만 자원(락)을 사용할 수 있음.
2.  **점유와 대기 (Hold and Wait)**: 하나의 자원을 보유한 상태에서 다른 자원을 추가로 요청하며 대기함.
3.  **비선점 (No Preemption)**: 다른 트랜잭션이 보유한 자원을 강제로 빼앗을 수 없음.
4.  **순환 대기 (Circular Wait)**: 자원을 기다리는 관계가 원형(사이클)을 이룸. (A→B→A)

---

### 3. 데드락 해결 및 예방

- **MySQL의 자동 처리**
  - InnoDB 엔진은 데드락을 자동으로 감지하고, 두 트랜잭션 중 하나를 "희생자"로 선택하여 강제로 롤백(ROLLBACK)시킴.
  - 롤백된 트랜잭션은 `ERROR 1213: Deadlock found ...` 오류를 받게 됨.

- **가장 중요한 예방 전략**
  - **락 획득 순서 일관성 유지**: 여러 데이터를 수정할 때, 관련된 모든 트랜잭션이 항상 일정한 순서(예: ID 오름차순)로 데이터에 접근하여 락을 획득하도록 규칙을 정함. 이것만으로 대부분의 데드락을 예방할 수 있음.

- **기타 예방 전략**
  - **트랜잭션을 짧게 유지**: 락을 보유하는 시간을 최소화하여 다른 트랜잭션과의 충돌 가능성을 줄임.
  - **인덱스 활용**: `WHERE` 절에 인덱스를 적절히 사용하여 불필요한 범위의 락이 걸리지 않도록 쿼리를 최적화.
  - **애플리케이션 재시도 로직**: 데드락 발생 시(오류 코드 1213), 잠시 후 트랜잭션을 다시 시도하는 로직을 애플리케이션 코드에 구현.

---

### 4. 데드락 정보 확인

- **가장 최근 데드락 정보 확인**
  ```sql
  SHOW ENGINE INNODB STATUS;
  ```
  - 위 쿼리 결과의 `LATEST DETECTED DEADLOCK` 섹션에서 데드락의 원인이 된 쿼리와 트랜잭션 정보를 확인할 수 있음.
