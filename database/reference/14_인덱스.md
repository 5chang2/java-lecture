### 🚀 Index: 데이터베이스의 검색 속도를 높이는 비밀 무기

**인덱스(Index)**는 데이터베이스 테이블의 **검색(SELECT) 성능**을 향상시키기 위해 사용하는, 원본 데이터와는 별도로 관리되는 **특수한 자료 구조**입니다. 🕵️‍♂️

가장 흔한 비유는 바로 **책의 '색인(찾아보기)'**입니다. 500페이지짜리 두꺼운 책에서 'SQL'이라는 단어를 찾으려면, 색인이 없다면 1페이지부터 500페이지까지 모든 페이지를 한 장씩 넘겨봐야 합니다. 하지만 책 맨 뒤의 색인을 이용하면 'SQL'이 몇 페이지에 있는지 바로 찾아서 해당 페이지로 한 번에 점프할 수 있죠.

데이터베이스에서도 마찬가지입니다. 인덱스가 없으면 특정 데이터를 찾기 위해 테이블의 모든 행을 처음부터 끝까지 훑어야 하는데, 이를 **전체 테이블 스캔(Full Table Scan)**이라고 부릅니다. 데이터가 수백만, 수천만 건이 되면 이 방식은 매우 비효율적입니다. 인덱스는 바로 이 전체 테이블 스캔을 방지하여 검색 속도를 극적으로 높여주는 역할을 합니다.



---

### **어떻게 동작하나요?**

인덱스는 특정 컬럼(또는 여러 컬럼)의 값과, 그 값이 저장된 행의 물리적 주소(위치)를 **미리 정렬된 상태**로 저장해 둡니다.

* **인덱스가 없을 때**: `WHERE user_nickname = '개발자김'` 이라는 조건으로 검색하면, `users` 테이블의 1번 행부터 마지막 행까지 `user_nickname`을 하나씩 다 비교해 봅니다.
* **인덱스가 있을 때**: `user_nickname`으로 만들어진 인덱스(가나다순으로 정렬된)에서 '개발자김'의 위치를 빠르게 찾고, 그곳에 기록된 주소를 통해 원본 테이블의 데이터로 한 번에 점프합니다.

---

### **언제 인덱스를 사용해야 할까요?**

인덱스는 모든 컬럼에 무분별하게 생성하는 것이 아니라, 전략적으로 필요한 곳에만 만들어야 합니다.

* **`WHERE` 절에서 자주 사용되는 컬럼**: 가장 일반적이고 중요한 경우입니다. 특정 조건으로 데이터를 필터링하는 일이 잦은 컬럼에는 인덱스가 필수적입니다.
* **`JOIN`의 `ON` 절에서 사용되는 컬럼**: `JOIN`은 두 테이블의 연결고리가 되는 컬럼을 기준으로 일치하는 데이터를 찾습니다. 이 연결고리 컬럼들(`FOREIGN KEY` 등)에 인덱스가 있으면 조인 성능이 크게 향상됩니다.
* **`ORDER BY` 절에서 자주 사용되는 컬럼**: 데이터를 특정 순서로 정렬하는 작업이 많을 경우, 해당 컬럼에 인덱스가 있으면 이미 정렬된 데이터를 활용하므로 정렬 속도가 빨라집니다.
* **데이터의 고유성(Cardinality)이 높은 컬럼**: `주민등록번호`, `이메일`처럼 중복되는 값이 거의 없는 컬럼은 인덱스 효율이 좋습니다. 반면, '성별'처럼 '남'/'여' 두 가지 값만 있는 컬럼은 인덱스 효율이 떨어집니다.
	* 1에 가까울수록 고유한 값이 많음 (높은 카디널리티)
	- 0에 가까울수록 중복된 값이 많음 (낮은 카디널리티)
	- ```sql
	  SELECT COUNT(DISTINCT column_name) / COUNT(*) as cardinality_ratio FROM table_name;
	  ```

---

### **⚖️ 인덱스의 장단점 (The Trade-off)**

인덱스는 만능이 아니며, 명확한 장점과 단점을 가집니다.

#### **✅ 장점 (Pros)**

* `SELECT` 쿼리의 성능을 비약적으로 향상시켜 데이터 조회 시간을 단축시킵니다.
* 시스템 전반의 부하를 줄여줍니다.

#### **⚠️ 단점 (Cons)**

* **저장 공간 차지**: 인덱스는 원본 테이블과는 별도의 저장 공간을 차지합니다. 테이블 크기의 약 10% 정도의 추가 공간이 필요할 수 있습니다.
* **쓰기 성능 저하**: `INSERT`, `UPDATE`, `DELETE` 작업이 발생할 때마다 테이블의 데이터뿐만 아니라 **인덱스도 함께 수정**되어야 합니다. 이 과정에서 부하가 발생하여 쓰기 성능이 저하됩니다.

> **💡 결론**: 데이터 조회(`SELECT`)는 거의 없고 데이터 입력/수정/삭제(`INSERT`, `UPDATE`, `DELETE`)가 매우 빈번한 테이블이라면 인덱스를 생성하지 않는 것이 더 나을 수도 있습니다. **읽기와 쓰기의 비율을 고려**하여 균형을 맞추는 것이 중요합니다.

---

### **기본적인 인덱스 명령어 (MySQL 기준)**

* **인덱스 생성 (`CREATE INDEX`)**
  ```sql
  -- users 테이블의 user_nickname 컬럼에 idx_nickname 이라는 이름의 인덱스를 생성합니다.
  CREATE INDEX idx_nickname ON users (nickname);
  ```

* **인덱스 조회 (`SHOW INDEX`)**
  ```sql
  -- users 테이블에 생성된 인덱스 목록을 확인합니다.
  SHOW INDEX FROM users;
  ```

* **인덱스 삭제 (`DROP INDEX`)**
  ```sql
  -- users 테이블에서 idx_nickname 인덱스를 삭제합니다.
  DROP INDEX idx_nickname ON users;
  ```