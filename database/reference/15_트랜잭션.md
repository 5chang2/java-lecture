### ⛓️ Transaction: 데이터를 지키는 논리적인 작업 단위

**트랜잭션(Transaction)**은 데이터베이스의 상태를 변화시키는, 더 이상 쪼갤 수 없는 **하나의 논리적인 작업 단위**입니다. 📦 여러 개의 SQL 명령문들을 하나의 작업으로 묶어서 처리하며, 관련된 모든 작업들이 반드시 **'전부 성공'**하거나 하나라도 실패하면 **'전부 실패'**하는 **"All or Nothing"** 원칙을 따릅니다.

---

#### ### **트랜잭션이 필요한 이유**

데이터의 일관성과 무결성을 지키기 위해 트랜잭션은 필수적입니다. 가장 대표적인 예는 **은행의 계좌 이체**입니다.

* **계좌 이체 예시**: A계좌에서 1만원을 출금하여 B계좌로 1만원을 입금하는 상황

```sql
-- 1. A계좌에서 1만원 출금
UPDATE accounts SET balance = balance - 10000 WHERE account_id = 'A';

-- ‼️ 만약 이 시점에서 시스템에 장애가 발생한다면?
-- A계좌에서만 돈이 빠져나가고 B계좌에는 입금되지 않아 1만원이 사라지는 심각한 문제가 발생합니다.

-- 2. B계좌로 1만원 입금
UPDATE accounts SET balance = balance + 10000 WHERE account_id = 'B';
```
    트랜잭션은 위 두 `UPDATE` 문을 하나의 작업 단위로 묶어, 두 작업이 모두 성공해야만 최종 저장하고, 하나라도 실패하면 모든 것을 원래대로 되돌려 데이터의 정합성을 보장합니다.

---

#### ### **트랜잭션 제어 명령어 (TCL)**

* `START TRANSACTION` 또는 `BEGIN`: 트랜잭션의 시작을 알립니다.
* `COMMIT`: 트랜잭션 내의 모든 작업을 **최종적으로 데이터베이스에 저장**하고 트랜잭션을 성공적으로 종료합니다.
* `ROLLBACK`: 트랜잭션 내에서 발생한 모든 변경 사항을 **취소**하고, 트랜잭션이 시작되기 이전 상태로 되돌립니다.

---

### **ACID: 트랜잭션의 4가지 핵심 속성**

안전한 트랜잭션을 보장하기 위해 데이터베이스는 **ACID**라고 불리는 네 가지 특성을 반드시 만족해야 합니다.

* **원자성 (Atomicity)**
    트랜잭션에 포함된 모든 연산은 **모두 성공**하거나 **모두 실패**해야 합니다. 하나라도 오류가 발생하면 전체가 롤백(Rollback)되어 이전 상태로 돌아갑니다.

* **일관성 (Consistency)**
    트랜잭션이 성공적으로 완료된 후에도 데이터베이스는 항상 **일관된 상태**를 유지해야 합니다. (예: 계좌 이체 전후의 총 잔액은 동일해야 함)

* **격리성 (Isolation / 고립성)**
    하나의 트랜잭션이 실행되는 동안에는 다른 트랜잭션이 그 중간 결과에 영향을 줄 수 없습니다. 각 트랜잭션은 마치 **혼자서 실행되는 것처럼** 보여야 합니다.

* **지속성 (Durability)**
    성공적으로 완료(`COMMIT`)된 트랜잭션의 결과는 시스템에 장애가 발생하더라도 **영구적으로 저장**되어야 합니다. (예: Write-Ahead Logging 기법 활용)

---

### **동시성 문제 (Concurrency Issues)**

여러 트랜잭션이 동시에 같은 데이터에 접근할 때 발생할 수 있는 데이터 불일치 문제입니다.

#### ### **1. 데이터 읽기 관련 문제**

* **Dirty Read**
    한 트랜잭션이 아직 **커밋(COMMIT)하지 않은** 데이터를 다른 트랜잭션이 읽는 현상입니다.
    ```sql
    -- 트랜잭션 1
    START TRANSACTION;
    UPDATE accounts SET balance = balance - 10000 WHERE id = 'A';
    -- 아직 커밋되지 않음

    -- 트랜잭션 2
    START TRANSACTION;
    SELECT balance FROM accounts WHERE id = 'A';
    -- 아직 확정되지 않은 A의 잔액(감소된 값)을 읽어버림 (Dirty Read 발생)
    ```
    > **해결 방안**: `READ COMMITTED` 이상의 격리 수준을 사용합니다.

* **Non-repeatable Read (반복 불가능 읽기)**
    한 트랜잭션 내에서 **같은 데이터를 두 번 읽었을 때, 그 결과가 다르게** 나타나는 현상입니다. (다른 트랜잭션이 중간에 데이터를 수정하고 커밋했기 때문)
    ```sql
    -- 트랜잭션 1
    START TRANSACTION;
    SELECT balance FROM accounts WHERE id = 'A';  -- 최초 읽기: 10000원

    -- 트랜잭션 2
    START TRANSACTION;
    UPDATE accounts SET balance = 20000 WHERE id = 'A';
    COMMIT; -- 트랜잭션 2가 수정하고 커밋

    -- 트랜잭션 1
    SELECT balance FROM accounts WHERE id = 'A';  -- 두 번째 읽기: 20000원 (결과가 다름!)
    ```
    > **해결 방안**: `REPEATABLE READ` 이상의 격리 수준을 사용합니다.

* **Phantom Read (유령 읽기)**
    한 트랜잭션 내에서 **같은 조건으로 두 번 조회했을 때, 결과 집합(행의 개수)이 다르게** 나타나는 현상입니다. (다른 트랜잭션이 중간에 데이터를 추가/삭제하고 커밋했기 때문)
    ```sql
    -- 트랜잭션 1
    START TRANSACTION;
    SELECT * FROM accounts WHERE balance > 10000;  -- 2개 행 조회

    -- 트랜잭션 2
    START TRANSACTION;
    INSERT INTO accounts VALUES ('C', 15000);
    COMMIT; -- 트랜잭션 2가 데이터를 추가하고 커밋

    -- 트랜잭션 1
    SELECT * FROM accounts WHERE balance > 10000;  -- 3개 행 조회 (결과 집합이 다름!)
    ```
    > **해결 방안**: `SERIALIZABLE` 격리 수준을 사용합니다.

> **💡 Non-repeatable Read vs Phantom Read**
>
> * **Non-repeatable Read**: **기존에 있던 데이터의 내용**이 바뀌는 문제 (UPDATE)
> * **Phantom Read**: 조회 조건에 해당하는 **데이터의 개수**가 바뀌는 문제 (INSERT, DELETE)

#### ### **2. 데이터 수정 관련 문제**

* **Lost Update (갱신 손실)**
    여러 트랜잭션이 동시에 같은 데이터를 수정할 때, 먼저 실행된 수정 내용이 나중에 실행된 수정 내용에 의해 덮어씌워지는 문제입니다.
    ```sql
    -- 원래 조회수: 100
    -- 사용자 1과 2가 동시에 조회수를 1씩 증가시키는 상황

    -- 사용자 1
    UPDATE posts SET views = 100 + 1 WHERE id = 1; -- views를 101로 변경

    -- 사용자 2 (동시에)
    UPDATE posts SET views = 100 + 1 WHERE id = 1; -- views를 101로 변경
    -- 최종 결과: 101 (예상 결과는 102)
    ```
    > **해결 방안**: `SELECT FOR UPDATE` 같은 락(Lock)을 사용합니다.

* **Deadlock (교착 상태)**
    두 개 이상의 트랜잭션이 서로 상대방의 자원(Lock)이 해제되기를 기다리며 무한 대기하는 상태입니다.
    ```sql
    -- 트랜잭션 1
    UPDATE accounts SET balance = balance - 100 WHERE id = 'A'; -- A에 Lock 획득
    UPDATE accounts SET balance = balance + 100 WHERE id = 'B'; -- B의 Lock을 기다림

    -- 트랜잭션 2 (동시에)
    UPDATE accounts SET balance = balance - 100 WHERE id = 'B'; -- B에 Lock 획득
    UPDATE accounts SET balance = balance + 100 WHERE id = 'A'; -- A의 Lock을 기다림
    ```
    > **해결 방안**: 트랜잭션에서 테이블 접근 순서를 통일하거나, 트랜잭션을 가능한 짧게 유지합니다.

---

### **Lock과 트랜잭션 격리 수준**

#### ### **Lock (잠금)**

`Lock`은 여러 트랜잭션이 동시에 데이터를 조작할 때 일관성을 유지하기 위한 메커니즘입니다. 하나의 트랜잭션이 사용 중인 데이터를 다른 트랜잭션이 접근하지 못하도록 제한합니다.

* **공유 락 (Shared Lock, S Lock)**: 데이터를 **읽을 때** 사용합니다. 다른 트랜잭션의 읽기는 허용하지만, 쓰기(수정/삭제)는 막습니다.
    ```sql
    SELECT * FROM accounts WHERE id = 'A' LOCK IN SHARE MODE;
    ```
* **배타적 락 (Exclusive Lock, X Lock)**: 데이터를 **변경할 때** 사용합니다. 다른 트랜잭션의 읽기와 쓰기 모두를 막습니다.
    ```sql
    SELECT * FROM accounts WHERE id = 'A' FOR UPDATE;
    ```

#### ### **트랜잭션 격리 수준 (Transaction Isolation Levels)**

동시성 문제와 성능 사이의 균형을 맞추기 위해 4가지 격리 수준을 제공합니다.

| 격리 수준            | Dirty Read | Non-repeatable Read | Phantom Read | 설명                                                         |
| -------------------- | :--------: | :-----------------: | :----------: | ------------------------------------------------------------ |
| **READ UNCOMMITTED** |    발생    |         발생        |     발생     | 커밋되지 않은 데이터 읽기 허용. 정합성 문제가 많아 거의 사용 안 함. |
| **READ COMMITTED** |    방지    |         발생        |     발생     | 커밋된 데이터만 읽기 허용. Oracle 등 많은 DBMS의 기본 수준.    |
| **REPEATABLE READ** |    방지    |         방지        |     발생     | 한 트랜잭션 내에서 동일한 결과 보장. **MySQL의 기본 격리 수준.** |
| **SERIALIZABLE** |    방지    |         방지        |     방지     | 가장 높은 격리 수준. 완벽한 격리 보장. 동시성이 떨어져 성능 저하 가능. |