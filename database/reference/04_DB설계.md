
### ## 🚀 데이터베이스 설계 및 문서화 로드맵

데이터베이스 설계는 크게 **요구사항 분석 → 개념적 설계 → 논리적 설계 → 물리적 설계**의 4단계를 거칩니다. 각 단계마다 명확한 산출물(문서)을 만드는 것이 중요합니다.

#### **1단계: 요구사항 분석 및 정의**

가장 중요한 첫 단계입니다. 어떤 데이터를, 왜, 어떻게 사용할지를 명확히 정의해야 합니다.

- **🎯 목표**: 서비스나 프로그램에 필요한 모든 데이터를 파악하고, 데이터 간의 관계와 제약조건을 파악합니다.
    
- **📋 해야 할 일**:
    
    - **핵심 기능 정의**: 이 데이터베이스가 지원해야 할 주요 기능은 무엇인가? (예: 사용자 가입, 게시글 작성, 상품 주문)
        
    - **데이터 식별**: 각 기능에 어떤 데이터가 필요한가? (예: 사용자 이름, 이메일, 비밀번호, 게시글 제목, 내용)
        
    - **업무 규칙 정의**: 데이터에 적용될 규칙은 무엇인가? (예: 사용자는 여러 개의 게시글을 작성할 수 있다. 주문 없이는 배송이 불가하다.)
        
- **📄 산출물 (문서)**:
    
    - **요구사항 정의서**: 필요한 기능, 데이터 목록, 제약 조건 등을 자유로운 형식으로 상세히 기술한 문서입니다. 이것이 모든 설계의 기준점이 됩니다.
        

---

#### **2. 단계: 개념적 설계 (Conceptual Design)**

요구사항을 바탕으로 데이터의 구조와 관계를 추상적으로, 시각적으로 표현하는 단계입니다.

- **🎯 목표**: 데이터의 핵심 요소(개체)와 그들 간의 관계를 도식화하여 전체적인 데이터 구조를 한눈에 파악할 수 있도록 합니다.
    
- **📋 해야 할 일**:
    
    - **개체(Entity) 도출**: 데이터의 핵심 주체를 찾아냅니다. (예: `회원`, `게시글`, `상품`, `주문`)
        
    - **속성(Attribute) 정의**: 각 개체가 가지는 속성들을 정의합니다. (예: `회원`은 `아이디`, `이름`, `이메일`을 가짐)
        
    - **관계(Relationship) 설정**: 개체들 간의 관계(1:1, 1:N, M:N)를 정의합니다. (예: `회원`과 `게시글`은 1:N 관계)
        
- **📄 산출물 (문서)**:
    
    - **개체-관계 다이어그램 (ERD, Entity-Relationship Diagram)**: 개념적 설계의 핵심 결과물입니다.
        

> **💡 Tip**: `draw.io`, `Lucidchart`, `AQueryTool` 같은 ERD 전문 툴을 사용하면 편리하게 다이어그램을 그리고 관리할 수 있습니다.

---

#### **3. 단계: 논리적 설계 (Logical Design)**

개념적 설계를 실제 데이터베이스에 적용할 수 있도록 **테이블(Table) 형태**로 변환하는 과정입니다. 특정 DBMS에 종속되지 않은, 일반적인 데이터 모델을 만듭니다.

- **🎯 목표**: ERD를 기반으로 테이블 스키마를 설계하고, 데이터의 중복과 비일관성을 제거하기 위해 **정규화**를 수행합니다.
    
- **📋 해야 할 일**:
    
    - **ERD를 테이블로 변환**: 각 개체는 테이블로, 속성은 열(Column)로 변환합니다.
        
    - **데이터 타입 및 제약조건 정의**: 각 열에 맞는 데이터 타입(예: `VARCHAR`, `INT`, `DATETIME`)과 제약조건(예: `NOT NULL`)을 결정합니다.
        
    - **기본 키(PK) 및 외래 키(FK) 설정**: 테이블 간의 관계를 PK와 FK를 통해 명확히 정의합니다.
        
    - **정규화(Normalization)**: 데이터 중복을 최소화하기 위해 제1, 제2, 제3 정규형 등을 적용하여 테이블을 분리하거나 조정합니다.
        
- **📄 산출물 (문서)**:
    
    - **테이블 명세서**: 각 테이블의 구조를 상세히 기술한 문서입니다. 아래와 같은 항목이 포함됩니다.
        

|테이블명|컬럼명|데이터 타입|PK/FK|제약조건|설명|
|---|---|---|---|---|---|
|`Users`|`user_id`|`INT`|PK|`NOT NULL`|사용자 고유 ID|
||`email`|`VARCHAR(100)`||`NOT NULL`, `UNIQUE`|사용자 이메일|
|`Posts`|`post_id`|`INT`|PK|`NOT NULL`|게시글 고유 ID|
||`user_id`|`INT`|FK|`NOT NULL`|작성자 ID (Users 참조)|

---

#### **4. 단계: 물리적 설계 (Physical Design)**

논리적 설계를 특정 DBMS(예: MySQL, PostgreSQL)의 특성에 맞게 최적화하고 실제 데이터베이스 객체를 생성하는 마지막 단계입니다.

- **🎯 목표**: 성능, 보안, 저장 효율성을 고려하여 최종적인 데이터베이스 스키마를 완성합니다.
    
- **📋 해야 할 일**:
    
    - **DBMS 선정 및 특성 반영**: 사용할 DBMS에 맞춰 데이터 타입을 최종 확정하고, 해당 DBMS가 제공하는 기능을 활용합니다. (예: MySQL의 `AUTO_INCREMENT` 사용)
        
    - **인덱스(Index) 설계**: 데이터 조회 성능을 높이기 위해 어떤 열에 인덱스를 생성할지 결정합니다.
        
    - **파티셔닝, 클러스터링 등 고려**: 대용량 데이터를 효율적으로 관리하기 위한 고급 기법을 적용할지 검토합니다.
        
    - **반정규화(Denormalization) 검토**: 정규화로 인해 쿼리 성능이 저하되는 경우, 의도적으로 중복을 허용하여 성능을 최적화할지 결정합니다.
        
- **📄 산출물 (문서)**:
    
    - **데이터베이스 생성 스크립트 (DDL)**: `CREATE TABLE`, `CREATE INDEX` 등 테이블과 객체를 생성하는 SQL 쿼리문 자체를 문서로 관리합니다.
        
    - **최종 ERD 및 테이블 명세서**: 물리적 설계 내용이 반영된 최종 버전의 문서입니다.
        

이러한 단계를 거쳐 체계적으로 설계하고 각 단계의 산출물을 잘 정리해두면, 협업이 원활해지고 향후 시스템을 유지보수하기도 훨씬 수월해집니다.


---

### **문제 1: 📝 개인 블로그 시스템 (난이도: 하)**

개인 블로그 서비스를 위한 데이터베이스를 설계하려고 합니다. 사용자는 글을 작성하고, 각 글에는 여러 개의 태그를 붙일 수 있습니다.

#### **✅ 요구사항**

1. **사용자(User)**는 한 명이라고 가정합니다 (개인 블로그이므로).
    
2. **게시글(Post)**을 작성할 수 있어야 합니다.
    
    - 게시글은 **고유 ID**, **제목**, **내용**, **작성일**, **수정일**을 가집니다.
        
3. 하나의 게시글에는 여러 개의 **태그(Tag)**를 달 수 있습니다.
    
    - 하나의 태그는 여러 게시글에 사용될 수 있습니다 (M:N 관계).
        
    - 태그는 **고유 ID**와 **태그 이름**을 가집니다.
        

#### **🚀 도전 과제**

- 게시글과 태그의 **다대다(M:N) 관계**를 어떻게 해결할지 생각해보세요.
    
- ERD를 그리고, 3개의 테이블(`Posts`, `Tags`, `Post_Tags`)로 논리적 설계를 해보세요.
    

---

### **문제 2: 📚 도서관 관리 시스템 (난이도: 중)**

동네 작은 도서관의 도서 및 대출 관리를 위한 데이터베이스를 설계합니다. 회원은 책을 대출하고 반납할 수 있습니다.

#### **✅ 요구사항**

1. **회원(Member)**을 관리해야 합니다.
    
    - 회원은 **회원 ID**, **이름**, **연락처**, **가입일** 정보를 가집니다.
        
2. **도서(Book)** 정보를 관리해야 합니다.
    
    - 도서는 **도서 ID**, **제목**, **저자**, **출판사**, **ISBN** 정보를 가집니다.
    - 도서관은 **같은 책을 여러 권** 가지고 있을 수 있습니다.
        
3. 회원은 여러 권의 책을 **대출(Loan)**할 수 있습니다.
    
    - 대출 기록에는 어떤 **회원**이 어떤 **책**을 언제 **대출했는지**, **반납 예정일**은 언제인지 기록되어야 합니다.
    - **반납(Return)**이 이루어지면 **실제 반납일**이 기록되어야 합니다.
        

#### **🚀 도전 과제**

- '도서 정보'와 '실제 보유한 책 한 권 한 권'을 어떻게 구분해서 관리할지 생각해보세요. (힌트: `Books`와 `Book_Copies` 테이블)
    
- 회원과 도서의 관계를 나타내는 `Loans`(대출) 테이블을 상세하게 설계해보세요.
    
- ERD를 그리고, 필요한 테이블들의 명세서를 작성해보세요.
    

---

### **문제 3: 🛒 온라인 쇼핑몰 시스템 (난이도: 상)**

다양한 상품을 판매하는 온라인 쇼핑몰의 주문 관리 데이터베이스를 설계합니다.

#### **✅ 요구사항**

1. **고객(Customer)**은 회원가입을 통해 관리됩니다.
    
    - 고객은 **고객 ID**, **이름**, **이메일**, **비밀번호**, **주소**, **가입일** 정보를 가집니다.
        
2. **상품(Product)**을 등록하고 관리해야 합니다.
    
    - 상품은 **상품 ID**, **상품명**, **가격**, **재고 수량** 정보를 가집니다.
    - 상품은 여러 **카테고리(Category)**에 속할 수 있습니다. (예: '노트북' 상품은 '전자제품'과 '컴퓨터' 카테고리에 모두 속함)
        
3. 고객은 **주문(Order)**을 할 수 있습니다.
    
    - 하나의 주문에는 **여러 종류의 상품**이 포함될 수 있습니다.
    - 주문 정보에는 **주문 ID**, **주문한 고객**, **주문일**, **배송 주소**, **총 결제 금액**이 포함되어야 합니다.
    - **주문 상세(Order_Details)** 정보에는 어떤 주문에 어떤 상품이 몇 개 포함되었는지 기록되어야 합니다.
        
4. 결제가 완료되면 **결제(Payment)** 정보가 기록되어야 합니다.
    
    - 결제 정보에는 **결제 ID**, **해당 주문 ID**, **결제 수단**(카드, 현금 등), **결제 금액**, **결제 일시**가 포함됩니다.
        

#### **🚀 도전 과제**

- 상품과 카테고리의 **M:N 관계**를 어떻게 처리할지 설계해보세요.
- 주문과 상품의 관계를 나타낼 **중간 테이블(`Order_Details`)**을 어떻게 설계해야 할지 구상해보세요. 이 테이블에 가격 정보가 포함되어야 할까요? (힌트: 상품 가격은 변동될 수 있습니다.)
- 고객, 상품, 주문, 결제 등 여러 개의 개체가 복잡하게 얽힌 관계를 ERD로 명확하게 표현해보세요.

---

### **정답 1: 📝 개인 블로그 시스템 (난이도: 하)**

**1. ERD (개체-관계 다이어그램)**

- **Posts**와 **Tags**는 **다대다(M:N)** 관계를 가집니다.
    
- 이 관계를 해소하기 위해 중간에 **Post_Tags**라는 **연결 테이블(Junction Table)**을 둡니다.
    
- **Posts**와 **Post_Tags**는 일대다(1:N) 관계입니다.
    
- **Tags**와 **Post_Tags**는 일대다(1:N) 관계입니다.
    

---

**2. 테이블 명세서**

**1. Posts (게시글)**

|컬럼명|데이터 타입|PK/FK|제약조건|설명|
|---|---|---|---|---|
|`post_id`|`INT`|PK|`AUTO_INCREMENT`|게시글 고유 ID|
|`title`|`VARCHAR(255)`||`NOT NULL`|게시글 제목|
|`content`|`TEXT`||`NOT NULL`|게시글 내용|
|`created_at`|`DATETIME`||`DEFAULT NOW()`|작성일|
|`updated_at`|`DATETIME`|||수정일|

**2. Tags (태그)**

|컬럼명|데이터 타입|PK/FK|제약조건|설명|
|---|---|---|---|---|
|`tag_id`|`INT`|PK|`AUTO_INCREMENT`|태그 고유 ID|
|`tag_name`|`VARCHAR(50)`||`NOT NULL`, `UNIQUE`|태그 이름 (중복 방지)|

**3. Post_Tags (게시글-태그 연결)**

- **복합 기본 키**: (`post_id`, `tag_id`)
    

|컬럼명|데이터 타입|PK/FK|제약조건|설명|
|---|---|---|---|---|
|`post_id`|`INT`|PK, FK|`NOT NULL`|게시글 ID (Posts 참조)|
|`tag_id`|`INT`|PK, FK|`NOT NULL`|태그 ID (Tags 참조)|

---

---

### **정답 2: 📚 도서관 관리 시스템 (난이도: 중)**

**1. ERD (개체-관계 다이어그램)**

- **Books**는 도서의 원본 정보(제목, 저자 등)를 담습니다.
    
- **Book_Copies**는 도서관이 실제로 보유한 책 한 권 한 권을 의미하며, `Books`를 참조합니다. (한 `Book`은 여러 `Book_Copies`를 가질 수 있음)
    
- **Members**는 **Loans**와 일대다(1:N) 관계입니다.
    
- **Book_Copies**는 **Loans**와 일대다(1:N) 관계입니다.
    

---

**2. 테이블 명세서**

**1. Members (회원)**

|컬럼명|데이터 타입|PK/FK|제약조건|설명|
|---|---|---|---|---|
|`member_id`|`INT`|PK|`AUTO_INCREMENT`|회원 고유 ID|
|`name`|`VARCHAR(100)`||`NOT NULL`|회원 이름|
|`contact`|`VARCHAR(20)`||`NOT NULL`, `UNIQUE`|연락처|
|`join_date`|`DATE`||`NOT NULL`|가입일|

**2. Books (도서 정보)**

|컬럼명|데이터 타입|PK/FK|제약조건|설명|
|---|---|---|---|---|
|`book_id`|`INT`|PK|`AUTO_INCREMENT`|도서 정보 고유 ID|
|`title`|`VARCHAR(255)`||`NOT NULL`|도서 제목|
|`author`|`VARCHAR(100)`||`NOT NULL`|저자|
|`publisher`|`VARCHAR(100)`|||출판사|
|`isbn`|`VARCHAR(20)`||`UNIQUE`|국제표준도서번호|

**3. Book_Copies (보유 도서)**

|컬럼명|데이터 타입|PK/FK|제약조건|설명|
|---|---|---|---|---|
|`copy_id`|`INT`|PK|`AUTO_INCREMENT`|보유 도서 고유 ID|
|`book_id`|`INT`|FK|`NOT NULL`|도서 정보 ID (Books 참조)|
|`status`|`VARCHAR(20)`||`DEFAULT 'available'`|상태 (available, loaned)|

**4. Loans (대출 기록)**

|컬럼명|데이터 타입|PK/FK|제약조건|설명|
|---|---|---|---|---|
|`loan_id`|`INT`|PK|`AUTO_INCREMENT`|대출 기록 고유 ID|
|`member_id`|`INT`|FK|`NOT NULL`|회원 ID (Members 참조)|
|`copy_id`|`INT`|FK|`NOT NULL`|보유 도서 ID (Book_Copies 참조)|
|`loan_date`|`DATE`||`NOT NULL`|대출일|
|`due_date`|`DATE`||`NOT NULL`|반납 예정일|
|`return_date`|`DATE`|||실제 반납일 (반납 전엔 NULL)|

---

---

### **정답 3: 🛒 온라인 쇼핑몰 시스템 (난이도: 상)**

**1. ERD (개체-관계 다이어그램)**

- **Products**와 **Categories**는 M:N 관계이며, **Product_Categories**로 연결합니다.
    
- **Orders**와 **Products**는 M:N 관계이며, **Order_Details**로 연결합니다.
    
- **Customers**와 **Orders**는 1:N 관계입니다.
    
- **Orders**와 **Payments**는 1:1 관계입니다. (하나의 주문에 하나의 결제)
    

---

**2. 테이블 명세서**

1. Customers (고객)

| 컬럼명 | 데이터 타입 | PK/FK | 제약조건 | 설명  |
| :-- | :----- | :---: | :--- | :-- |
| customer_id | INT | PK | AUTO_INCREMENT | 고객 고유 ID |
| name | VARCHAR(100) | | NOT NULL | 고객 이름 |
| email | VARCHAR(100) | | NOT NULL, UNIQUE | 이메일 |
| password | VARCHAR(255) | | NOT NULL | 비밀번호 (해시 저장) |
| address | VARCHAR(255) | | NOT NULL | 주소 |
| created_at | DATETIME | | DEFAULT NOW() | 가입일 |

2. Categories (카테고리)

| 컬럼명 | 데이터 타입 | PK/FK | 제약조건 | 설명 |
|:---|:---|:---:|:---|:---|
| category_id | INT | PK | AUTO_INCREMENT | 카테고리 고유 ID |
| category_name | VARCHAR(100) | | NOT NULL, UNIQUE | 카테고리 이름 |

3. Products (상품)

| 컬럼명 | 데이터 타입 | PK/FK | 제약조건 | 설명 |
|:---|:---|:---:|:---|:---|
| product_id | INT | PK | AUTO_INCREMENT | 상품 고유 ID |
| product_name | VARCHAR(255) | | NOT NULL | 상품명 |
| price | DECIMAL(10, 2) | | NOT NULL | 현재 가격 |
| stock_quantity | INT | | NOT NULL | 재고 수량 |

**4. Product_Categories (상품-카테고리 연결)**

- 복합 기본 키: (product_id, category_id)

| 컬럼명 | 데이터 타입 | PK/FK | 제약조건 | 설명 |
|:---|:---|:---:|:---|:---|
| product_id | INT | PK, FK | NOT NULL | 상품 ID (Products 참조) |
| category_id | INT | PK, FK | NOT NULL | 카테고리 ID (Categories 참조) |


5. Orders (주문)

| 컬럼명 | 데이터 타입 | PK/FK | 제약조건 | 설명 |
|:---|:---|:---:|:---|:---|
| order_id | INT | PK | AUTO_INCREMENT | 주문 고유 ID |
| customer_id | INT | FK | NOT NULL | 고객 ID (Customers 참조) |
| order_date | DATETIME | | DEFAULT NOW() | 주문일 |
| shipping_address | VARCHAR(255) | | NOT NULL | 배송 주소 |
| total_amount | DECIMAL(10, 2) | | NOT NULL | 총 결제 금액 |

6. Order_Details (주문 상세)

| 컬럼명 | 데이터 타입 | PK/FK | 제약조건 | 설명 |
|:---|:---|:---:|:---|:---|
| order_detail_id | INT | PK | AUTO_INCREMENT | 주문 상세 고유 ID |
| order_id | INT | FK | NOT NULL | 주문 ID (Orders 참조) |
| product_id | INT | FK | NOT NULL | 상품 ID (Products 참조) |
| quantity | INT | | NOT NULL | 주문 수량 |
| price_at_purchase | DECIMAL(10, 2) | | NOT NULL | 주문 시점의 상품 가격 |

> **💡 중요**: `price_at_purchase` 컬럼은 매우 중요합니다. `Products` 테이블의 가격은 언제든 바뀔 수 있기 때문에, 주문 당시의 가격을 `Order_Details`에 별도로 저장해야 정확한 기록을 남길 수 있습니다.

7. Payments (결제)

| 컬럼명 | 데이터 타입 | PK/FK | 제약조건 | 설명 |
|:---|:---|:---:|:---|:---|
| payment_id | INT | PK | AUTO_INCREMENT | 결제 고유 ID |
| order_id | INT | FK | NOT NULL, UNIQUE | 주문 ID (Orders 참조, 1:1 관계) |
| payment_method | VARCHAR(50) | | NOT NULL | 결제 수단 (예: 'Credit Card') |
| amount | DECIMAL(10, 2) | | NOT NULL | 결제 금액 |
| payment_date | DATETIME | | DEFAULT NOW() | 결제 일시 |