# 5.1. 비동기 처리: AJAX로 좋아요 구현

지금까지의 '좋아요' 기능은 버튼을 누를 때마다 페이지 전체가 새로고침되는 방식이었습니다. 이는 사용자 경험을 저해하는 요소입니다. 이번 챕터에서는 JavaScript의 `fetch` API(AJAX)를 사용하여 서버와 비동기적으로 통신하고, 페이지 새로고침 없이 '좋아요' 상태와 개수를 동적으로 변경하는 방법을 알아봅니다. 이를 위해 Spring Boot에서는 JSON 형식으로 데이터를 응답하는 `@RestController`를 사용합니다.

---

## 1. JSON 응답을 위한 API 컨트롤러 생성

뷰(HTML)가 아닌 데이터(JSON)를 반환하는 컨트롤러를 API 컨트롤러라고 합니다. `@RestController` 어노테이션을 사용하면 클래스의 모든 메서드가 `@ResponseBody`를 적용받아, 반환하는 객체를 JSON 형식으로 변환하여 응답합니다.

#### 1) `LikeApiController` 생성

`com.example.instaclone.controller` 패키지에 `LikeApiController.java`를 생성합니다.

```java
package com.example.instaclone.controller;

import com.example.instaclone.domain.User;
import com.example.instaclone.service.PostService;
import com.example.instaclone.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Map;

@RestController
@RequiredArgsConstructor
public class LikeApiController {

    private final PostService postService;
    private final UserService userService;

    @PostMapping("/api/posts/{postId}/like")
    public ResponseEntity<Map<String, Object>> toggleLike(@PathVariable Long postId, @AuthenticationPrincipal UserDetails userDetails) {
        User user = userService.findByUsername(userDetails.getUsername());
        boolean liked = postService.toggleLike(postId, user);
        int likeCount = postService.getLikeCount(postId); // 좋아요 수를 가져오는 서비스 메서드 필요

        Map<String, Object> response = Map.of("liked", liked, "likeCount", likeCount);
        return ResponseEntity.ok(response);
    }
}
```

- **`@RestController`**: 이 컨트롤러의 모든 메서드는 뷰 이름이 아닌 데이터(JSON)를 반환합니다.
- **`ResponseEntity`**: HTTP 응답의 상태 코드, 헤더, 본문을 모두 포함하는 객체입니다. `ResponseEntity.ok()`는 HTTP 200 OK 상태와 함께 응답 본문을 보냅니다.
- **`Map.of(...)`**: 응답할 JSON 데이터를 `Map` 형태로 간단하게 만듭니다. `{"liked": true, "likeCount": 10}` 와 같은 JSON이 됩니다.

#### 2) `PostService`에 `getLikeCount` 메서드 추가

```java
// PostService.java

@Transactional(readOnly = true)
public int getLikeCount(Long postId) {
    Post post = postRepository.findById(postId)
            .orElseThrow(() -> new IllegalArgumentException("해당 게시물이 없습니다."));
    return post.getLikedBy().size();
}
```

---

## 2. JavaScript(AJAX)로 비동기 요청 보내기

`home.html`의 '좋아요' 버튼 로직을 JavaScript를 사용하도록 수정합니다.

```html
<!-- home.html의 '좋아요' 버튼 부분 수정 -->
<div>
    <button th:id="|like-btn-${post.id}|" 
            th:data-post-id="${post.id}" 
            th:classappend="${isLiked} ? 'btn-danger' : 'btn-outline-danger'" 
            class="btn btn-sm">❤️</button>
    <span th:id="|like-count-${post.id}|" th:text="${post.likeCount}">0</span> Likes
</div>
```

- `th:id`: 각 버튼과 카운트 span에 고유한 ID를 부여합니다.
- `th:data-post-id`: JavaScript에서 게시물 ID를 쉽게 가져올 수 있도록 `data-*` 속성을 사용합니다.
- `th:classappend`: 현재 사용자가 '좋아요'를 눌렀는지 여부(`isLiked` 변수, 컨트롤러에서 전달)에 따라 버튼 색상을 다르게 표시합니다.

이제 `home.html` 하단에 JavaScript 코드를 추가합니다.

```html
<!-- home.html의 </body> 태그 직전 -->
<script>
    document.querySelectorAll('[id^="like-btn-"]').forEach(button => {
        button.addEventListener('click', function() {
            const postId = this.dataset.postId;
            const likeCountSpan = document.getElementById(`like-count-${postId}`);

            fetch(`/api/posts/${postId}/like`, {
                method: 'POST',
                headers: {
                    // CSRF 토큰 추가 (SecurityConfig에서 CSRF 비활성화 시 불필요)
                }
            })
            .then(response => response.json())
            .then(data => {
                // 좋아요 수 업데이트
                likeCountSpan.textContent = data.likeCount;
                // 버튼 색상 변경
                if (data.liked) {
                    this.classList.remove('btn-outline-danger');
                    this.classList.add('btn-danger');
                } else {
                    this.classList.remove('btn-danger');
                    this.classList.add('btn-outline-danger');
                }
            });
        });
    });
</script>
```

- **`fetch()`**: JavaScript에서 서버로 비동기 HTTP 요청을 보내는 API입니다.
- `.then(response => response.json())`: 서버로부터 받은 JSON 응답을 JavaScript 객체로 변환합니다.
- `.then(data => { ... })`: 변환된 객체(`data`)를 사용하여 페이지의 좋아요 수와 버튼 색상을 동적으로 변경합니다. 페이지 새로고침이 일어나지 않습니다.

---

## 3. Django와 비교

- Spring의 **`@RestController`**는 Django 뷰에서 **`JsonResponse`**를 반환하는 것과 같습니다.

  ```python
  # Django views.py
  from django.http import JsonResponse

  def like_post_api(request, post_id):
      # ... 좋아요 토글 로직 ...
      response_data = {
          'liked': liked,
          'like_count': post.liked_by.count()
      }
      return JsonResponse(response_data)
  ```

- JavaScript의 **`fetch()` API**는 프레임워크에 종속되지 않는 웹 표준 기술이므로 Django 프로젝트에서도 똑같이 사용할 수 있습니다. 다만, Django는 CSRF 보호가 기본적으로 활성화되어 있으므로, `fetch` 요청 시 헤더에 CSRF 토큰을 포함시키는 코드가 추가로 필요합니다.
