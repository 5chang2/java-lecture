# 5.2. 예외 처리 및 로깅

애플리케이션을 운영하다 보면 존재하지 않는 게시물을 조회하거나, 잘못된 요청을 보내는 등 다양한 예외 상황이 발생할 수 있습니다. 이번 챕터에서는 이런 예외를 통합적으로 처리하는 **전역 예외 처리(Global Exception Handling)**와, 시스템의 동작 상태나 에러를 기록하는 **로깅(Logging)** 방법을 알아봅니다.

---

## 1. 전역 예외 처리 (`@ControllerAdvice`)

`@ControllerAdvice`는 모든 컨트롤러에서 발생하는 예외를 한 곳에서 처리할 수 있게 해주는 강력한 어노테이션입니다. 이를 사용하면 컨트롤러 메서드마다 `try-catch` 블록을 반복해서 작성할 필요가 없어집니다.

`com.example.instaclone.config` 패키지에 `GlobalExceptionHandler.java` 클래스를 생성합니다.

```java
package com.example.instaclone.config;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.servlet.ModelAndView;

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(IllegalArgumentException.class)
    public ModelAndView handleIllegalArgumentException(IllegalArgumentException e) {
        ModelAndView mav = new ModelAndView("error/404"); // templates/error/404.html
        mav.addObject("errorMessage", e.getMessage());
        mav.setStatus(HttpStatus.NOT_FOUND);
        return mav;
    }

    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<String> handleRuntimeException(RuntimeException e) {
        // API 요청에 대한 예외는 보통 JSON 형태로 응답
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("An unexpected error occurred: " + e.getMessage());
    }
}
```

- **`@ControllerAdvice`**: 이 클래스가 전역 예외 처리기임을 선언합니다.
- **`@ExceptionHandler(IllegalArgumentException.class)`**: `IllegalArgumentException` 타입의 예외가 발생하면 이 메서드가 실행됩니다. 우리는 서비스 계층에서 "해당 게시물이 없습니다" 와 같은 예외를 이 타입으로 던졌습니다.
- **`ModelAndView`**: 에러 페이지(HTML)와 함께 전달할 데이터를 담는 객체입니다. `error/404.html` 뷰를 렌더링하고, `errorMessage`를 모델에 추가합니다.
- API 요청에서 발생한 예외는 보통 HTML이 아닌 JSON 형태의 에러 메시지를 응답하는 것이 일반적입니다.

이제 `templates/error/404.html` 파일을 만들어 사용자에게 보여줄 친절한 에러 페이지를 디자인할 수 있습니다.

---

## 2. 로깅(Logging) 적용

Spring Boot는 별도 설정 없이 바로 사용할 수 있는 강력한 로깅 시스템(SLF4J & Logback)을 내장하고 있습니다. 로깅은 시스템의 현재 상태를 파악하고, 에러 발생 시 원인을 추적하는 데 필수적입니다.

#### 1) 로거(Logger) 선언

로그를 남기고 싶은 클래스(주로 서비스 클래스)에 `Logger` 객체를 선언합니다.

```java
// PostService.java

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
public class PostService {
    private static final Logger log = LoggerFactory.getLogger(PostService.class);
    // ...
}
```

#### 2) 로그 남기기

주요 로직의 실행 정보나 에러 상황을 로그로 기록합니다.

```java
// PostService.java의 create 메서드

@Transactional
public void create(PostCreateRequest request, User user) throws IOException {
    log.info("게시물 생성 시작: user={}, fileName={}", user.getUsername(), request.imageFile().getOriginalFilename());
    
    // ... 파일 저장 및 DB 저장 로직 ...

    log.info("게시물 생성 완료: postId={}", post.getId());
}

// PostService.java의 delete 메서드
@Transactional
public void delete(Long postId) {
    Post post = postRepository.findById(postId)
            .orElseThrow(() -> {
                log.warn("존재하지 않는 게시물 삭제 시도: postId={}", postId);
                return new IllegalArgumentException("해당 게시물을 찾을 수 없습니다.");
            });
    // ... 파일 삭제 및 DB 삭제 로직 ...
    log.info("게시물 삭제 완료: postId={}", postId);
}
```

- **`log.info(...)`**: 정보성 로그를 남깁니다. `log.warn()`, `log.error()` 등 다양한 로그 레벨이 있습니다.
- **`{}`**: 중괄호 플레이스홀더를 사용하면 파라미터 값을 문자열에 안전하고 효율적으로 포함시킬 수 있습니다.
- 이제 애플리케이션을 실행하고 기능을 사용하면 콘솔에 설정한 로그가 출력되는 것을 볼 수 있습니다.

#### 로그 레벨

- **TRACE > DEBUG > INFO > WARN > ERROR** 순으로 심각도가 높습니다.
- `application.properties`에서 특정 패키지의 로그 레벨을 조절할 수 있습니다.
  ```properties
  logging.level.com.example.instaclone=DEBUG
  ```

---

## 3. Django와 비교

- Spring의 **`@ControllerAdvice`** 와 **`@ExceptionHandler`**는 Django의 **미들웨어(Middleware)**를 이용한 예외 처리와 유사합니다. Django에서는 `process_exception` 메서드를 가진 미들웨어를 만들어 예외를 전역적으로 처리할 수 있습니다.
- Spring Boot의 **SLF4J/Logback** 로깅 시스템은 Python의 표준 **`logging`** 모듈에 해당합니다. Django에서는 `settings.py`의 `LOGGING` 사전에 로거, 핸들러, 포매터 등을 설정하여 로깅 시스템을 구성하며, 이는 Spring Boot의 `logback-spring.xml` 설정 파일과 유사한 역할을 합니다.
