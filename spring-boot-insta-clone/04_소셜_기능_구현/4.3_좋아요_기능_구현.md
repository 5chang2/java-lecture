# 4.3. 좋아요 기능 구현

소셜 미디어의 핵심 상호작용 중 하나인 '좋아요' 기능을 구현합니다. '좋아요'는 한 명의 사용자(User)가 여러 게시물(Post)에 '좋아요'를 누를 수 있고, 하나의 게시물은 여러 사용자로부터 '좋아요'를 받을 수 있는 **다대다(N:M, Many-to-Many)** 관계입니다. JPA의 `@ManyToMany` 어노테이션을 사용하여 이 관계를 모델링하는 방법을 알아봅니다.

---

## 1. 다대다(N:M) 연관관계 매핑

`User`와 `Post` 엔티티 사이에 `@ManyToMany` 관계를 설정합니다. JPA는 이 관계를 처리하기 위해 두 테이블의 ID를 묶어주는 **연결 테이블(Join Table)**을 자동으로 생성합니다.

#### 1) `Post` 엔티티 수정

게시물 입장에서 '좋아요'를 누른 사용자들이 누구인지 알아야 합니다.

```java
// Post.java

// ... imports ...
import java.util.HashSet;
import java.util.Set;

@Entity
// ...
public class Post {
    // ... 기존 필드 ...

    @ManyToMany
    @JoinTable(
        name = "post_like",
        joinColumns = @JoinColumn(name = "post_id"),
        inverseJoinColumns = @JoinColumn(name = "user_id")
    )
    private Set<User> likedBy = new HashSet<>();
}
```

- **`@ManyToMany`**: 다대다 관계임을 선언합니다.
- **`@JoinTable`**: 생성될 연결 테이블의 정보를 지정합니다.
  - `name = "post_like"`: 연결 테이블의 이름을 `post_like`로 지정합니다.
  - `joinColumns`: 현재 엔티티(`Post`)를 참조하는 외래 키 컬럼을 지정합니다.
  - `inverseJoinColumns`: 반대쪽 엔티티(`User`)를 참조하는 외래 키 컬럼을 지정합니다.
- **`Set<User>`**: '좋아요'를 누른 사용자는 중복될 수 없으므로, 중복을 허용하지 않는 `Set` 컬렉션을 사용합니다.

#### 2) `User` 엔티티 수정 (선택사항이지만 권장)

사용자 입장에서 자신이 '좋아요'를 누른 게시물 목록을 알 수 있도록 양방향 관계를 설정합니다.

```java
// User.java

// ...
@Entity
// ...
public class User {
    // ...

    @ManyToMany(mappedBy = "likedBy")
    private Set<Post> likedPosts = new HashSet<>();
}
```

- `mappedBy = "likedBy"`: 이 관계의 주인이 `Post` 엔티티의 `likedBy` 필드임을 명시합니다. 이쪽은 DB에 영향을 주지 않습니다.

---

## 2. '좋아요' 처리 로직 구현

사용자가 '좋아요' 버튼을 눌렀을 때, 이미 '좋아요'를 누른 상태라면 취소하고, 아니라면 '좋아요'를 추가하는 토글(Toggle) 방식의 로직을 구현합니다.

#### 1) `PostService`에 `toggleLike` 메서드 추가

```java
// PostService.java

// ...
@Transactional
public boolean toggleLike(Long postId, User user) {
    Post post = postRepository.findById(postId)
            .orElseThrow(() -> new IllegalArgumentException("해당 게시물이 없습니다."));

    // 사용자가 이미 '좋아요'를 눌렀는지 확인
    if (post.getLikedBy().contains(user)) {
        post.getLikedBy().remove(user);
        return false; // 좋아요 취소
    } else {
        post.getLikedBy().add(user);
        return true; // 좋아요 추가
    }
}
```

- `@Transactional` 환경이므로, `post.getLikedBy()` 컬렉션에 `user`를 추가하거나 제거하기만 하면 Dirty Checking에 의해 JPA가 자동으로 연결 테이블의 데이터를 관리해줍니다.

#### 2) `PostController`에 '좋아요' 처리 메서드 추가

```java
// PostController.java

// ...
@PostMapping("/posts/{postId}/like")
public String toggleLike(@PathVariable Long postId, @AuthenticationPrincipal UserDetails userDetails) {
    User user = userRepository.findByUsername(userDetails.getUsername()).orElseThrow();
    postService.toggleLike(postId, user);
    return "redirect:/";
}
```

---

## 3. 뷰(View)에 '좋아요' 버튼 및 카운트 추가

`home.html`에 '좋아요' 버튼과 '좋아요' 개수를 표시합니다.

```html
<!-- home.html의 card-body 내부 -->
<div>
    <!-- 좋아요 버튼 -->
    <form th:action="@{/posts/{id}/like(id=${post.id})}" method="post" style="display: inline;">
        <button type="submit" class="btn btn-sm btn-outline-danger">❤️</button>
    </form>
    <!-- 좋아요 개수 -->
    <span th:text="${post.likeCount}">0</span> Likes
</div>
```

- **`th:text="${post.likeCount}"`**: '좋아요' 개수를 표시하기 위해 `PostResponse` DTO에 `likeCount` 필드를 추가해야 합니다.

**`PostResponse` DTO 수정**
```java
public record PostResponse(
        // ... 기존 필드
        int likeCount // 좋아요 수
) {
    public static PostResponse from(Post post) {
        return new PostResponse(
                // ...
                post.getLikedBy().size()
        );
    }
}
```

---

## 4. Django와 비교

- JPA의 **`@ManyToMany`** 어노테이션은 Django 모델의 **`models.ManyToManyField`** 필드 타입과 정확히 동일한 역할을 합니다. 두 프레임워크 모두 개발자가 직접 연결 테이블을 만들지 않아도, 다대다 관계를 설정하면 자동으로 생성하고 관리해줍니다.

  ```python
  # Django models.py
  class Post(models.Model):
      # ...
      liked_by = models.ManyToManyField(User, related_name='liked_posts')
  ```

- '좋아요' 토글 로직도 유사합니다. Django에서도 `post.liked_by.add(user)` 또는 `post.liked_by.remove(user)`와 같은 메서드를 사용하여 다대다 관계를 조작합니다.
