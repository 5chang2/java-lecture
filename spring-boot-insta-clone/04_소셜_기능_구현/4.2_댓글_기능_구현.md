# 4.2. 댓글 기능 구현

게시물에 사용자들이 의견을 남길 수 있는 댓글 기능을 구현합니다. 댓글(`Comment`)은 게시물(`Post`)과 작성자(`User`) 모두와 관계를 맺는 새로운 엔티티입니다. 이를 통해 N:1 연관관계 매핑을 한 번 더 연습하고, 한 페이지 안에서 여러 정보를 함께 처리하는 방법을 알아봅니다.

---

## 1. Comment 엔티티 및 리포지토리 생성

#### 1) `Comment.java` 엔티티 생성

`com.example.instaclone.domain` 패키지에 `Comment.java` 클래스를 생성합니다.

```java
package com.example.instaclone.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;

@Entity
@Getter
@NoArgsConstructor
public class Comment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String content;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "post_id")
    private Post post;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;

    @CreationTimestamp
    private LocalDateTime createdAt;

    public Comment(String content, Post post, User user) {
        this.content = content;
        this.post = post;
        this.user = user;
    }
}
```

- `Comment` 엔티티는 자신이 속한 `Post`와 자신을 작성한 `User` 정보를 모두 알고 있어야 하므로, 각각 `@ManyToOne` 관계로 연결됩니다.

#### 2) `CommentRepository.java` 인터페이스 생성

`com.example.instaclone.repository` 패키지에 `CommentRepository.java`를 생성합니다.

```java
package com.example.instaclone.repository;

import com.example.instaclone.domain.Comment;
import org.springframework.data.jpa.repository.JpaRepository;

public interface CommentRepository extends JpaRepository<Comment, Long> {
}
```

---

## 2. 댓글 작성 로직 구현

#### 1) DTO 및 Service, Controller 생성

- **DTO**: `CommentRequest` (content), `CommentResponse` (id, content, username) 등을 `dto` 패키지에 생성합니다.
- **Service**: `CommentService`를 만들고, `Post`와 `User` 정보를 받아 `Comment`를 생성하고 저장하는 `createComment` 메서드를 구현합니다.
- **Controller**: `PostController` 또는 별도의 `CommentController`에 `@PostMapping("/posts/{postId}/comments")` 와 같은 URL을 처리하는 메서드를 만듭니다.

**`CommentService.java` (예시)**
```java
@Service
@RequiredArgsConstructor
public class CommentService {
    private final CommentRepository commentRepository;
    private final PostRepository postRepository; // Post를 조회하기 위해 필요

    @Transactional
    public void createComment(Long postId, String content, User user) {
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new IllegalArgumentException("해당 게시물이 없습니다."));
        
        Comment comment = new Comment(content, post, user);
        commentRepository.save(comment);
    }
}
```

**`PostController.java`에 댓글 생성 메서드 추가 (예시)**
```java
@PostMapping("/posts/{postId}/comments")
public String createComment(@PathVariable Long postId, @RequestParam String content, @AuthenticationPrincipal UserDetails userDetails) {
    User user = userRepository.findByUsername(userDetails.getUsername()).orElseThrow();
    commentService.createComment(postId, content, user); // CommentService 주입 필요
    return "redirect:/"; // 또는 게시물 상세 페이지로 리다이렉트
}
```

---

## 3. 뷰(View)에 댓글 폼 및 목록 추가

`home.html`의 각 게시물 카드에 댓글을 작성하는 폼과 댓글 목록을 보여주는 부분을 추가합니다.

```html
<!-- home.html의 card-body 내부, 수정/삭제 버튼 아래 -->
<div class="mt-3">
    <!-- 댓글 목록 -->
    <div th:each="comment : ${post.comments}" class="mb-2">
        <strong><span th:text="${comment.username}"></span></strong>
        <span th:text="${comment.content}"></span>
    </div>

    <!-- 댓글 작성 폼 -->
    <form th:action="@{/posts/{id}/comments(id=${post.id})}" method="post" class="mt-2">
        <div class="input-group">
            <input type="text" name="content" class="form-control" placeholder="댓글 달기...">
            <button type="submit" class="btn btn-outline-secondary">게시</button>
        </div>
    </form>
</div>
```

- **`th:each="comment : ${post.comments}"`**: `PostResponse` DTO에 `comments` 리스트가 포함되어 있어야 합니다. `Post` 엔티티에 `@OneToMany`로 `Comment` 목록을 추가하고, `PostResponse`의 `from()` 메서드에서 이 목록을 `CommentResponse` DTO 리스트로 변환하여 담아주어야 합니다.

**`PostResponse` DTO 수정 (예시)**
```java
public record PostResponse(
        // ... 기존 필드
        String username, // 작성자 이름
        List<CommentResponse> comments // 댓글 목록
) {
    public static PostResponse from(Post post) {
        return new PostResponse(
                // ...
                post.getUser().getUsername(),
                post.getComments().stream().map(CommentResponse::from).collect(Collectors.toList())
        );
    }
}
```

---

## 4. Django와 비교

- **`Comment` 엔티티**는 Django에서 `ForeignKey`를 사용하여 `Post`와 `User` 모델에 각각 연결한 **`Comment` 모델**과 완벽하게 동일한 구조입니다.
- **댓글 폼과 목록을 한 페이지에 표시**하는 것은 두 프레임워크 모두 동일한 방식으로 처리합니다. 부모 객체(Post)를 기준으로 자식 객체(Comment)들을 조회하고, 템플릿에서 반복문을 통해 렌더링합니다.
- Spring에서 `PostResponse` DTO를 수정하여 댓글 목록까지 포함시킨 것처럼, Django에서도 `Post` 객체를 템플릿에 전달하면 `post.comment_set.all`과 같은 역참조를 통해 댓글 목록에 접근할 수 있습니다.
