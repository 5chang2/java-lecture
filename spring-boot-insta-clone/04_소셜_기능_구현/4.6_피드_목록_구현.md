# 4.6. 피드 목록 구현

소셜 미디어의 핵심인 '피드' 기능을 구현합니다. 피드는 현재 로그인한 사용자가 팔로우하는 사람들의 게시물만 시간순으로 보여주는 페이지입니다. 이 기능을 구현하려면 여러 테이블을 조인(JOIN)하는 것과 유사한, 복잡한 조건의 쿼리가 필요합니다. Spring Data JPA에서 JPQL(Java Persistence Query Language)을 사용하여 직접 쿼리를 작성하는 방법을 알아봅니다.

---

## 1. JPQL을 이용한 커스텀 쿼리 작성

Spring Data JPA는 메서드 이름만으로 쿼리를 생성하는 강력한 기능을 제공하지만, 복잡한 쿼리는 직접 작성해야 할 때가 있습니다. 이때 JPQL을 사용합니다. JPQL은 SQL과 매우 유사하지만, 테이블이 아닌 **엔티티 객체**를 대상으로 쿼리를 작성하는 것이 특징입니다.

`PostRepository.java` 인터페이스에 다음 메서드를 추가합니다.

```java
// PostRepository.java

// ... imports ...
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface PostRepository extends JpaRepository<Post, Long> {

    @Query("SELECT p FROM Post p WHERE p.user IN :followings ORDER BY p.createdAt DESC")
    List<Post> findFeedPosts(@Param("followings") Set<User> followings);

}
```

- **`@Query`**: 이 메서드가 JPQL 쿼리를 사용함을 나타냅니다.
- **`SELECT p FROM Post p`**: `Post` 테이블이 아닌 `Post` **엔티티**를 조회하겠다는 의미입니다. `p`는 `Post` 엔티티의 별칭(alias)입니다.
- **`WHERE p.user IN :followings`**: `Post` 엔티티의 `user` 필드가 `:followings` 파라미터로 전달된 사용자 목록(`Set<User>`)에 포함된 게시물만 조회합니다.
- **`@Param("followings")`**: 메서드의 `followings` 파라미터를 JPQL의 `:followings` 파라미터에 바인딩합니다.

---

## 2. 피드 로직 구현 (Service, Controller)

#### 1) `PostService`에 피드 조회 메서드 추가

```java
// PostService.java

// ...
@Transactional(readOnly = true)
public List<PostResponse> findFeed(User user) {
    Set<User> followings = user.getFollowings();
    if (followings.isEmpty()) {
        return Collections.emptyList();
    }

    List<Post> feedPosts = postRepository.findFeedPosts(followings);
    return feedPosts.stream()
            .map(PostResponse::from)
            .collect(Collectors.toList());
}
```

- 현재 사용자의 `followings` 목록을 가져옵니다.
- `postRepository.findFeedPosts()` 메서드를 호출하여 팔로잉하는 사용자들의 게시물만 조회합니다.
- 조회된 `Post` 엔티티 리스트를 `PostResponse` DTO 리스트로 변환하여 반환합니다.

#### 2) `PostController`에 피드 페이지 처리 메서드 추가

```java
// PostController.java

// ...
@GetMapping("/feed")
public String feedPage(@AuthenticationPrincipal UserDetails userDetails, Model model) {
    User user = userService.findByUsername(userDetails.getUsername());
    List<PostResponse> feedPosts = postService.findFeed(user);
    model.addAttribute("posts", feedPosts);
    return "posts/feed"; // templates/posts/feed.html 뷰 반환
}
```

---

## 3. 피드 페이지 뷰(View) 만들기

`templates/posts/` 경로에 `feed.html` 파일을 생성합니다. 이 파일의 내용은 `home.html`과 거의 동일하며, 모든 게시물이 아닌 피드 게시물 목록을 `posts` 변수로 받아 출력합니다.

```html
<!-- feed.html -->
<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Insta Clone - Feed</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
    <div th:replace="~{fragments/navbar :: navbar}"></div>

    <div class="container mt-4">
        <h1 class="mb-4">My Feed</h1>
        <div class="row justify-content-center">
            <div class="col-md-6">
                <!-- 게시물 카드 반복 (home.html과 동일) -->
                <div th:each="post : ${posts}" class="card mb-4">
                    <!-- ... (home.html의 게시물 카드 내용과 동일) ... -->
                </div>
            </div>
        </div>
    </div>
</body>
</html>
```

이제 내비게이션 바에 '피드' 메뉴를 추가하고 `/feed` 경로로 링크를 걸어주면, 팔로우하는 사람들의 게시물만 볼 수 있는 피드 페이지가 완성됩니다.

---

## 4. Django와 비교

- JPQL을 사용하여 직접 쿼리를 작성하는 것은 Django ORM에서 `filter()`, `exclude()`, `order_by()` 등을 조합하여 복잡한 쿼리셋(QuerySet)을 만드는 것과 같습니다.

  ```python
  # Django views.py
  def feed(request):
      following_users = request.user.following.all()
      posts = Post.objects.filter(author__in=following_users).order_by('-created_at')
      return render(request, 'feed.html', {'posts': posts})
  ```

- Spring Data JPA의 **`@Query`** 어노테이션은 Django의 **`Post.objects.filter(author__in=...)`** 와 같은 복잡한 조회 조건을 코드로 표현하는 방법입니다.
- `author__in`과 같이 `__`를 사용하여 연관된 모델의 필드를 조회하는 Django의 방식과, `p.user IN :followings`와 같이 객체 그래프를 탐색하는 JPQL의 방식은 매우 유사한 객체지향적 쿼리 접근법입니다.

이것으로 기본적인 소셜 기능 구현이 모두 완료되었습니다. 다음 챕터에서는 비동기 통신(AJAX)을 이용해 사용자 경험을 향상시키는 방법을 알아봅니다.
