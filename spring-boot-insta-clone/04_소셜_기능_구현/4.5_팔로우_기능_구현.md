# 4.5. 팔로우 기능 구현

소셜 기능의 핵심인 팔로우(Follow) 기능을 구현합니다. 팔로우는 사용자(User)가 다른 사용자(User)를 구독하는 관계로, 엔티티 관점에서는 **자기 자신을 참조하는 다대다(Self-Referencing Many-to-Many)** 관계입니다. 이 복잡해 보이는 관계를 JPA의 `@ManyToMany`를 사용하여 모델링하고, 팔로우/언팔로우 로직을 구현해봅니다.

---

## 1. 팔로우 연관관계 매핑 (`User` 엔티티)

`User` 엔티티에 팔로잉(following)과 팔로워(follower) 목록을 추가합니다. 한 명의 사용자는 여러 명을 팔로우할 수 있고, 여러 명의 팔로워를 가질 수 있습니다.

```java
// User.java

// ...
@Entity
@Table(name = "users")
public class User {
    // ...

    @ManyToMany
    @JoinTable(
        name = "follow",
        joinColumns = @JoinColumn(name = "from_user_id"), // 나를 팔로우하는 사람
        inverseJoinColumns = @JoinColumn(name = "to_user_id")   // 내가 팔로우하는 사람
    )
    private Set<User> followers = new HashSet<>();

    @ManyToMany(mappedBy = "followers")
    private Set<User> followings = new HashSet<>();
}
```

- **`followers` 필드**: 이 관계의 주인 역할을 합니다. `follow`라는 이름의 연결 테이블을 생성합니다.
  - `joinColumns = @JoinColumn(name = "from_user_id")`: `follow` 테이블에서 나(`User`)를 참조하는 컬럼입니다. 즉, 팔로우를 하는 주체(follower)의 ID가 저장됩니다.
  - `inverseJoinColumns = @JoinColumn(name = "to_user_id")`: `follow` 테이블에서 내가 팔로우하는 대상(following)의 ID가 저장됩니다.
- **`followings` 필드**: `followers`에 의해 매핑되는, 관계의 주인이 아닌 쪽입니다. `mappedBy`를 사용하여 DB에 추가적인 컬럼 생성을 막습니다.

---

## 2. 팔로우/언팔로우 로직 구현

#### 1) `UserService`에 팔로우/언팔로우 메서드 추가

```java
// UserService.java

// ...
@Transactional
public void follow(User fromUser, User toUser) {
    if (fromUser.getId().equals(toUser.getId())) {
        throw new IllegalArgumentException("자기 자신을 팔로우할 수 없습니다.");
    }
    fromUser.getFollowings().add(toUser);
    toUser.getFollowers().add(fromUser);
}

@Transactional
public void unfollow(User fromUser, User toUser) {
    fromUser.getFollowings().remove(toUser);
    toUser.getFollowers().remove(fromUser);
}
```

- `@Transactional` 환경이므로, 각 `User` 객체의 `followings`와 `followers` `Set` 컬렉션에서 상대방을 추가하거나 제거하기만 하면 JPA가 알아서 연결 테이블의 데이터를 관리해줍니다.

#### 2) `UserController`에 팔로우/언팔로우 처리 메서드 추가

```java
// UserController.java

// ...
@PostMapping("/follow/{userId}")
public String follow(@PathVariable Long userId, @AuthenticationPrincipal UserDetails userDetails) {
    User fromUser = userService.findByUsername(userDetails.getUsername());
    User toUser = userService.findById(userId); // findById 메서드 필요
    userService.follow(fromUser, toUser);
    return "redirect:/profile/" + toUser.getUsername();
}

@PostMapping("/unfollow/{userId}")
public String unfollow(@PathVariable Long userId, @AuthenticationPrincipal UserDetails userDetails) {
    User fromUser = userService.findByUsername(userDetails.getUsername());
    User toUser = userService.findById(userId);
    userService.unfollow(fromUser, toUser);
    return "redirect:/profile/" + toUser.getUsername();
}
```

---

## 3. 뷰(View)에 팔로우/언팔로우 버튼 추가

`profile.html` 페이지에 현재 로그인한 사용자가 프로필 페이지의 주인을 팔로우하고 있는지 여부에 따라 다른 버튼이 보이도록 수정합니다.

```html
<!-- profile.html의 프로필 정보 부분 -->
<div class="col-md-9">
    <h2 th:text="${user.username}">Username</h2>
    <div class="d-flex align-items-center">
        <p class="me-3">게시물 <strong th:text="${user.posts.size()}">0</strong></p>
        <p class="me-3">팔로워 <strong th:text="${user.followers.size()}">0</strong></p>
        <p>팔로잉 <strong th:text="${user.followings.size()}">0</strong></p>
    </div>

    <!-- 팔로우/언팔로우 버튼 (로그인한 사용자에게만, 그리고 자기 자신이 아닐 때만 보임) -->
    <div sec:authorize="isAuthenticated()" th:if="${#authentication.name != user.username}">
        <!-- 현재 사용자가 이 프로필 유저를 팔로우하고 있지 않다면 -->
        <form th:if="${!isFollowing}" th:action="@{/follow/{id}(id=${user.id})}" method="post">
            <button type="submit" class="btn btn-primary">팔로우</button>
        </form>
        <!-- 현재 사용자가 이 프로필 유저를 팔로우하고 있다면 -->
        <form th:if="${isFollowing}" th:action="@{/unfollow/{id}(id=${user.id})}" method="post">
            <button type="submit" class="btn btn-outline-secondary">언팔로우</button>
        </form>
    </div>
</div>
```

- **`isFollowing`**: 컨트롤러에서 현재 로그인한 사용자가 프로필 사용자를 팔로우하고 있는지 여부를 boolean 값으로 계산하여 모델에 담아 보내주어야 합니다.
- **`#authentication.name`**: Thymeleaf Security 확장 기능으로, 현재 로그인한 사용자의 이름(username)에 접근할 수 있습니다.

---

## 4. Django와 비교

- JPA의 자기 참조 `@ManyToMany` 관계 설정은 Django의 `ManyToManyField('self')`와 매우 유사합니다. 다만 Django에서는 연결 테이블을 직접 명시하지 않으면 자동으로 생성해주지만, JPA에서는 `@JoinTable`로 더 명시적으로 제어하는 경우가 많습니다.

  ```python
  # Django models.py
  class User(AbstractUser):
      # ...
      following = models.ManyToManyField(
          'self',
          symmetrical=False,
          related_name='followers'
      )
  ```
  - `symmetrical=False` 옵션은 A가 B를 팔로우할 때 B도 A를 자동으로 팔로우하지 않도록 설정하는 것으로, 팔로우 기능의 핵심입니다.

- 로직 자체는 비슷합니다. Django에서도 `user.following.add(other_user)` 와 `user.following.remove(other_user)`를 사용하여 관계를 조작합니다.
