# 4.1. 게시물과 사용자 연동

지금까지의 게시물은 누가 작성했는지에 대한 정보가 없었습니다. 이번 챕터에서는 Spring Security를 통해 얻은 현재 로그인한 사용자 정보를 게시물과 연동하여, "이 게시물은 A 사용자가 작성했다"는 관계를 맺어주는 방법을 배웁니다. JPA의 연관관계 매핑 중 가장 기본이 되는 `@ManyToOne`을 사용합니다.

---

## 1. 엔티티 연관관계 매핑

하나의 사용자(User)는 여러 개의 게시물(Post)을 작성할 수 있습니다. 이를 객체 지향적으로 표현하면 `Post`와 `User`는 **다대일(N:1)** 관계가 됩니다.

#### 1) `Post` 엔티티 수정

`Post.java`에 `User` 필드를 추가합니다.

```java
// Post.java

// ... imports ...
import com.example.instaclone.domain.User;

@Entity
// ...
public class Post {
    // ... 기존 필드 ...

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;

    //== 생성자 수정 ==//
    public Post(String content, String imageUrl, User user) {
        this.content = content;
        this.imageUrl = imageUrl;
        this.user = user;
    }
    
    // 기본 생성자는 JPA를 위해 유지
    public Post() {}
}
```

- **`@ManyToOne`**: `Post`가 N, `User`가 1인 다대일 관계임을 나타냅니다.
- **`fetch = FetchType.LAZY`**: **지연 로딩** 설정입니다. `Post`를 조회할 때 연관된 `User` 정보를 바로 가져오지 않고, 실제로 `post.getUser()`처럼 `User` 정보가 필요한 시점에 가져오도록 하여 불필요한 쿼리를 줄여줍니다. 성능 최적화를 위해 필수적인 옵션입니다.
- **`@JoinColumn(name = "user_id")`**: `post` 테이블에 생성될 외래 키(Foreign Key) 컬럼의 이름을 `user_id`로 지정합니다.

#### 2) `User` 엔티티에 양방향 관계 추가 (선택사항)

사용자 입장에서 자신이 작성한 모든 게시물을 알고 싶을 수 있습니다. 이를 위해 `User` 엔티티에 게시물 목록을 추가하여 **양방향 관계**를 만들 수 있습니다.

```java
// User.java

// ... imports ...
import java.util.ArrayList;
import java.util.List;

@Entity
// ...
public class User {
    // ... 기존 필드 ...

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Post> posts = new ArrayList<>();
}
```

- **`@OneToMany(mappedBy = "user")`**: 일대다(1:N) 관계이며, 이 관계의 주인이 `Post` 엔티티의 `user` 필드임을 나타냅니다. `mappedBy`가 지정된 쪽은 DB 테이블에 컬럼이 추가되지 않습니다.

---

## 2. 서비스 및 컨트롤러 로직 수정

게시물을 생성할 때, 현재 로그인한 사용자의 정보를 함께 저장하도록 로직을 수정해야 합니다.

#### 1) `PostService` 수정

`create` 메서드가 `User` 정보를 파라미터로 받도록 수정합니다.

```java
// PostService.java

// ...
@Transactional
public void create(PostCreateRequest request, User user) throws IOException {
    // ... 파일 저장 로직 ...
    String imageUrl = "/images/" + savedFilename;

    // 2. DB에 Post 정보 저장 (user 정보 추가)
    Post post = new Post(request.content(), imageUrl, user);
    postRepository.save(post);
}
```

#### 2) `PostController` 수정

컨트롤러에서 현재 로그인한 사용자 정보를 가져와 서비스로 넘겨줍니다.

```java
// PostController.java

// ... imports ...
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;

@PostMapping("/posts")
public String createPost(PostCreateRequest request, @AuthenticationPrincipal UserDetails userDetails) throws IOException {
    // UserDetails에서 username을 가져와 DB에서 User 엔티티를 다시 조회해야 함
    // (이 과정은 다음 챕터들에서 더 세련되게 바뀔 예정)
    User user = userRepository.findByUsername(userDetails.getUsername()).orElseThrow(); // UserRepository 주입 필요
    postService.create(request, user);
    return "redirect:/";
}
```

- **`@AuthenticationPrincipal`**: Spring Security가 관리하는 현재 인증된 사용자의 `Principal` 객체를 파라미터로 주입해줍니다. `UserDetails` 타입으로 받아 사용자 정보를 얻을 수 있습니다.

---

## 3. 뷰(View) 수정

게시물 목록에서 작성자의 이름을 표시하도록 `home.html`을 수정합니다.

```html
<!-- home.html의 card-body 내부 -->
<div class="card-body">
    <h6 class="card-title" th:text="${post.username}">작성자</h6> <!-- 작성자 이름 표시 -->
    <p class="card-text" th:text="${post.content}"></p>
    <p class="card-text"><small class="text-muted" th:text="${post.createdAt}"></small></p>
    <!-- ... -->
</div>
```

- `PostResponse` DTO에도 `username` 필드를 추가하고, `from()` 메서드에서 `post.getUser().getUsername()` 값을 담아주도록 수정해야 합니다.

---

## 4. Django와 비교

- JPA의 **`@ManyToOne`**, **`@OneToMany`** 어노테이션은 Django 모델의 **`models.ForeignKey`** 와 정확히 같은 역할을 합니다. 데이터베이스의 외래 키 관계를 객체 세상에서 표현하는 방법입니다.
- Spring Security의 **`@AuthenticationPrincipal`** 은 Django 뷰에서 `request` 객체를 통해 **`request.user`** 로 현재 로그인한 사용자 정보에 접근하는 것과 동일한 개념입니다.

이제 게시물은 소유자 정보를 갖게 되었으며, 이를 기반으로 다음 챕터에서 권한 검사, 댓글, 좋아요 등 다양한 소셜 기능을 구현할 수 있습니다.
