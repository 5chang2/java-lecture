# 3.2. 회원가입 구현

보안 설정의 기초를 다졌으니, 이제 사용자가 직접 계정을 만들 수 있는 회원가입 기능을 구현합니다. 사용자가 입력한 비밀번호는 반드시 암호화하여 데이터베이스에 저장해야 합니다. 이전 챕터에서 `SecurityConfig`에 Bean으로 등록한 `PasswordEncoder`를 사용하여 이 과정을 처리합니다.

---

## 1. 회원가입 폼(View) 및 DTO

#### 1) `signup-form.html` 생성

`templates/` 경로에 `users` 폴더를 새로 만들고, 그 안에 `signup-form.html` 파일을 생성합니다.

```html
<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>회원가입</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
<div class="container">
    <div class="row justify-content-center">
        <div class="col-md-6">
            <h1 class="my-4 text-center">회원가입</h1>
            <form action="/signup" method="post">
                <div class="mb-3">
                    <label for="username" class="form-label">사용자 이름</label>
                    <input type="text" class="form-control" id="username" name="username" required>
                </div>
                <div class="mb-3">
                    <label for="password" class="form-label">비밀번호</label>
                    <input type="password" class="form-control" id="password" name="password" required>
                </div>
                <div class="mb-3">
                    <label for="email" class="form-label">이메일</label>
                    <input type="email" class="form-control" id="email" name="email">
                </div>
                <div class="d-grid">
                    <button type="submit" class="btn btn-primary">가입하기</button>
                </div>
            </form>
        </div>
    </div>
</div>
</body>
</html>
```

#### 2) `UserSignupRequest` DTO 생성

`com.example.instaclone.domain.dto` 패키지에 회원가입 요청 데이터를 담을 DTO를 생성합니다.

```java
package com.example.instaclone.domain.dto;

public record UserSignupRequest(
        String username,
        String password,
        String email
) {
}
```

---

## 2. 회원가입 로직 구현 (Controller, Service)

#### 1) `UserService` 생성

`com.example.instaclone.service` 패키지에 `UserService.java`를 생성하고, 회원가입 비즈니스 로직을 작성합니다.

```java
package com.example.instaclone.service;

import com.example.instaclone.domain.User;
import com.example.instaclone.domain.dto.UserSignupRequest;
import com.example.instaclone.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    @Transactional
    public void signup(UserSignupRequest request) {
        // 1. 사용자 이름 중복 확인
        userRepository.findByUsername(request.username()).ifPresent(user -> {
            throw new IllegalArgumentException("이미 존재하는 사용자 이름입니다.");
        });

        // 2. 비밀번호 암호화
        String encodedPassword = passwordEncoder.encode(request.password());

        // 3. 사용자 정보 저장
        User user = new User(request.username(), encodedPassword, request.email());
        userRepository.save(user);
    }
}
```

- **`PasswordEncoder` 주입**: `SecurityConfig`에 Bean으로 등록된 `PasswordEncoder`를 의존성 주입받습니다.
- **중복 확인**: `userRepository.findByUsername()`을 사용하여 이미 같은 이름의 사용자가 있는지 확인하고, 있다면 예외를 발생시킵니다.
- **비밀번호 암호화**: `passwordEncoder.encode()` 메서드를 사용하여 평문 비밀번호를 안전한 해시값으로 변경합니다.
- **사용자 저장**: 암호화된 비밀번호와 함께 `User` 객체를 생성하여 `userRepository.save()`로 데이터베이스에 저장합니다.

#### 2) `UserController` 생성

`com.example.instaclone.controller` 패키지에 `UserController.java`를 생성합니다.

```java
package com.example.instaclone.controller;

import com.example.instaclone.domain.dto.UserSignupRequest;
import com.example.instaclone.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;

@Controller
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @GetMapping("/signup")
    public String signupForm() {
        return "users/signup-form";
    }

    @PostMapping("/signup")
    public String signup(UserSignupRequest request) {
        userService.signup(request);
        return "redirect:/login"; // 회원가입 성공 시 로그인 페이지로 리다이렉트
    }
}
```

- **`GET /signup`**: `signup-form.html` 뷰를 보여줍니다.
- **`POST /signup`**: `UserSignupRequest` DTO로 폼 데이터를 받아 `userService.signup()`을 호출하여 회원가입 로직을 수행합니다. 성공적으로 완료되면 `/login` 경로로 리다이렉트합니다.

---

## 3. Django와 비교

Spring Boot에서 `UserService`가 수행하는 역할은 Django의 `forms.py`와 `views.py`가 함께 처리하는 로직과 유사합니다.

**Django의 `forms.py`와 `views.py`**
```python
# forms.py
from django.contrib.auth.forms import UserCreationForm

class CustomUserCreationForm(UserCreationForm):
    class Meta(UserCreationForm.Meta):
        model = User
        fields = ('username', 'email',)

# views.py
from django.shortcuts import render, redirect

def signup(request):
    if request.method == 'POST':
        form = CustomUserCreationForm(request.POST)
        if form.is_valid():
            form.save() # 폼이 알아서 비밀번호 암호화 및 사용자 저장
            return redirect('/login')
    else:
        form = CustomUserCreationForm()
    return render(request, 'signup.html', {'form': form})
```

- Spring의 `UserService`에서 직접 처리하는 **사용자 이름 중복 검사**와 **비밀번호 암호화** 로직은, Django에서는 `UserCreationForm`이 내부적으로 상당 부분 처리해줍니다.
- Spring에서는 `PasswordEncoder`를 직접 주입받아 `encode()`를 호출하는 반면, Django의 `form.save()`는 이 과정을 추상화하여 숨깁니다.
- 두 프레임워크 모두 클라이언트의 요청을 받아 유효성을 검증하고, 데이터를 가공하여 데이터베이스에 저장하는 큰 흐름은 동일합니다.
