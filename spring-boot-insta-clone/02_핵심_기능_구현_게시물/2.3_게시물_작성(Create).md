# 2.3. 게시물 작성(Create)

이제 사용자가 직접 게시물을 작성할 수 있는 UI와 서버 로직을 구현합니다. HTML 폼을 통해 텍스트와 이미지 파일을 받아, 이전에 설정한 파일 저장소에 이미지를 저장하고, 데이터베이스에는 게시물 내용과 이미지 경로를 기록하는 흐름을 만듭니다.

---

## 1. 게시물 작성 폼(View) 만들기

먼저 `src/main/resources/templates/` 경로에 `posts`라는 새 폴더를 만들고, 그 안에 `post-form.html` 파일을 생성합니다.

```html
<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>새 게시물 작성</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
    <div class="container">
        <h1 class="my-4">새 게시물 작성</h1>
        <form action="/posts" method="post" enctype="multipart/form-data">
            <div class="mb-3">
                <label for="content" class="form-label">내용</label>
                <textarea class="form-control" id="content" name="content" rows="3" required></textarea>
            </div>
            <div class="mb-3">
                <label for="image" class="form-label">이미지</label>
                <input class="form-control" type="file" id="image" name="imageFile" accept="image/*" required>
            </div>
            <button type="submit" class="btn btn-primary">작성하기</button>
        </form>
    </div>
</body>
</html>
```

- **`enctype="multipart/form-data"`**: `<form>` 태그의 이 속성은 파일(이미지 등)을 서버로 전송하기 위해 **반드시** 필요합니다.
- `name="content"`, `name="imageFile"`: 이 `name` 속성값은 서버에서 요청 데이터를 받을 때 사용하는 키(key)가 됩니다.

---

## 2. DTO(Data Transfer Object) 생성

클라이언트의 요청 데이터를 컨트롤러로 전달할 때, 각 데이터를 개별 파라미터로 받기보다는 데이터를 담는 전용 객체인 DTO를 사용하는 것이 좋습니다. `com.example.instaclone.domain` 패키지 아래에 `dto` 패키지를 만들고 `PostCreateRequest.java` 클래스를 생성합니다.

```java
package com.example.instaclone.domain.dto;

import org.springframework.web.multipart.MultipartFile;

public record PostCreateRequest(
        String content,
        MultipartFile imageFile
) {
}
```

- **`record`**: Java 16부터 도입된 `record`는 데이터 전달을 목적으로 하는 불변 객체를 쉽게 만들 수 있는 기능입니다. 컴파일러가 자동으로 생성자, getter, `equals()`, `hashCode()`, `toString()` 메서드를 만들어줍니다.
- `MultipartFile`: Spring에서 파일 업로드를 처리할 때 사용하는 타입입니다.

---

## 3. 컨트롤러 및 서비스 로직 구현

이제 폼 요청을 받아 실제로 게시물을 생성하는 로직을 만듭니다.

#### 1) 게시물 작성 페이지를 보여주는 컨트롤러 메서드

`com.example.instaclone` 아래에 `controller` 패키지를 만들고 `PostController.java`를 생성합니다.

```java
package com.example.instaclone.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class PostController {

    @GetMapping("/posts/new")
    public String newPostForm() {
        return "posts/post-form";
    }
}
```

#### 2) 게시물 생성 요청을 처리하는 컨트롤러 및 서비스

`com.example.instaclone` 아래에 `service` 패키지를 만들고 `PostService.java`를 생성한 후, `PostController`를 다음과 같이 수정합니다.

**`PostService.java`**
```java
package com.example.instaclone.service;

import com.example.instaclone.domain.Post;
import com.example.instaclone.domain.dto.PostCreateRequest;
import com.example.instaclone.repository.PostRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.util.UUID;

@Service
@RequiredArgsConstructor
public class PostService {

    private final PostRepository postRepository;

    @Value("${file.upload-dir}")
    private String uploadDir;

    public void create(PostCreateRequest request) throws IOException {
        // 1. 파일 저장
        MultipartFile imageFile = request.imageFile();
        String originalFilename = imageFile.getOriginalFilename();
        String savedFilename = UUID.randomUUID() + "_" + originalFilename;
        File dest = new File(uploadDir + savedFilename);
        imageFile.transferTo(dest);

        // 2. DB에 Post 정보 저장
        String imageUrl = "/images/" + savedFilename;
        Post post = new Post(request.content(), imageUrl);
        postRepository.save(post);
    }
}
```

**`PostController.java` (수정)**
```java
// ... imports ...
@Controller
@RequiredArgsConstructor
public class PostController {

    private final PostService postService;

    @GetMapping("/posts/new")
    public String newPostForm() {
        return "posts/post-form";
    }

    @PostMapping("/posts")
    public String createPost(PostCreateRequest request) throws IOException {
        postService.create(request);
        return "redirect:/"; // 게시물 작성 후 메인 페이지로 리다이렉트
    }
}
```

- **`@RequiredArgsConstructor`**: `final` 키워드가 붙은 필드를 인자로 받는 생성자를 자동으로 만들어주는 Lombok 어노테이션입니다. 이를 통해 의존성 주입(DI)이 이루어집니다.
- **`PostService`**: 실제 비즈니스 로직(파일 저장, DB 저장)을 수행합니다.
  - `UUID.randomUUID()`: 중복되지 않는 파일명을 만들기 위해 사용합니다.
  - `imageFile.transferTo(dest)`: 업로드된 파일을 실제 경로에 저장합니다.
  - `new Post(...)`: Post 엔티티를 생성합니다. (이를 위해 Post 엔티티에 content와 imageUrl을 받는 생성자를 추가해야 합니다.)
- **`@PostMapping("/posts")`**: HTTP POST 메서드로 `/posts` 요청이 들어올 때 `createPost` 메서드를 실행합니다.
- **`return "redirect:/"`**: 요청 처리가 끝난 후, 클라이언트에게 루트 경로(`/`)로 다시 이동하라는 응답을 보냅니다.

---

## 4. Django와 비교 (View와 Form)

- **`PostController`**는 Django의 **`views.py`**와 역할이 같습니다. HTTP 요청을 받아 어떤 로직을 수행하고 어떤 응답을 보낼지 결정합니다.
- **`PostService`**는 복잡한 비즈니스 로직을 `views.py`에서 분리하는 **서비스 계층(Service Layer)** 패턴에 해당합니다. Django에서도 복잡한 뷰는 별도의 함수나 클래스로 로직을 분리하는 것이 좋습니다.
- **`PostCreateRequest` DTO**는 Django의 **`forms.py`**와 유사한 역할을 합니다. 클라이언트로부터 받은 데이터의 유효성을 검증하고, 특정 형식의 데이터를 담는 역할을 수행합니다.
