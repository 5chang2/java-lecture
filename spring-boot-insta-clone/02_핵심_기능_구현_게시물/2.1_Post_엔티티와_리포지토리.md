# 2.1. Post 엔티티와 리포지토리

데이터베이스 설정을 마쳤으니, 이제 게시물 데이터를 표현하는 객체인 **엔티티(Entity)**와, 이 엔티티를 데이터베이스에 저장하고 조회하는 **리포지토리(Repository)**를 만들 차례입니다.

---

## 1. JPA 엔티티(Entity)란?

JPA 엔티티는 데이터베이스의 테이블에 대응하는 자바 클래스입니다. 이 클래스의 필드는 테이블의 컬럼에 매핑됩니다. `@Entity` 어노테이션을 클래스에 붙이면 JPA가 해당 클래스를 관리하기 시작합니다.

`com.example.instaclone` 패키지 아래에 `domain`이라는 새 패키지를 만들고, 그 안에 `Post.java` 클래스를 생성합니다.

```java
package com.example.instaclone.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;

@Entity
@Getter
@NoArgsConstructor
public class Post {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(columnDefinition = "TEXT", nullable = false)
    private String content; // 글 내용

    @Column(nullable = false)
    private String imageUrl; // 이미지 저장 경로

    @CreationTimestamp
    private LocalDateTime createdAt; // 작성 시간
}
```

- **`@Entity`**: 이 클래스가 JPA 엔티티임을 나타냅니다.
- **`@Getter`**: Lombok 어노테이션으로, 모든 필드의 getter 메서드를 자동으로 생성합니다.
- **`@NoArgsConstructor`**: JPA는 엔티티를 생성할 때 기본 생성자를 필요로 하므로 추가합니다.
- **`@Id`**: 이 필드가 테이블의 Primary Key(기본 키)임을 나타냅니다.
- **`@GeneratedValue(strategy = GenerationType.IDENTITY)`**: 기본 키 생성을 데이터베이스에 위임합니다(예: MySQL의 AUTO_INCREMENT).
- **`@Column`**: 필드와 테이블의 컬럼을 매핑합니다. `columnDefinition="TEXT"`는 `content` 필드를 `TEXT` 타입으로 지정하며, `nullable=false`는 `NOT NULL` 제약조건을 의미합니다.
- **`@CreationTimestamp`**: 엔티티가 생성될 때의 시간이 자동으로 저장됩니다.

---

## 2. Spring Data JPA 리포지토리(Repository)란?

리포지토리는 엔티티에 의해 생성된 데이터베이스 레코드에 접근하는 방법을 제공하는 인터페이스입니다. Spring Data JPA는 `JpaRepository` 인터페이스를 상속받기만 하면, 기본적인 CRUD(Create, Read, Update, Delete) 메서드를 자동으로 생성해 줍니다.

`com.example.instaclone` 패키지 아래에 `repository`라는 새 패키지를 만들고, 그 안에 `PostRepository.java` 인터페이스를 생성합니다.

```java
package com.example.instaclone.repository;

import com.example.instaclone.domain.Post;
import org.springframework.data.jpa.repository.JpaRepository;

public interface PostRepository extends JpaRepository<Post, Long> {
}
```

- `JpaRepository<Post, Long>`: `<엔티티 클래스, PK의 타입>`을 지정합니다.
- 이제 `PostRepository`는 `save()`, `findById()`, `findAll()`, `delete()` 등 수많은 메서드를 기본적으로 사용할 수 있게 되었습니다.

---

## 3. 실행 및 테이블 생성 확인

이제 애플리케이션을 실행해 보세요. `application.properties`에 설정한 `spring.jpa.hibernate.ddl-auto=update` 옵션 덕분에, Spring Boot는 `Post` 엔티티를 보고 MySQL 데이터베이스에 자동으로 `post` 테이블을 생성합니다.

데이터베이스 클라이언트에서 `insta_clone` 스키마를 확인해보면 `id`, `content`, `image_url`, `created_at` 컬럼을 가진 `post` 테이블이 생성된 것을 볼 수 있습니다.

---

## 4. Django와 비교 (`models.py`와 ORM)

JPA 엔티티와 리포지토리는 Django의 모델과 ORM(Manager)에 정확히 대응됩니다.

**Django의 `models.py`**
```python
from django.db import models

class Post(models.Model):
    content = models.TextField()
    image = models.ImageField(upload_to='images/')
    created_at = models.DateTimeField(auto_now_add=True)
```

- **`Post.java`의 `@Entity` 클래스**는 Django의 **`Post` 모델 클래스**와 같습니다.
- `@Id`, `@Column` 등의 어노테이션은 Django 모델 필드(`TextField`, `ImageField`)의 옵션과 같은 역할을 합니다.
- **`PostRepository` 인터페이스**는 Django에서 `Post.objects`와 같이 데이터베이스에 쿼리를 보내는 **모델 매니저(Model Manager)**와 동일한 역할을 수행합니다.

Spring Boot에서는 `Entity`로 데이터 구조를 정의하고, `Repository`로 데이터에 접근하는 패턴을 사용합니다.
