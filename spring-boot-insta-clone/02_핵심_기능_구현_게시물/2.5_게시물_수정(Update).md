# 2.5. 게시물 수정(Update)

이번 챕터에서는 이미 작성된 게시물의 내용을 수정하는 기능을 구현합니다. 수정 기능은 보통 '수정 폼 보여주기'와 '실제 수정 처리' 두 단계로 나뉩니다. 여기서는 JPA의 강력한 기능인 **Dirty Checking(변경 감지)**에 대해서도 자연스럽게 배우게 됩니다.

*참고: 이번 튜토리얼에서는 게시물의 글 내용(content)만 수정하는 것으로 범위를 한정합니다. 이미지 자체를 교체하는 것은 더 복잡한 로직이 필요합니다.*

---

## 1. 수정/삭제 버튼 추가

먼저 `home.html`의 게시물 목록에 '수정'과 '삭제'를 위한 버튼을 추가합니다.

```html
<!-- home.html의 card-body 내부 -->
<div class="card-body">
    <p class="card-text" th:text="${post.content}"></p>
    <p class="card-text"><small class="text-muted" th:text="${post.createdAt}"></small></p>
    <div>
        <a th:href="@{/posts/{id}/edit(id=${post.id})}" class="btn btn-sm btn-outline-primary">수정</a>
        <!-- 삭제 버튼은 다음 챕터에서 form으로 변경 예정 -->
        <a href="#" class="btn btn-sm btn-outline-danger">삭제</a>
    </div>
</div>
```

- `th:href="@{/posts/{id}/edit(id=${post.id})}"`: Thymeleaf의 URL 생성 문법입니다. `/posts/1/edit` 와 같이 동적인 URL을 안전하게 만들어줍니다.

---

## 2. 수정 폼(View) 및 컨트롤러

#### 1) 수정 폼 `post-edit-form.html` 생성

`templates/posts/` 경로에 `post-edit-form.html` 파일을 생성합니다. 이 폼은 `post-form.html`과 매우 유사하지만, 기존 데이터를 보여줘야 한다는 점이 다릅니다.

```html
<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>게시물 수정</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
<div class="container">
    <h1 class="my-4">게시물 수정</h1>
    <form th:action="@{/posts/{id}/update(id=${post.id})}" method="post">
        <div class="mb-3">
            <label for="content" class="form-label">내용</label>
            <textarea class="form-control" id="content" name="content" rows="3" th:text="${post.content}" required></textarea>
        </div>
        <div class="mb-3">
            <label class="form-label">현재 이미지</label><br>
            <img th:src="${post.imageUrl}" alt="Post Image" style="max-width: 300px;">
        </div>
        <button type="submit" class="btn btn-primary">수정 완료</button>
    </form>
</div>
</body>
</html>
```

- `th:action` : 수정 요청을 보낼 URL을 동적으로 생성합니다.
- `th:text="${post.content}"`: `<textarea>` 안에 기존 게시물 내용을 채워넣습니다.

#### 2) `PostController`에 수정 폼을 보여주는 메서드 추가

```java
// PostController.java

// ... imports ...

@GetMapping("/posts/{postId}/edit")
public String editPostForm(@PathVariable Long postId, Model model) {
    PostResponse post = postService.findById(postId); // ID로 게시물을 찾는 서비스 메서드 필요
    model.addAttribute("post", post);
    return "posts/post-edit-form";
}
```

- `@PathVariable Long postId`: URL 경로의 `{postId}` 부분을 메서드의 파라미터로 받습니다.

---

## 3. 수정 처리 로직 (Service)

#### 1) `PostService`에 `findById`, `update` 메서드 추가

```java
// PostService.java

// ... imports ...
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class PostService {
    // ...

    @Transactional(readOnly = true)
    public PostResponse findById(Long postId) {
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new IllegalArgumentException("해당 게시물을 찾을 수 없습니다."));
        return PostResponse.from(post);
    }

    @Transactional
    public void update(Long postId, String content) {
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new IllegalArgumentException("해당 게시물을 찾을 수 없습니다.
"));
        post.changeContent(content); // 엔티티의 내용만 변경
    }
}
```

- **`@Transactional`**: 이 어노테이션이 붙은 메서드는 하나의 트랜잭션으로 묶입니다. 메서드가 성공적으로 끝나면 변경 사항이 DB에 커밋(commit)되고, 예외가 발생하면 롤백(rollback)됩니다.
- **Dirty Checking (변경 감지)**: `@Transactional`이 붙은 메서드 안에서 JPA가 관리하는 엔티티(e.g., `postRepository.findById()`로 가져온 `post` 객체)의 상태를 변경하면, 트랜잭션이 끝나는 시점에 JPA가 변경을 감지하여 **자동으로 UPDATE 쿼리를 실행**합니다. 즉, `postRepository.save()`를 호출할 필요가 없습니다.
- `post.changeContent(content)`: 엔티티의 상태를 변경하기 위한 메서드입니다. `Post` 엔티티에 이 메서드를 추가해야 합니다.

#### 2) `Post` 엔티티에 `changeContent` 메서드 추가

```java
// Post.java

@Entity
// ...
public class Post {
    // ... 필드 ...

    //== 생성자 ==//
    public Post(String content, String imageUrl) {
        this.content = content;
        this.imageUrl = imageUrl;
    }

    //== 비즈니스 로직 ==//
    public void changeContent(String content) {
        this.content = content;
    }
}
```

#### 3) `PostController`에 수정 처리 메서드 추가

```java
// PostController.java

// ... imports ...

@PostMapping("/posts/{postId}/update")
public String updatePost(@PathVariable Long postId, @RequestParam String content) {
    postService.update(postId, content);
    return "redirect:/";
}
```

- `@RequestParam String content`: 폼 데이터 중 `name="content"`인 값을 `content` 파라미터로 받습니다.

---

## 4. Django와 비교

- JPA의 **Dirty Checking**은 Django ORM과 가장 큰 차이점 중 하나입니다. Django에서는 모델 객체의 필드를 변경한 후, 반드시 **`post.save()`**를 명시적으로 호출해야 UPDATE 쿼리가 실행됩니다.
  ```python
  # Django views.py
  def post_update(request, post_id):
      post = Post.objects.get(id=post_id)
      post.content = request.POST.get('content')
      post.save() # 명시적으로 save() 호출 필요
      return redirect('/')
  ```
- Spring에서는 `@Transactional` 환경 하에서 엔티티의 상태 변경만으로 UPDATE가 자동으로 일어나는 점이 매우 편리하고 객체지향적입니다.
