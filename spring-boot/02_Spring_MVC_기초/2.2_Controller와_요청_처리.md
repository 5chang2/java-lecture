# 2.2 Controller와 요청 처리

> **학습 목표**
> - @Controller 애너테이션의 역할을 이해합니다
> - 다양한 HTTP 요청 매핑 방법을 활용할 수 있습니다
> - 요청 파라미터를 받는 여러 방법을 이해합니다
> - Model을 사용하여 View에 데이터를 전달할 수 있습니다
> - Redirect와 Forward의 차이를 구분할 수 있습니다

---

## 1. Controller 기본

### 1.1 @Controller 애너테이션

**역할**:
- 이 클래스가 **Controller** 역할임을 Spring에게 알림
- **Component Scan** 대상이 됨 (자동으로 Bean 등록)
- **요청을 처리**하는 메서드들을 포함

**기본 구조**:
```java
package com.example.demo.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller  // ← Controller 선언
public class HomeController {

    @GetMapping("/")  // ← URL 매핑
    public String home() {
        return "index";  // ← View 이름 반환
    }
}
```

### 1.2 Plain Java Servlet과 비교

**Plain Java (Servlet)**:
```java
@WebServlet("/home")
public class HomeServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request,
                         HttpServletResponse response)
            throws ServletException, IOException {

        // View로 포워딩
        RequestDispatcher dispatcher =
            request.getRequestDispatcher("/WEB-INF/views/index.jsp");
        dispatcher.forward(request, response);
    }
}
```

**Spring MVC**:
```java
@Controller
public class HomeController {

    @GetMapping("/home")
    public String home() {
        return "index";  // 훨씬 간결!
    }
}
```

---

## 2. HTTP 요청 매핑

### 2.1 @GetMapping

**GET 요청**을 처리합니다.

```java
@Controller
public class ProductController {

    // URL: /products
    @GetMapping("/products")
    public String listProducts() {
        return "product/list";
    }

    // URL: /products/1
    @GetMapping("/products/{id}")
    public String getProduct(@PathVariable Long id) {
        return "product/detail";
    }
}
```

**사용 시기**:
- 데이터 조회
- 페이지 표시
- 검색

### 2.2 @PostMapping

**POST 요청**을 처리합니다.

```java
@Controller
public class ProductController {

    // 상품 등록 폼 (GET)
    @GetMapping("/products/new")
    public String newProductForm() {
        return "product/form";
    }

    // 상품 등록 처리 (POST)
    @PostMapping("/products")
    public String createProduct(@RequestParam String name,
                                 @RequestParam int price) {
        // 상품 저장 로직
        return "redirect:/products";
    }
}
```

**사용 시기**:
- 데이터 생성
- 폼 제출
- 파일 업로드

### 2.3 기타 HTTP 메서드

```java
@Controller
@RequestMapping("/products")
public class ProductController {

    // GET /products (목록)
    @GetMapping
    public String list() {
        return "product/list";
    }

    // POST /products (생성)
    @PostMapping
    public String create() {
        return "redirect:/products";
    }

    // PUT /products/1 (수정 - 전체)
    @PutMapping("/{id}")
    public String update(@PathVariable Long id) {
        return "redirect:/products";
    }

    // PATCH /products/1 (수정 - 일부)
    @PatchMapping("/{id}")
    public String partialUpdate(@PathVariable Long id) {
        return "redirect:/products";
    }

    // DELETE /products/1 (삭제)
    @DeleteMapping("/{id}")
    public String delete(@PathVariable Long id) {
        return "redirect:/products";
    }
}
```

| 메서드 | 용도 | 멱등성 |
|--------|------|--------|
| GET | 조회 | O |
| POST | 생성 | X |
| PUT | 전체 수정 | O |
| PATCH | 일부 수정 | X |
| DELETE | 삭제 | O |

### 2.4 @RequestMapping (통합)

모든 HTTP 메서드를 하나로 처리할 수 있습니다.

```java
@Controller
public class UserController {

    // 모든 메서드 허용
    @RequestMapping("/users")
    public String users() {
        return "user/list";
    }

    // GET, POST만 허용
    @RequestMapping(value = "/users/new", method = {RequestMethod.GET, RequestMethod.POST})
    public String newUser() {
        return "user/form";
    }
}
```

**권장**: 명시적인 `@GetMapping`, `@PostMapping` 사용

---

## 3. 요청 파라미터 받기

### 3.1 @RequestParam

**쿼리 스트링** 또는 **폼 데이터**를 받습니다.

```java
@Controller
public class SearchController {

    // URL: /search?keyword=Spring&page=1
    @GetMapping("/search")
    public String search(@RequestParam String keyword,
                         @RequestParam int page,
                         Model model) {

        model.addAttribute("keyword", keyword);
        model.addAttribute("page", page);

        return "search/result";
    }
}
```

**Plain Java와 비교**:
```java
// Servlet
String keyword = request.getParameter("keyword");
int page = Integer.parseInt(request.getParameter("page"));

// Spring MVC
@RequestParam String keyword,
@RequestParam int page
```

자동으로 타입 변환! ✨

### 3.2 @RequestParam 옵션

**1. 필수 여부**:
```java
@GetMapping("/search")
public String search(
    @RequestParam String keyword,              // 필수 (기본값)
    @RequestParam(required = false) String category  // 선택
) {
    // category가 없으면 null
}
```

**2. 기본값**:
```java
@GetMapping("/search")
public String search(
    @RequestParam String keyword,
    @RequestParam(defaultValue = "1") int page  // 기본값 1
) {
    // page 파라미터가 없으면 자동으로 1
}
```

**3. 이름 다르게**:
```java
@GetMapping("/search")
public String search(
    @RequestParam("q") String keyword  // URL: ?q=Spring
) {
    // 파라미터 이름은 'q', 변수명은 keyword
}
```

### 3.3 @PathVariable

**URL 경로**에서 값을 추출합니다.

```java
@Controller
public class UserController {

    // URL: /users/123
    @GetMapping("/users/{id}")
    public String getUser(@PathVariable Long id, Model model) {
        model.addAttribute("userId", id);
        return "user/detail";
    }

    // URL: /posts/2024/05/10
    @GetMapping("/posts/{year}/{month}/{day}")
    public String getPostsByDate(
        @PathVariable int year,
        @PathVariable int month,
        @PathVariable int day,
        Model model
    ) {
        model.addAttribute("date", year + "-" + month + "-" + day);
        return "post/list";
    }
}
```

**RESTful URL 설계**:
```
/users/123          (O)  ← 깔끔
/users?id=123       (△)  ← 쿼리 스트링
```

### 3.4 @RequestParam vs @PathVariable

| 구분 | @RequestParam | @PathVariable |
|------|---------------|---------------|
| 위치 | 쿼리 스트링 | URL 경로 |
| 예시 | `/search?q=Spring` | `/users/123` |
| 용도 | 검색, 필터, 페이징 | 리소스 식별 |
| 필수 | 선택 가능 | 필수 (기본) |

**조합 사용**:
```java
// URL: /users/123?include=posts
@GetMapping("/users/{id}")
public String getUser(
    @PathVariable Long id,
    @RequestParam(required = false) String include
) {
    // id는 경로에서, include는 쿼리에서
}
```

### 3.5 객체로 한 번에 받기 (커맨드 객체)

**폼 데이터를 객체로 바인딩**:

```java
// DTO 클래스
public class UserForm {
    private String username;
    private String email;
    private int age;

    // Getter, Setter 필수!
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }
}

// Controller
@Controller
public class UserController {

    @PostMapping("/users")
    public String createUser(UserForm form) {
        // form.getUsername(), form.getEmail(), form.getAge() 자동 바인딩!
        System.out.println("이름: " + form.getUsername());
        System.out.println("이메일: " + form.getEmail());
        System.out.println("나이: " + form.getAge());

        return "redirect:/users";
    }
}
```

**HTML 폼**:
```html
<form action="/users" method="post">
    <input type="text" name="username" />
    <input type="email" name="email" />
    <input type="number" name="age" />
    <button type="submit">등록</button>
</form>
```

**자동 바인딩 규칙**:
- HTML input의 `name` 속성 = DTO 필드명
- Setter 메서드 필수
- 타입 자동 변환

### 3.6 Django MTV 패턴과 비교

Django를 사용해본 경험이 있다면, Spring MVC와 많은 유사점을 발견할 수 있습니다.

#### Django views.py vs Spring Boot Controller

**Django (Python)**:
```python
from django.shortcuts import render

def profile(request, username):
    context = {
        'username': username,
    }
    return render(request, 'profile.html', context)

def cube(request, number):
    result = number ** 3
    context = {
        'number': number,
        'result': result,
    }
    return render(request, 'cube.html', context)
```

**Spring Boot (Java)**:
```java
@Controller
public class ExampleController {

    @GetMapping("/profile/{username}")
    public String profile(@PathVariable String username, Model model) {
        model.addAttribute("username", username);
        return "profile";
    }

    @GetMapping("/cube/{number}")
    public String cube(@PathVariable int number, Model model) {
        int result = (int) Math.pow(number, 3);
        model.addAttribute("number", number);
        model.addAttribute("result", result);
        return "cube";
    }
}
```

**주요 차이점**:

| Django | Spring Boot |
|--------|-------------|
| `def profile(request, username)` | `@GetMapping("/profile/{username}")` |
| URL 패턴은 urls.py에 정의 | URL 패턴을 메서드에 직접 정의 |
| `context = {'key': value}` | `model.addAttribute("key", value)` |
| `render(request, 'template.html', context)` | `return "template"` + Model |

#### 쿼리 파라미터 처리 비교

**Django**:
```python
def pong(request):
    title = request.GET.get('title')
    content = request.GET.get('content')

    context = {
        'title': title,
        'content': content,
    }
    return render(request, 'pong.html', context)
```

**Spring Boot**:
```java
@Controller
public class PingPongController {

    @GetMapping("/pong")
    public String pong(@RequestParam String title,
                       @RequestParam String content,
                       Model model) {
        model.addAttribute("title", title);
        model.addAttribute("content", content);
        return "pong";
    }
}
```

**Spring Boot의 장점**:
- 파라미터 타입을 자동으로 변환 (문자열 → 숫자 등)
- `@RequestParam(required = false)`, `defaultValue` 등 다양한 옵션
- 컴파일 타임에 타입 체크 가능

---

## 4. Model 사용하기

### 4.1 Model이란?

**Controller에서 View로 데이터를 전달**하는 객체입니다.

```java
@Controller
public class ProductController {

    @GetMapping("/products/{id}")
    public String getProduct(@PathVariable Long id, Model model) {
        // 1. 데이터 조회
        Product product = new Product(id, "노트북", 1000000);

        // 2. Model에 데이터 추가
        model.addAttribute("product", product);
        model.addAttribute("message", "상품 상세 페이지입니다.");

        // 3. View 이름 반환
        return "product/detail";
    }
}
```

### 4.2 Model에 데이터 추가

**addAttribute() 메서드**:
```java
model.addAttribute("키", 값);
```

**예시**:
```java
@GetMapping("/dashboard")
public String dashboard(Model model) {
    model.addAttribute("username", "홍길동");
    model.addAttribute("point", 1000);
    model.addAttribute("level", "Gold");

    List<String> messages = Arrays.asList("메시지1", "메시지2");
    model.addAttribute("messages", messages);

    return "dashboard";
}
```

### 4.3 View에서 Model 데이터 사용

**Thymeleaf 템플릿**:
```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head><title>대시보드</title></head>
<body>
    <h1 th:text="${username}">사용자명</h1>
    <p>포인트: <span th:text="${point}">0</span></p>
    <p>등급: <span th:text="${level}">-</span></p>

    <ul>
        <li th:each="msg : ${messages}" th:text="${msg}"></li>
    </ul>
</body>
</html>
```

### 4.4 ModelAndView (선택)

Model과 View를 함께 반환하는 방법:

```java
@GetMapping("/products/{id}")
public ModelAndView getProduct(@PathVariable Long id) {
    ModelAndView mav = new ModelAndView();

    Product product = new Product(id, "노트북", 1000000);

    mav.addObject("product", product);
    mav.setViewName("product/detail");

    return mav;
}
```

**권장**: 간결성을 위해 `Model` 파라미터 방식 사용

---

## 5. Redirect vs Forward

### 5.1 Redirect

**새로운 요청**을 생성하여 다른 URL로 이동합니다.

```java
@PostMapping("/users")
public String createUser(UserForm form) {
    // 사용자 저장 로직
    userService.save(form);

    // /users 로 리다이렉트 (새로운 GET 요청)
    return "redirect:/users";
}
```

**동작 흐름**:
```
1. POST /users (폼 제출)
2. Controller 처리
3. 브라우저에게 "GET /users로 다시 요청하세요" 응답 (302)
4. 브라우저가 GET /users 요청
5. 목록 페이지 표시
```

**특징**:
- URL이 변경됨 (/users → /users)
- 새로운 요청이므로 Model 데이터 전달 안 됨
- **PRG 패턴** (Post-Redirect-Get)에 사용

### 5.2 Forward

**같은 요청** 내에서 다른 View로 이동합니다.

```java
@GetMapping("/old-url")
public String oldPage() {
    // 내부적으로 new-url로 포워딩
    return "forward:/new-url";
}

@GetMapping("/new-url")
public String newPage() {
    return "newPage";
}
```

**동작 흐름**:
```
1. GET /old-url 요청
2. 서버 내부에서 /new-url로 포워딩
3. URL은 /old-url로 유지
4. newPage.html 응답
```

**특징**:
- URL이 변경되지 않음
- 같은 요청이므로 Model 데이터 유지
- **서버 내부**에서만 이동

### 5.3 비교표

| 구분 | Redirect | Forward |
|------|----------|---------|
| 방식 | 새로운 요청 | 같은 요청 내 이동 |
| URL 변경 | O | X |
| Model 유지 | X | O |
| 용도 | POST 후 목록 이동 | 내부 페이지 이동 |
| HTTP 상태 | 302 | - |

### 5.4 PRG (Post-Redirect-Get) 패턴

**문제 상황**:
```java
// 잘못된 예
@PostMapping("/users")
public String createUser(UserForm form, Model model) {
    userService.save(form);
    model.addAttribute("users", userService.findAll());
    return "user/list";  // 바로 View 반환
}
```

```
POST /users → 사용자 등록
브라우저가 새로고침 (F5) → POST /users 다시 실행!
→ 중복 등록 발생! 😱
```

**올바른 예 (PRG 패턴)**:
```java
@PostMapping("/users")
public String createUser(UserForm form) {
    userService.save(form);
    return "redirect:/users";  // GET으로 리다이렉트
}

@GetMapping("/users")
public String listUsers(Model model) {
    model.addAttribute("users", userService.findAll());
    return "user/list";
}
```

```
POST /users → 사용자 등록
리다이렉트 → GET /users
브라우저가 새로고침 (F5) → GET /users 다시 실행
→ 목록만 다시 조회, 중복 등록 없음 ✅
```

---

## 6. 실전 예제: 게시판

### 6.1 Model (Post.java)

```java
public class Post {
    private Long id;
    private String title;
    private String content;
    private String author;
    private LocalDateTime createdAt;

    public Post(Long id, String title, String content, String author) {
        this.id = id;
        this.title = title;
        this.content = content;
        this.author = author;
        this.createdAt = LocalDateTime.now();
    }

    // Getter, Setter
}
```

### 6.2 Controller

```java
@Controller
@RequestMapping("/posts")
public class PostController {

    // 임시 저장소
    private List<Post> posts = new ArrayList<>();
    private Long nextId = 1L;

    // 1. 목록 조회
    @GetMapping
    public String list(Model model) {
        model.addAttribute("posts", posts);
        return "post/list";
    }

    // 2. 상세 조회
    @GetMapping("/{id}")
    public String detail(@PathVariable Long id, Model model) {
        Post post = posts.stream()
            .filter(p -> p.getId().equals(id))
            .findFirst()
            .orElse(null);

        if (post == null) {
            return "redirect:/posts";
        }

        model.addAttribute("post", post);
        return "post/detail";
    }

    // 3. 작성 폼
    @GetMapping("/new")
    public String newForm() {
        return "post/form";
    }

    // 4. 작성 처리
    @PostMapping
    public String create(@RequestParam String title,
                         @RequestParam String content,
                         @RequestParam String author) {
        Post post = new Post(nextId++, title, content, author);
        posts.add(post);

        return "redirect:/posts";  // PRG 패턴
    }

    // 5. 삭제
    @PostMapping("/{id}/delete")
    public String delete(@PathVariable Long id) {
        posts.removeIf(p -> p.getId().equals(id));
        return "redirect:/posts";
    }
}
```

### 6.3 View

**목록 (list.html)**:
```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head><title>게시판</title></head>
<body>
    <h1>게시판</h1>
    <a href="/posts/new">글쓰기</a>

    <table>
        <tr>
            <th>번호</th>
            <th>제목</th>
            <th>작성자</th>
            <th>작성일</th>
        </tr>
        <tr th:each="post : ${posts}">
            <td th:text="${post.id}">1</td>
            <td>
                <a th:href="@{/posts/{id}(id=${post.id})}"
                   th:text="${post.title}">제목</a>
            </td>
            <td th:text="${post.author}">작성자</td>
            <td th:text="${post.createdAt}">작성일</td>
        </tr>
    </table>
</body>
</html>
```

**작성 폼 (form.html)**:
```html
<!DOCTYPE html>
<html>
<head><title>글쓰기</title></head>
<body>
    <h1>글쓰기</h1>
    <form action="/posts" method="post">
        <input type="text" name="title" placeholder="제목" required />
        <textarea name="content" placeholder="내용" required></textarea>
        <input type="text" name="author" placeholder="작성자" required />
        <button type="submit">작성</button>
    </form>
</body>
</html>
```

---

## 실습 문제

### 문제 1: 계산기 폼

**요구사항**:
- `/calculator` (GET): 계산기 폼 표시
- `/calculator` (POST): 계산 결과 표시

**폼**:
```html
<form action="/calculator" method="post">
    <input type="number" name="num1" />
    <select name="operator">
        <option value="+">+</option>
        <option value="-">-</option>
        <option value="*">*</option>
        <option value="/">/</option>
    </select>
    <input type="number" name="num2" />
    <button type="submit">계산</button>
</form>
```

<details>
<summary>답안 보기</summary>

```java
@Controller
public class CalculatorController {

    @GetMapping("/calculator")
    public String form() {
        return "calculator/form";
    }

    @PostMapping("/calculator")
    public String calculate(@RequestParam int num1,
                            @RequestParam String operator,
                            @RequestParam int num2,
                            Model model) {
        int result = 0;

        switch (operator) {
            case "+": result = num1 + num2; break;
            case "-": result = num1 - num2; break;
            case "*": result = num1 * num2; break;
            case "/": result = num1 / num2; break;
        }

        model.addAttribute("num1", num1);
        model.addAttribute("operator", operator);
        model.addAttribute("num2", num2);
        model.addAttribute("result", result);

        return "calculator/result";
    }
}
```

</details>

---

## 정리

### 핵심 요약

1. **@Controller**: Controller 클래스 선언
2. **요청 매핑**:
   - @GetMapping, @PostMapping 등
   - @RequestMapping (통합)
3. **파라미터 받기**:
   - @RequestParam (쿼리 스트링, 폼)
   - @PathVariable (URL 경로)
   - 객체 바인딩 (커맨드 객체)
4. **Model**: View에 데이터 전달
5. **Redirect vs Forward**:
   - Redirect: 새 요청, URL 변경
   - Forward: 같은 요청, URL 유지
6. **PRG 패턴**: POST → Redirect → GET

### 다음 단계

다음 섹션에서는 Thymeleaf 템플릿 엔진을 깊이 있게 다룹니다!

---

## 강사 가이드

### 강의 진행 팁

**1. 단계적 실습**
- 먼저 @RequestParam으로 간단하게
- 점진적으로 복잡한 폼 처리
- 마지막에 게시판 예제

**2. 네트워크 탭 활용**
- 브라우저 개발자 도구 열기
- Redirect 시 302 응답 확인
- POST → GET 흐름 시각적으로 보여주기

**3. 실수 경험**
- Setter 없으면 객체 바인딩 안 됨
- PRG 패턴 안 쓰면 중복 등록
- 직접 경험하게 하기

### 예상 질문과 답변

**Q: @RequestParam 없이 파라미터 받을 수 있나요?**
A: 네, 파라미터명과 메서드 파라미터명이 같으면 생략 가능합니다. 하지만 명시적으로 쓰는 게 좋습니다.

**Q: Redirect 시 데이터를 전달하려면?**
A: RedirectAttributes를 사용합니다. Flash Attribute로 일회성 데이터 전달 가능합니다. (나중에 배움)

**Q: 왜 GET으로 삭제하면 안 되나요?**
A: GET은 멱등성이 있어야 하고, 크롤러가 링크를 클릭할 수 있어 의도치 않은 삭제가 발생할 수 있습니다.

---

**[이전: 2.1 MVC 패턴 이해](./2.1_MVC_패턴_이해.md)** | **[다음: 2.3 Thymeleaf 템플릿 엔진](./2.3_Thymeleaf_템플릿_엔진.md)**
