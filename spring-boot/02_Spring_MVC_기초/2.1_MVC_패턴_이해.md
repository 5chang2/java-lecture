# 2.1 MVC 패턴 이해

> **학습 목표**
> - MVC 패턴이 무엇이고 왜 필요한지 이해합니다
> - Model, View, Controller의 역할을 구분할 수 있습니다
> - Plain Java 방식과 Spring MVC를 비교할 수 있습니다
> - Spring MVC의 요청 처리 흐름을 이해합니다

---

## 1. MVC 패턴이란?

### 1.1 개념

**MVC (Model-View-Controller)**는 애플리케이션을 **세 가지 역할**로 분리하는 디자인 패턴입니다.

```
사용자 요청
    ↓
Controller (컨트롤러) ─── 요청 받고 처리 로직 호출
    ↓
Model (모델) ─────────── 데이터 처리 및 비즈니스 로직
    ↓
View (뷰) ───────────── 화면 렌더링
    ↓
사용자에게 응답 (HTML)
```

### 1.2 각 요소의 역할

| 요소 | 역할 | 예시 |
|------|------|------|
| **Model** | 데이터와 비즈니스 로직 | User 객체, 데이터베이스 조회 |
| **View** | 사용자에게 보여질 화면 | HTML, Thymeleaf 템플릿 |
| **Controller** | 요청 처리 및 흐름 제어 | UserController |

---

## 2. 왜 MVC 패턴이 필요한가?

### 2.1 MVC를 사용하지 않은 경우 (안티 패턴)

**Plain Java (JSP/Servlet) - 모든 코드가 섞여 있음**:

```jsp
<%@ page contentType="text/html;charset=UTF-8" %>
<%
    // 비즈니스 로직 (Model 역할)
    String name = request.getParameter("name");
    int age = Integer.parseInt(request.getParameter("age"));

    // 데이터 처리
    if (age < 0 || age > 150) {
        age = 0;
    }

    // 데이터베이스 접근
    Connection conn = DriverManager.getConnection("jdbc:mysql://...");
    PreparedStatement ps = conn.prepareStatement("SELECT * FROM users WHERE name = ?");
    ps.setString(1, name);
    ResultSet rs = ps.executeQuery();
%>
<!-- HTML (View 역할) -->
<html>
<head><title>사용자 정보</title></head>
<body>
    <h1>사용자 정보</h1>
    <%
        // 또 다시 로직과 HTML이 섞임
        if (rs.next()) {
            out.println("<p>이름: " + rs.getString("name") + "</p>");
            out.println("<p>나이: " + rs.getInt("age") + "</p>");
        } else {
            out.println("<p>사용자를 찾을 수 없습니다.</p>");
        }
        rs.close();
        ps.close();
        conn.close();
    %>
</body>
</html>
```

**문제점**:
- ❌ Java 코드와 HTML이 뒤섞임
- ❌ 유지보수 어려움 (어디가 로직이고 어디가 화면인지 구분 안 됨)
- ❌ 재사용 불가능
- ❌ 테스트 어려움
- ❌ 디자이너와 개발자의 협업 어려움

### 2.2 MVC 패턴 적용 후

**Model (User.java)**:
```java
public class User {
    private String name;
    private int age;

    // 생성자, Getter, Setter
}
```

**Controller (UserController.java)**:
```java
@Controller
public class UserController {

    @GetMapping("/user")
    public String getUser(@RequestParam String name,
                          @RequestParam int age,
                          Model model) {
        // 비즈니스 로직
        if (age < 0 || age > 150) {
            age = 0;
        }

        User user = new User(name, age);
        model.addAttribute("user", user);

        return "user";  // View 이름
    }
}
```

**View (user.html - Thymeleaf)**:
```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>사용자 정보</title>
</head>
<body>
    <h1>사용자 정보</h1>
    <p>이름: <span th:text="${user.name}"></span></p>
    <p>나이: <span th:text="${user.age}"></span></p>
</body>
</html>
```

**장점**:
- ✅ 역할이 명확하게 분리됨
- ✅ 유지보수 용이 (각 파일의 책임이 분명)
- ✅ 재사용 가능 (User 모델을 다른 곳에서도 사용)
- ✅ 테스트 용이 (Controller만 따로 테스트 가능)
- ✅ 협업 용이 (디자이너는 HTML만, 개발자는 Java만)

---

## 3. MVC 각 요소 상세 설명

### 3.1 Model (모델)

**역할**:
- 애플리케이션의 **데이터**를 표현
- **비즈니스 로직** 처리
- 데이터베이스와 상호작용

**예시**:
```java
// 데이터 객체 (DTO, Entity)
public class Product {
    private Long id;
    private String name;
    private int price;

    // 비즈니스 로직
    public int getDiscountedPrice(int discountRate) {
        return price * (100 - discountRate) / 100;
    }
}

// Service (비즈니스 로직)
@Service
public class ProductService {
    public Product findProduct(Long id) {
        // 데이터베이스에서 조회
        return productRepository.findById(id);
    }
}
```

**특징**:
- View나 Controller에 의존하지 않음
- 순수한 Java 객체 (POJO)
- 재사용 가능

### 3.2 View (뷰)

**역할**:
- 사용자에게 **화면**을 보여줌
- Model의 데이터를 **시각화**
- 사용자 입력 받음 (폼)

**예시**:
```html
<!-- Thymeleaf 템플릿 -->
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>상품 상세</title>
</head>
<body>
    <h1 th:text="${product.name}">상품명</h1>
    <p>가격: <span th:text="${product.price}">0</span>원</p>
    <p>할인가: <span th:text="${product.getDiscountedPrice(10)}">0</span>원</p>
</body>
</html>
```

**특징**:
- 로직이 거의 없음 (단순 표시만)
- Model의 데이터를 받아서 렌더링
- HTML, CSS, JavaScript 사용

### 3.3 Controller (컨트롤러)

**역할**:
- 사용자의 **요청**을 받음
- **Model**을 호출하여 데이터 처리
- 처리 결과를 **View**에 전달
- 흐름 제어

**예시**:
```java
@Controller
public class ProductController {

    @Autowired
    private ProductService productService;

    @GetMapping("/product/{id}")
    public String getProduct(@PathVariable Long id, Model model) {
        // 1. Model 호출 (데이터 조회)
        Product product = productService.findProduct(id);

        // 2. View에 데이터 전달
        model.addAttribute("product", product);

        // 3. View 이름 반환
        return "product-detail";  // product-detail.html
    }
}
```

**특징**:
- Model과 View를 연결하는 다리 역할
- 요청 URL과 매핑
- 얇게 유지 (비즈니스 로직은 Service에)

---

## 4. Spring MVC 동작 흐름

### 4.1 전체 흐름도

```
1. 사용자가 브라우저에서 요청
   http://localhost:8080/product/1
        ↓
2. DispatcherServlet이 요청 받음
   (Spring의 프론트 컨트롤러)
        ↓
3. HandlerMapping이 적절한 Controller 찾음
   → ProductController.getProduct()
        ↓
4. Controller가 Model 호출 (Service → Repository)
   → productService.findProduct(1)
        ↓
5. Controller가 Model에 데이터 추가
   → model.addAttribute("product", product)
        ↓
6. Controller가 View 이름 반환
   → "product-detail"
        ↓
7. ViewResolver가 실제 View 파일 찾음
   → templates/product-detail.html
        ↓
8. View가 Model 데이터로 HTML 렌더링
   → Thymeleaf가 ${product.name} 등을 실제 값으로 치환
        ↓
9. HTML을 사용자에게 응답
```

### 4.2 코드로 보는 흐름

**1. 사용자 요청**:
```
GET http://localhost:8080/product/1
```

**2. Controller 실행**:
```java
@Controller
public class ProductController {

    @GetMapping("/product/{id}")
    public String getProduct(@PathVariable Long id, Model model) {
        // 3. Service 호출
        Product product = productService.findProduct(id);

        // 4. Model에 데이터 추가
        model.addAttribute("product", product);

        // 5. View 이름 반환
        return "product-detail";
    }
}
```

**3. Service 실행** (생략 - 나중에 배움):
```java
@Service
public class ProductService {
    public Product findProduct(Long id) {
        // 데이터베이스에서 조회
        return new Product(1L, "노트북", 1000000);
    }
}
```

**4. View 렌더링**:
```html
<!-- templates/product-detail.html -->
<h1 th:text="${product.name}">상품명</h1>
<!-- 결과: <h1>노트북</h1> -->
```

**5. 사용자에게 응답**:
```html
<!DOCTYPE html>
<html>
<head><title>상품 상세</title></head>
<body>
    <h1>노트북</h1>
    <p>가격: 1000000원</p>
</body>
</html>
```

---

## 5. Plain Java vs Spring MVC 비교

### 5.1 Plain Java (Servlet/JSP)

**Servlet (Controller 역할)**:
```java
@WebServlet("/product")
public class ProductServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request,
                         HttpServletResponse response)
            throws ServletException, IOException {

        // 파라미터 추출 (수동)
        String idStr = request.getParameter("id");
        Long id = Long.parseLong(idStr);

        // 비즈니스 로직 (직접 처리)
        Product product = new Product(id, "노트북", 1000000);

        // Model에 데이터 추가 (수동)
        request.setAttribute("product", product);

        // View로 포워딩 (수동)
        RequestDispatcher dispatcher =
            request.getRequestDispatcher("/WEB-INF/views/product.jsp");
        dispatcher.forward(request, response);
    }
}
```

**JSP (View 역할)**:
```jsp
<%@ page contentType="text/html;charset=UTF-8" %>
<html>
<head><title>상품 상세</title></head>
<body>
    <h1>${product.name}</h1>
    <p>가격: ${product.price}원</p>
</body>
</html>
```

**문제점**:
- web.xml 설정 필요
- 파라미터 변환 수동 처리
- 예외 처리 복잡
- 보일러플레이트 코드 많음

### 5.2 Spring MVC

**Controller**:
```java
@Controller
public class ProductController {

    @GetMapping("/product/{id}")
    public String getProduct(@PathVariable Long id, Model model) {
        Product product = new Product(id, "노트북", 1000000);
        model.addAttribute("product", product);
        return "product-detail";
    }
}
```

**View (Thymeleaf)**:
```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head><title>상품 상세</title></head>
<body>
    <h1 th:text="${product.name}">상품명</h1>
    <p>가격: <span th:text="${product.price}">0</span>원</p>
</body>
</html>
```

**장점**:
- ✅ 설정 최소화 (애너테이션 기반)
- ✅ 자동 타입 변환 (@PathVariable Long id)
- ✅ 간결한 코드
- ✅ 강력한 기능 (Validation, 예외 처리 등)

---

## 6. Spring MVC의 핵심 컴포넌트

### 6.1 DispatcherServlet

**역할**: 모든 요청을 받는 **프론트 컨트롤러**

```
사용자 요청
    ↓
DispatcherServlet (중앙 집중 처리)
    ↓
각 Controller로 분배
```

**특징**:
- Spring Boot가 자동으로 설정
- 개발자가 직접 다룰 일 없음
- 모든 HTTP 요청을 가로챔

### 6.2 HandlerMapping

**역할**: URL과 Controller 메서드를 **매핑**

```java
@GetMapping("/product/{id}")  // ← 이 정보를 저장
public String getProduct(@PathVariable Long id) { ... }
```

요청 `/product/1` → `getProduct()` 메서드 호출

### 6.3 ViewResolver

**역할**: View 이름을 실제 파일 경로로 **변환**

```
"product-detail"
    ↓ (ViewResolver)
/templates/product-detail.html
```

**설정** (application.properties):
```properties
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
```

---

## 7. MVC 패턴의 장점

### 7.1 관심사의 분리 (Separation of Concerns)

```
Model:      데이터와 로직
View:       화면 표시
Controller: 흐름 제어
```

각자의 역할에만 집중 → 코드가 깔끔해짐

### 7.2 유지보수 용이

```
화면 수정: View만 수정
로직 수정: Model/Service만 수정
URL 수정:  Controller만 수정
```

한 곳만 고치면 됨

### 7.3 재사용성

```java
// User 모델을 여러 Controller에서 사용
@Controller
public class UserController {
    public String getUser(Model model) {
        User user = new User("홍길동", 25);
        model.addAttribute("user", user);
        return "user-detail";
    }
}

@Controller
public class AdminController {
    public String getUserList(Model model) {
        List<User> users = Arrays.asList(
            new User("홍길동", 25),
            new User("김철수", 30)
        );
        model.addAttribute("users", users);
        return "user-list";
    }
}
```

### 7.4 테스트 용이

```java
// Controller 단위 테스트
@Test
void testGetProduct() {
    ProductController controller = new ProductController();
    Model model = new ConcurrentModel();

    String viewName = controller.getProduct(1L, model);

    assertEquals("product-detail", viewName);
    assertTrue(model.containsAttribute("product"));
}
```

---

## 8. 실전 예제: 간단한 방명록

### 8.1 Model

```java
public class GuestbookEntry {
    private String name;
    private String message;
    private LocalDateTime createdAt;

    public GuestbookEntry(String name, String message) {
        this.name = name;
        this.message = message;
        this.createdAt = LocalDateTime.now();
    }

    // Getter
    public String getName() { return name; }
    public String getMessage() { return message; }
    public LocalDateTime getCreatedAt() { return createdAt; }
}
```

### 8.2 Controller

```java
@Controller
public class GuestbookController {

    // 임시 저장소 (나중에 DB로 대체)
    private List<GuestbookEntry> entries = new ArrayList<>();

    // 목록 보기
    @GetMapping("/guestbook")
    public String list(Model model) {
        model.addAttribute("entries", entries);
        return "guestbook/list";
    }

    // 작성 폼
    @GetMapping("/guestbook/write")
    public String writeForm() {
        return "guestbook/write";
    }

    // 작성 처리
    @PostMapping("/guestbook/write")
    public String write(@RequestParam String name,
                        @RequestParam String message) {
        entries.add(new GuestbookEntry(name, message));
        return "redirect:/guestbook";  // 목록으로 리다이렉트
    }
}
```

### 8.3 View

**목록 (list.html)**:
```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head><title>방명록</title></head>
<body>
    <h1>방명록</h1>
    <a href="/guestbook/write">글쓰기</a>

    <div th:each="entry : ${entries}">
        <h3 th:text="${entry.name}">작성자</h3>
        <p th:text="${entry.message}">메시지</p>
        <small th:text="${entry.createdAt}">작성일</small>
        <hr/>
    </div>
</body>
</html>
```

**작성 폼 (write.html)**:
```html
<!DOCTYPE html>
<html>
<head><title>방명록 작성</title></head>
<body>
    <h1>방명록 작성</h1>
    <form action="/guestbook/write" method="post">
        <input type="text" name="name" placeholder="이름" required/>
        <textarea name="message" placeholder="메시지" required></textarea>
        <button type="submit">작성</button>
    </form>
</body>
</html>
```

---

## 정리

### 핵심 요약

1. **MVC 패턴**
   - Model: 데이터 + 비즈니스 로직
   - View: 화면 렌더링
   - Controller: 요청 처리 + 흐름 제어

2. **장점**
   - 관심사의 분리
   - 유지보수 용이
   - 재사용성 향상
   - 테스트 용이

3. **Spring MVC**
   - DispatcherServlet: 프론트 컨트롤러
   - HandlerMapping: URL → Controller 매핑
   - ViewResolver: View 이름 → 파일 경로

4. **Plain Java와 비교**
   - 설정 최소화
   - 자동 변환
   - 간결한 코드

### 다음 단계

다음 섹션에서는 Controller를 더 깊이 있게 다루며, 다양한 요청 처리 방법을 배웁니다.

---

## 강사 가이드

### 강의 진행 팁

**1. 시각 자료 활용**
- MVC 흐름도를 화이트보드에 그리며 설명
- 각 요소가 어떻게 연결되는지 화살표로 표시

**2. 비유 사용**
- Restaurant 비유:
  - Model = 주방 (요리, 재료)
  - View = 테이블 (손님에게 음식 제공)
  - Controller = 웨이터 (주문 받고 전달)

**3. 실습 중심**
- JSP 예제를 먼저 보여주고 불편함 체험
- 같은 기능을 Spring MVC로 구현하며 차이 강조

**4. 단계적 설명**
- MVC 개념 → 각 요소 역할 → 전체 흐름 → 실제 코드

### 예상 질문과 답변

**Q: Model과 DTO의 차이는?**
A: 넓은 의미에서 Model은 데이터를 담는 모든 객체를 의미합니다. DTO(Data Transfer Object)는 계층 간 데이터 전송용 객체로, Model의 한 종류입니다.

**Q: Controller에 비즈니스 로직을 넣으면 안 되나요?**
A: 가능하지만 권장하지 않습니다. Controller는 얇게 유지하고, 비즈니스 로직은 Service 계층에 두는 게 좋습니다. (3-tier 아키텍처)

**Q: @Controller와 @RestController의 차이는?**
A: `@Controller`는 View를 반환하고, `@RestController`는 데이터(JSON)를 반환합니다. 다음 챕터에서 자세히 다룹니다.

**Q: Thymeleaf 말고 JSP를 써도 되나요?**
A: 가능하지만 Spring Boot에서는 Thymeleaf를 권장합니다. JSP는 JAR 패키징 시 문제가 있고, 템플릿 엔진이 더 현대적입니다.

---

**[이전: 1.3 첫 번째 프로젝트 생성](../01_Spring_Boot_소개_및_환경_설정/1.3_첫_번째_프로젝트_생성.md)** | **[다음: 2.2 Controller와 요청 처리](./2.2_Controller와_요청_처리.md)**
