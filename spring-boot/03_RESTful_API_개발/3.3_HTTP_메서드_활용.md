# 3.3 HTTP 메서드 활용

> **학습 목표**
> - HTTP 메서드별 용도와 특성을 이해합니다
> - CRUD에 적절한 HTTP 메서드를 선택할 수 있습니다
> - 멱등성과 안전성 개념을 이해합니다
> - 완전한 CRUD API를 구현할 수 있습니다

---

## 1. HTTP 메서드 개요

### 1.1 CRUD와 HTTP 메서드 매핑

| CRUD | HTTP 메서드 | 예시 |
|------|-------------|------|
| **Create** (생성) | POST | `POST /api/users` |
| **Read** (조회) | GET | `GET /api/users` |
| **Update** (수정) | PUT, PATCH | `PUT /api/users/123` |
| **Delete** (삭제) | DELETE | `DELETE /api/users/123` |

### 1.2 멱등성 (Idempotent)

**멱등성**: 같은 요청을 여러 번 해도 결과가 동일

| 메서드 | 멱등성 | 설명 |
|--------|--------|------|
| GET | O | 여러 번 조회해도 같은 결과 |
| POST | X | 여러 번 생성하면 여러 개 생성됨 |
| PUT | O | 같은 내용으로 여러 번 수정해도 결과 동일 |
| PATCH | △ | 구현에 따라 다름 |
| DELETE | O | 여러 번 삭제해도 결과 동일 (없어진 상태) |

**예시**:
```
GET /api/users/123     (10번 호출해도 같은 사용자)
POST /api/users        (10번 호출하면 10개 생성)
DELETE /api/users/123  (10번 호출해도 삭제된 상태)
```

### 1.3 안전성 (Safe)

**안전성**: 서버의 상태를 변경하지 않음

| 메서드 | 안전성 | 설명 |
|--------|--------|------|
| GET | O | 조회만 하므로 안전 |
| POST | X | 데이터 생성 (변경) |
| PUT | X | 데이터 수정 (변경) |
| PATCH | X | 데이터 수정 (변경) |
| DELETE | X | 데이터 삭제 (변경) |

**중요**: GET은 서버 상태를 변경하면 안 됨!
```java
// ❌ 잘못된 예
@GetMapping("/api/users/{id}/delete")  // GET으로 삭제 (X)
public String deleteUser(@PathVariable Long id) {
    userService.delete(id);
    return "deleted";
}

// ✅ 올바른 예
@DeleteMapping("/api/users/{id}")  // DELETE로 삭제 (O)
public void deleteUser(@PathVariable Long id) {
    userService.delete(id);
}
```

---

## 2. GET - 조회

### 2.1 목록 조회

```java
@GetMapping("/api/users")
public List<User> list() {
    return userService.findAll();
}
```

**Postman**:
```
GET http://localhost:8080/api/users
```

**응답** (200 OK):
```json
[
  { "id": 1, "name": "홍길동", "email": "hong@example.com" },
  { "id": 2, "name": "김철수", "email": "kim@example.com" }
]
```

### 2.2 단일 조회

```java
@GetMapping("/api/users/{id}")
public ResponseEntity<User> getUser(@PathVariable Long id) {
    User user = userService.findById(id);

    if (user == null) {
        return ResponseEntity.notFound().build();  // 404
    }

    return ResponseEntity.ok(user);  // 200
}
```

**Postman**:
```
GET http://localhost:8080/api/users/1
```

**응답** (200 OK):
```json
{
  "id": 1,
  "name": "홍길동",
  "email": "hong@example.com"
}
```

**존재하지 않는 경우** (404 Not Found):
```
GET http://localhost:8080/api/users/999
→ 404 Not Found (본문 없음)
```

### 2.3 쿼리 파라미터로 필터링

```java
@GetMapping("/api/users")
public List<User> search(@RequestParam(required = false) String name) {
    if (name == null) {
        return userService.findAll();
    }
    return userService.findByName(name);
}
```

**Postman**:
```
GET http://localhost:8080/api/users?name=홍길동
```

---

## 3. POST - 생성

### 3.1 기본 생성

```java
@PostMapping("/api/users")
@ResponseStatus(HttpStatus.CREATED)  // 201
public User create(@RequestBody User user) {
    return userService.create(user);
}
```

**Postman**:
```
메서드: POST
URL: http://localhost:8080/api/users
Headers: Content-Type: application/json
Body (raw, JSON):
{
  "name": "이영희",
  "email": "lee@example.com",
  "age": 28
}
```

**응답** (201 Created):
```json
{
  "id": 3,
  "name": "이영희",
  "email": "lee@example.com",
  "age": 28
}
```

### 3.2 ResponseEntity로 Location 헤더 추가

```java
@PostMapping("/api/users")
public ResponseEntity<User> create(@RequestBody User user) {
    User created = userService.create(user);

    URI location = ServletUriComponentsBuilder
        .fromCurrentRequest()
        .path("/{id}")
        .buildAndExpand(created.getId())
        .toUri();

    return ResponseEntity.created(location).body(created);
}
```

**응답 헤더**:
```
HTTP/1.1 201 Created
Location: http://localhost:8080/api/users/3
Content-Type: application/json

{
  "id": 3,
  "name": "이영희",
  ...
}
```

---

## 4. PUT - 전체 수정

### 4.1 PUT의 의미

**PUT**: 리소스를 **전체적으로 교체**

```java
@PutMapping("/api/users/{id}")
public ResponseEntity<User> update(@PathVariable Long id,
                                    @RequestBody User user) {
    User existing = userService.findById(id);

    if (existing == null) {
        return ResponseEntity.notFound().build();  // 404
    }

    // 전체 교체
    user.setId(id);
    User updated = userService.update(user);

    return ResponseEntity.ok(updated);  // 200
}
```

**Postman**:
```
메서드: PUT
URL: http://localhost:8080/api/users/1
Headers: Content-Type: application/json
Body:
{
  "name": "홍길동(수정)",
  "email": "hong.new@example.com",
  "age": 26
}
```

**응답** (200 OK):
```json
{
  "id": 1,
  "name": "홍길동(수정)",
  "email": "hong.new@example.com",
  "age": 26
}
```

---

## 5. PATCH - 일부 수정

### 5.1 PATCH의 의미

**PATCH**: 리소스의 **일부만 수정**

```java
@PatchMapping("/api/users/{id}")
public ResponseEntity<User> partialUpdate(@PathVariable Long id,
                                           @RequestBody Map<String, Object> updates) {
    User user = userService.findById(id);

    if (user == null) {
        return ResponseEntity.notFound().build();
    }

    // 제공된 필드만 수정
    if (updates.containsKey("name")) {
        user.setName((String) updates.get("name"));
    }
    if (updates.containsKey("email")) {
        user.setEmail((String) updates.get("email"));
    }
    if (updates.containsKey("age")) {
        user.setAge((Integer) updates.get("age"));
    }

    User updated = userService.update(user);

    return ResponseEntity.ok(updated);
}
```

**Postman**:
```
메서드: PATCH
URL: http://localhost:8080/api/users/1
Headers: Content-Type: application/json
Body:
{
  "email": "new.email@example.com"
}
```

**응답** (200 OK):
```json
{
  "id": 1,
  "name": "홍길동",  // 그대로
  "email": "new.email@example.com",  // 변경됨
  "age": 25  // 그대로
}
```

### 5.2 PUT vs PATCH 비교

**PUT** (전체 교체):
```json
// 요청
{
  "name": "홍길동(수정)",
  "email": "hong@example.com",
  "age": 26
}
// → 모든 필드를 보내야 함. 안 보내면 null 또는 기본값
```

**PATCH** (일부 수정):
```json
// 요청
{
  "email": "new@example.com"
}
// → 바꿀 필드만 보냄. 나머지는 그대로 유지
```

---

## 6. DELETE - 삭제

### 6.1 기본 삭제

```java
@DeleteMapping("/api/users/{id}")
@ResponseStatus(HttpStatus.NO_CONTENT)  // 204
public void delete(@PathVariable Long id) {
    userService.delete(id);
}
```

**Postman**:
```
메서드: DELETE
URL: http://localhost:8080/api/users/1
```

**응답** (204 No Content):
```
(본문 없음)
```

### 6.2 존재 여부 확인 후 삭제

```java
@DeleteMapping("/api/users/{id}")
public ResponseEntity<Void> delete(@PathVariable Long id) {
    boolean deleted = userService.delete(id);

    if (!deleted) {
        return ResponseEntity.notFound().build();  // 404
    }

    return ResponseEntity.noContent().build();  // 204
}
```

---

## 7. 완전한 CRUD API 예시

### 7.1 TodoApiController

```java
@RestController
@RequestMapping("/api/todos")
public class TodoApiController {

    private List<Todo> todos = new ArrayList<>();
    private Long nextId = 1L;

    // CREATE (POST)
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Todo create(@RequestBody Todo todo) {
        todo.setId(nextId++);
        todo.setCompleted(false);
        todo.setCreatedAt(LocalDateTime.now());
        todos.add(todo);
        return todo;
    }

    // READ - 목록 (GET)
    @GetMapping
    public List<Todo> list() {
        return todos;
    }

    // READ - 상세 (GET)
    @GetMapping("/{id}")
    public ResponseEntity<Todo> getTodo(@PathVariable Long id) {
        return todos.stream()
            .filter(t -> t.getId().equals(id))
            .findFirst()
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }

    // UPDATE - 전체 (PUT)
    @PutMapping("/{id}")
    public ResponseEntity<Todo> update(@PathVariable Long id,
                                        @RequestBody Todo todo) {
        for (int i = 0; i < todos.size(); i++) {
            if (todos.get(i).getId().equals(id)) {
                todo.setId(id);
                todos.set(i, todo);
                return ResponseEntity.ok(todo);
            }
        }
        return ResponseEntity.notFound().build();
    }

    // UPDATE - 일부 (PATCH) - 완료 토글
    @PatchMapping("/{id}/toggle")
    public ResponseEntity<Todo> toggleComplete(@PathVariable Long id) {
        return todos.stream()
            .filter(t -> t.getId().equals(id))
            .findFirst()
            .map(t -> {
                t.setCompleted(!t.isCompleted());
                return ResponseEntity.ok(t);
            })
            .orElse(ResponseEntity.notFound().build());
    }

    // DELETE (DELETE)
    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void delete(@PathVariable Long id) {
        todos.removeIf(t -> t.getId().equals(id));
    }
}
```

### 7.2 Postman 테스트 시나리오

**1. TODO 생성**:
```
POST /api/todos
{
  "title": "Spring Boot 공부하기"
}
→ 201 Created
```

**2. 목록 조회**:
```
GET /api/todos
→ 200 OK (생성한 TODO 포함)
```

**3. 상세 조회**:
```
GET /api/todos/1
→ 200 OK
```

**4. 완료 토글**:
```
PATCH /api/todos/1/toggle
→ 200 OK (completed: true)
```

**5. 전체 수정**:
```
PUT /api/todos/1
{
  "title": "Spring Boot 마스터하기",
  "completed": false
}
→ 200 OK
```

**6. 삭제**:
```
DELETE /api/todos/1
→ 204 No Content
```

**7. 삭제 확인**:
```
GET /api/todos/1
→ 404 Not Found
```

---

## 8. HTTP 메서드 선택 가이드

### 8.1 어떤 메서드를 쓸까?

**생성**:
```
POST /api/users
→ 항상 POST
```

**조회**:
```
GET /api/users
GET /api/users/123
→ 항상 GET
```

**수정**:
```
PUT /api/users/123      (전체 교체)
PATCH /api/users/123    (일부 수정)
→ 둘 중 하나 선택 (또는 둘 다 제공)
```

**삭제**:
```
DELETE /api/users/123
→ 항상 DELETE
```

### 8.2 실무 팁

**1. PUT만 사용하는 경우**:
```java
// 간단하게 PUT만 제공
@PutMapping("/api/users/{id}")
public User update(@PathVariable Long id, @RequestBody User user) {
    // null이 아닌 필드만 업데이트 (PATCH처럼 동작)
}
```

**2. PATCH만 사용하는 경우**:
```java
// 명시적으로 PATCH만 제공
@PatchMapping("/api/users/{id}")
public User update(@PathVariable Long id, @RequestBody Map<String, Object> updates) {
    // 제공된 필드만 업데이트
}
```

**3. 둘 다 제공**:
```java
@PutMapping("/api/users/{id}")     // 전체 교체
@PatchMapping("/api/users/{id}")   // 일부 수정
```

**권장**: 간단한 프로젝트는 PUT만 제공, 복잡한 프로젝트는 둘 다 제공

---

## 실습 문제

### 문제: 게시판 API

**요구사항**:
1. Post 모델 (id, title, content, author, createdAt)
2. CRUD API 전체 구현
3. Postman으로 모든 API 테스트

<details>
<summary>답안 보기</summary>

```java
// Post.java
public class Post {
    private Long id;
    private String title;
    private String content;
    private String author;
    private LocalDateTime createdAt;

    // 생성자, Getter, Setter
}

// PostApiController.java
@RestController
@RequestMapping("/api/posts")
public class PostApiController {

    private List<Post> posts = new ArrayList<>();
    private Long nextId = 1L;

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Post create(@RequestBody Post post) {
        post.setId(nextId++);
        post.setCreatedAt(LocalDateTime.now());
        posts.add(post);
        return post;
    }

    @GetMapping
    public List<Post> list() {
        return posts;
    }

    @GetMapping("/{id}")
    public ResponseEntity<Post> getPost(@PathVariable Long id) {
        return posts.stream()
            .filter(p -> p.getId().equals(id))
            .findFirst()
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }

    @PutMapping("/{id}")
    public ResponseEntity<Post> update(@PathVariable Long id,
                                        @RequestBody Post post) {
        for (int i = 0; i < posts.size(); i++) {
            if (posts.get(i).getId().equals(id)) {
                post.setId(id);
                post.setCreatedAt(posts.get(i).getCreatedAt());
                posts.set(i, post);
                return ResponseEntity.ok(post);
            }
        }
        return ResponseEntity.notFound().build();
    }

    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void delete(@PathVariable Long id) {
        posts.removeIf(p -> p.getId().equals(id));
    }
}
```

</details>

---

## 정리

### 핵심 요약

1. **HTTP 메서드**:
   - GET: 조회 (안전, 멱등)
   - POST: 생성 (비안전, 비멱등)
   - PUT: 전체 수정 (비안전, 멱등)
   - PATCH: 일부 수정 (비안전, 조건부 멱등)
   - DELETE: 삭제 (비안전, 멱등)

2. **상태 코드**:
   - 200: OK (성공)
   - 201: Created (생성 성공)
   - 204: No Content (삭제 성공)
   - 404: Not Found (없음)

3. **설계 원칙**:
   - GET은 서버 상태 변경 금지
   - 적절한 HTTP 메서드 사용
   - 일관된 응답 코드

### 다음 단계

다음 섹션에서는 JSON 요청/응답을 더 깊이 다룹니다!

---

## 강사 가이드

### 강의 진행 팁

**1. Postman으로 전부 시연**:
- CRUD 전체를 순서대로 실행
- 학생들이 따라하며 익히도록

**2. 멱등성 체험**:
- DELETE를 여러 번 호출
- 첫 번째: 204, 두 번째부터: 404 (또는 204 유지)

**3. 상태 코드 강조**:
- 200과 201의 차이
- 204는 본문 없음
- 404는 클라이언트 오류

### 예상 질문과 답변

**Q: POST도 멱등하게 만들 수 있나요?**
A: 가능하지만 권장하지 않습니다. POST는 기본적으로 새 리소스 생성이므로 멱등성이 없는 게 자연스럽습니다.

**Q: PUT vs PATCH 중 뭘 써야 하나요?**
A: 프로젝트 규모와 요구사항에 따라 다릅니다. 간단한 프로젝트는 PUT만, 복잡한 프로젝트는 둘 다 제공하는 게 일반적입니다.

**Q: 204 No Content 대신 200 OK를 써도 되나요?**
A: 네, 가능합니다. 하지만 RESTful 관례상 삭제 성공 시 204를 사용하는 게 더 적절합니다.

---

**[이전: 3.2 @RestController와 @RequestMapping](./3.2_RestController와_RequestMapping.md)** | **[다음: 3.4 JSON 요청과 응답](./3.4_JSON_요청과_응답.md)**
