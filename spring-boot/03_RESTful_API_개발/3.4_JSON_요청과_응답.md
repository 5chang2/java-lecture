# 3.4 JSON 요청과 응답

> **학습 목표**
> - JSON과 객체 간 변환 원리를 이해합니다
> - @RequestBody와 @ResponseBody를 활용할 수 있습니다
> - Jackson 애너테이션으로 JSON을 커스터마이징할 수 있습니다
> - DTO 패턴을 적용하여 API 설계를 개선할 수 있습니다
> - 일관된 에러 응답을 처리할 수 있습니다

---

## 1. JSON이란?

### 1.1 JSON (JavaScript Object Notation)

**JSON**은 데이터 교환을 위한 **경량 텍스트 형식**입니다.

**예시**:
```json
{
  "id": 1,
  "name": "홍길동",
  "age": 25,
  "email": "hong@example.com",
  "hobbies": ["독서", "운동"],
  "address": {
    "city": "서울",
    "zipcode": "12345"
  }
}
```

**특징**:
- 사람이 읽기 쉬움
- 기계가 파싱하기 쉬움
- 언어 독립적 (Java, JavaScript, Python 모두 지원)
- REST API의 표준 포맷

### 1.2 Java 객체 ↔ JSON 변환

**Java 객체**:
```java
User user = new User(1L, "홍길동", "hong@example.com", 25);
```

**JSON**:
```json
{
  "id": 1,
  "name": "홍길동",
  "email": "hong@example.com",
  "age": 25
}
```

**변환 과정**:
```
Java 객체 ─(직렬화)→ JSON 문자열
JSON 문자열 ─(역직렬화)→ Java 객체
```

---

## 2. Jackson - JSON 변환 라이브러리

### 2.1 Jackson이란?

- Spring Boot에 **기본 포함**된 JSON 라이브러리
- 자동으로 Java 객체 ↔ JSON 변환
- 별도 설정 불필요

### 2.2 자동 변환 원리

**Controller**:
```java
@RestController
public class UserApiController {

    @GetMapping("/api/users/{id}")
    public User getUser(@PathVariable Long id) {
        return new User(id, "홍길동", "hong@example.com", 25);
        // ↑ User 객체 반환
    }
}
```

**내부 동작**:
```
1. Controller가 User 객체 반환
2. Spring Boot가 @RestController 인식
3. Jackson이 User → JSON 변환
4. HTTP 응답 본문에 JSON 포함
```

**HTTP 응답**:
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": 1,
  "name": "홍길동",
  "email": "hong@example.com",
  "age": 25
}
```

### 2.3 Getter의 중요성

**Jackson은 Getter를 통해 필드 값을 읽습니다.**

```java
public class User {
    private String name;

    // ❌ Getter 없음 → JSON에서 제외
    public User(String name) {
        this.name = name;
    }
}
```

**JSON** (name 필드 없음):
```json
{}
```

```java
public class User {
    private String name;

    public User(String name) {
        this.name = name;
    }

    // ✅ Getter 있음 → JSON에 포함
    public String getName() {
        return name;
    }
}
```

**JSON**:
```json
{
  "name": "홍길동"
}
```

---

## 3. @RequestBody - JSON 요청 받기

### 3.1 기본 사용법

**Controller**:
```java
@PostMapping("/api/users")
public User create(@RequestBody User user) {
    // JSON이 자동으로 User 객체로 변환됨
    System.out.println("이름: " + user.getName());
    System.out.println("이메일: " + user.getEmail());

    return user;
}
```

**Postman**:
```
POST http://localhost:8080/api/users
Headers: Content-Type: application/json
Body (raw, JSON):
{
  "name": "홍길동",
  "email": "hong@example.com",
  "age": 25
}
```

**내부 동작**:
```
1. 클라이언트가 JSON 전송
2. Jackson이 JSON → User 객체 변환
3. @RequestBody가 User 파라미터에 주입
4. Controller 메서드 실행
```

### 3.2 Setter의 중요성

**Jackson은 Setter를 통해 값을 설정합니다.**

```java
public class User {
    private String name;

    // ✅ Setter 필요
    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
```

**Setter 없으면?** → 해당 필드가 null

---

## 4. Jackson 애너테이션

### 4.1 @JsonProperty - 필드명 변경

**Java 필드명 ≠ JSON 키 이름**:

```java
public class User {
    @JsonProperty("user_id")  // JSON: user_id
    private Long id;          // Java: id

    @JsonProperty("user_name")  // JSON: user_name
    private String name;        // Java: name

    // Getter, Setter
}
```

**JSON** (요청/응답):
```json
{
  "user_id": 1,
  "user_name": "홍길동"
}
```

### 4.2 @JsonIgnore - 필드 제외

**민감한 정보를 JSON에서 제외**:

```java
public class User {
    private Long id;
    private String name;

    @JsonIgnore  // JSON에서 제외
    private String password;

    // Getter, Setter
}
```

**JSON** (password 없음):
```json
{
  "id": 1,
  "name": "홍길동"
}
```

### 4.3 @JsonIgnoreProperties - 여러 필드 제외

**클래스 레벨**에서 여러 필드 제외:

```java
@JsonIgnoreProperties({"password", "ssn"})
public class User {
    private Long id;
    private String name;
    private String password;
    private String ssn;  // 주민번호

    // Getter, Setter
}
```

### 4.4 @JsonFormat - 날짜 포맷

```java
public class Post {
    private Long id;
    private String title;

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime createdAt;

    // Getter, Setter
}
```

**JSON**:
```json
{
  "id": 1,
  "title": "제목",
  "createdAt": "2024-01-15 10:30:00"
}
```

### 4.5 @JsonInclude - null 값 제외

```java
@JsonInclude(JsonInclude.Include.NON_NULL)
public class User {
    private Long id;
    private String name;
    private String email;  // null일 수 있음

    // Getter, Setter
}
```

**email이 null일 때**:
```json
{
  "id": 1,
  "name": "홍길동"
}
```

---

## 5. DTO 패턴

### 5.1 DTO란?

**DTO (Data Transfer Object)**: 계층 간 데이터 전송용 객체

**문제 상황**:
```java
@Entity
public class User {
    private Long id;
    private String name;
    private String email;
    private String password;  // 비밀번호를 응답에 포함하면 안 됨!

    // Getter, Setter
}

@RestController
public class UserApiController {

    @GetMapping("/api/users/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
        // password가 JSON에 노출됨! 😱
    }
}
```

**해결책: DTO 사용**:

```java
// DTO (응답용)
public class UserResponse {
    private Long id;
    private String name;
    private String email;
    // password 없음!

    public UserResponse(User user) {
        this.id = user.getId();
        this.name = user.getName();
        this.email = user.getEmail();
    }

    // Getter
}

// Controller
@RestController
public class UserApiController {

    @GetMapping("/api/users/{id}")
    public UserResponse getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        return new UserResponse(user);  // DTO로 변환
    }
}
```

### 5.2 요청/응답 DTO 분리

**CreateUserRequest** (생성 요청):
```java
public class CreateUserRequest {
    private String name;
    private String email;
    private String password;

    // Getter, Setter
}
```

**UserResponse** (응답):
```java
public class UserResponse {
    private Long id;
    private String name;
    private String email;
    // password 없음

    // Getter
}
```

**Controller**:
```java
@PostMapping("/api/users")
public UserResponse create(@RequestBody CreateUserRequest request) {
    User user = new User();
    user.setName(request.getName());
    user.setEmail(request.getEmail());
    user.setPassword(request.getPassword());

    User created = userService.create(user);

    return new UserResponse(created);
}
```

---

## 6. 에러 응답 처리

### 6.1 기본 에러 응답

**에러 발생 시**:
```
GET http://localhost:8080/api/users/999
```

**Spring Boot 기본 에러 응답**:
```json
{
  "timestamp": "2024-01-15T10:30:00.000+00:00",
  "status": 404,
  "error": "Not Found",
  "path": "/api/users/999"
}
```

### 6.2 커스텀 에러 응답

**ErrorResponse** DTO:
```java
public class ErrorResponse {
    private String message;
    private int status;
    private LocalDateTime timestamp;

    public ErrorResponse(String message, int status) {
        this.message = message;
        this.status = status;
        this.timestamp = LocalDateTime.now();
    }

    // Getter
}
```

**Controller**:
```java
@GetMapping("/api/users/{id}")
public ResponseEntity<?> getUser(@PathVariable Long id) {
    User user = userService.findById(id);

    if (user == null) {
        ErrorResponse error = new ErrorResponse(
            "사용자를 찾을 수 없습니다.",
            404
        );
        return ResponseEntity.status(404).body(error);
    }

    return ResponseEntity.ok(new UserResponse(user));
}
```

**에러 응답**:
```json
{
  "message": "사용자를 찾을 수 없습니다.",
  "status": 404,
  "timestamp": "2024-01-15T10:30:00"
}
```

### 6.3 유효성 검증 에러

**Jakarta Validation** (나중에 자세히 배움):
```java
public class CreateUserRequest {

    @NotBlank(message = "이름은 필수입니다.")
    private String name;

    @Email(message = "올바른 이메일 형식이 아닙니다.")
    private String email;

    @Size(min = 8, message = "비밀번호는 최소 8자 이상이어야 합니다.")
    private String password;

    // Getter, Setter
}
```

---

## 7. 실전 예제: 블로그 API

### 7.1 모델 및 DTO

**Post** (Entity):
```java
public class Post {
    private Long id;
    private String title;
    private String content;
    private String author;
    private LocalDateTime createdAt;

    // Getter, Setter
}
```

**CreatePostRequest** (생성 요청):
```java
public class CreatePostRequest {
    private String title;
    private String content;
    private String author;

    // Getter, Setter
}
```

**UpdatePostRequest** (수정 요청):
```java
public class UpdatePostRequest {
    private String title;
    private String content;

    // Getter, Setter
}
```

**PostResponse** (응답):
```java
public class PostResponse {
    private Long id;
    private String title;
    private String content;
    private String author;

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm")
    private LocalDateTime createdAt;

    public PostResponse(Post post) {
        this.id = post.getId();
        this.title = post.getTitle();
        this.content = post.getContent();
        this.author = post.getAuthor();
        this.createdAt = post.getCreatedAt();
    }

    // Getter
}
```

### 7.2 Controller

```java
@RestController
@RequestMapping("/api/posts")
public class PostApiController {

    private List<Post> posts = new ArrayList<>();
    private Long nextId = 1L;

    // 목록 조회
    @GetMapping
    public List<PostResponse> list() {
        return posts.stream()
            .map(PostResponse::new)
            .collect(Collectors.toList());
    }

    // 상세 조회
    @GetMapping("/{id}")
    public ResponseEntity<?> getPost(@PathVariable Long id) {
        return posts.stream()
            .filter(p -> p.getId().equals(id))
            .findFirst()
            .map(post -> ResponseEntity.ok(new PostResponse(post)))
            .orElse(ResponseEntity.status(404)
                .body(new ErrorResponse("게시물을 찾을 수 없습니다.", 404)));
    }

    // 생성
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public PostResponse create(@RequestBody CreatePostRequest request) {
        Post post = new Post();
        post.setId(nextId++);
        post.setTitle(request.getTitle());
        post.setContent(request.getContent());
        post.setAuthor(request.getAuthor());
        post.setCreatedAt(LocalDateTime.now());

        posts.add(post);

        return new PostResponse(post);
    }

    // 수정
    @PutMapping("/{id}")
    public ResponseEntity<?> update(@PathVariable Long id,
                                     @RequestBody UpdatePostRequest request) {
        for (Post post : posts) {
            if (post.getId().equals(id)) {
                post.setTitle(request.getTitle());
                post.setContent(request.getContent());
                return ResponseEntity.ok(new PostResponse(post));
            }
        }
        return ResponseEntity.status(404)
            .body(new ErrorResponse("게시물을 찾을 수 없습니다.", 404));
    }

    // 삭제
    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void delete(@PathVariable Long id) {
        posts.removeIf(p -> p.getId().equals(id));
    }
}
```

### 7.3 Postman 테스트

**1. 게시물 생성**:
```
POST /api/posts
{
  "title": "Spring Boot 배우기",
  "content": "REST API를 만들어보자",
  "author": "홍길동"
}

응답 (201 Created):
{
  "id": 1,
  "title": "Spring Boot 배우기",
  "content": "REST API를 만들어보자",
  "author": "홍길동",
  "createdAt": "2024-01-15 10:30"
}
```

**2. 목록 조회**:
```
GET /api/posts

응답 (200 OK):
[
  {
    "id": 1,
    "title": "Spring Boot 배우기",
    "content": "REST API를 만들어보자",
    "author": "홍길동",
    "createdAt": "2024-01-15 10:30"
  }
]
```

**3. 수정**:
```
PUT /api/posts/1
{
  "title": "Spring Boot 마스터하기",
  "content": "REST API 완성!"
}

응답 (200 OK):
{
  "id": 1,
  "title": "Spring Boot 마스터하기",
  "content": "REST API 완성!",
  "author": "홍길동",
  "createdAt": "2024-01-15 10:30"
}
```

---

## 실습 문제

### 문제: 댓글 API

**요구사항**:
1. Comment 모델 (id, postId, author, content, createdAt)
2. DTO 설계 (CreateCommentRequest, CommentResponse)
3. CRUD API 구현
4. JSON 날짜 포맷팅

<details>
<summary>답안 보기</summary>

```java
// Comment.java
public class Comment {
    private Long id;
    private Long postId;
    private String author;
    private String content;
    private LocalDateTime createdAt;

    // Getter, Setter
}

// CreateCommentRequest.java
public class CreateCommentRequest {
    private Long postId;
    private String author;
    private String content;

    // Getter, Setter
}

// CommentResponse.java
public class CommentResponse {
    private Long id;
    private Long postId;
    private String author;
    private String content;

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm")
    private LocalDateTime createdAt;

    public CommentResponse(Comment comment) {
        this.id = comment.getId();
        this.postId = comment.getPostId();
        this.author = comment.getAuthor();
        this.content = comment.getContent();
        this.createdAt = comment.getCreatedAt();
    }

    // Getter
}

// CommentApiController.java
@RestController
@RequestMapping("/api/comments")
public class CommentApiController {

    private List<Comment> comments = new ArrayList<>();
    private Long nextId = 1L;

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public CommentResponse create(@RequestBody CreateCommentRequest request) {
        Comment comment = new Comment();
        comment.setId(nextId++);
        comment.setPostId(request.getPostId());
        comment.setAuthor(request.getAuthor());
        comment.setContent(request.getContent());
        comment.setCreatedAt(LocalDateTime.now());

        comments.add(comment);

        return new CommentResponse(comment);
    }

    @GetMapping
    public List<CommentResponse> list(@RequestParam(required = false) Long postId) {
        Stream<Comment> stream = comments.stream();

        if (postId != null) {
            stream = stream.filter(c -> c.getPostId().equals(postId));
        }

        return stream
            .map(CommentResponse::new)
            .collect(Collectors.toList());
    }
}
```

</details>

---

## 정리

### 핵심 요약

1. **JSON 변환**:
   - Jackson이 자동 변환
   - Getter (응답), Setter (요청) 필요

2. **@RequestBody**:
   - JSON → Java 객체
   - POST, PUT, PATCH에서 사용

3. **@ResponseBody**:
   - Java 객체 → JSON
   - @RestController에 자동 적용

4. **Jackson 애너테이션**:
   - @JsonProperty: 필드명 변경
   - @JsonIgnore: 필드 제외
   - @JsonFormat: 날짜 포맷

5. **DTO 패턴**:
   - 요청/응답 분리
   - 민감 정보 보호
   - API 명확화

### 다음 단계

축하합니다! 챕터 3을 완료했습니다.

**다음 챕터 (데이터베이스 연동)**에서는:
- Spring Data JPA
- MyBatis
- 실제 데이터베이스 연결

---

## 강사 가이드

### 강의 진행 팁

**1. JSON 변환 시연**:
- Getter 없는 경우 → JSON 확인
- Setter 없는 경우 → null 값 확인
- 학생들이 직접 경험하도록

**2. DTO 필요성 강조**:
- password가 노출되는 상황 시연
- DTO로 해결하는 과정 보여주기

**3. Postman 활용**:
- JSON Body 작성 실습
- 에러 응답 확인

### 예상 질문과 답변

**Q: Lombok을 사용하면 Getter/Setter를 안 써도 되나요?**
A: 네, `@Getter`, `@Setter`로 자동 생성됩니다. 다만 이 강의에서는 명시적으로 작성합니다.

**Q: DTO와 Entity의 차이는?**
A: Entity는 데이터베이스 테이블과 매핑되는 객체, DTO는 계층 간 데이터 전송용 객체입니다. (챕터 4에서 자세히)

**Q: JSON 대신 XML을 쓸 수 있나요?**
A: 가능하지만, REST API는 보통 JSON을 사용합니다. XML은 무겁고 복잡합니다.

---

**[이전: 3.3 HTTP 메서드 활용](./3.3_HTTP_메서드_활용.md)** | **[다음: 챕터 4로 이동](../04_데이터베이스_연동_Part1_JPA/)**
