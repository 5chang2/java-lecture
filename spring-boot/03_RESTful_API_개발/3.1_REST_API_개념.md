# 3.1 REST API 개념

> **학습 목표**
> - REST API가 무엇이고 왜 필요한지 이해합니다
> - 풀스택 방식과 API 서버 방식의 차이를 구분할 수 있습니다
> - REST 아키텍처 원칙을 설명할 수 있습니다
> - RESTful한 API를 설계할 수 있습니다

---

## 1. REST API란?

### 1.1 정의

**REST (Representational State Transfer)**는 웹의 장점을 최대한 활용할 수 있는 **아키텍처 스타일**입니다.

**REST API**는 REST 원칙을 따르는 API(Application Programming Interface)를 의미합니다.

**핵심**:
- HTTP를 기반으로 클라이언트와 서버가 **데이터를 주고받는 방식**
- 주로 **JSON** 형식으로 데이터 전송
- **리소스(자원)** 중심의 설계

### 1.2 간단한 예시

**REST API 요청**:
```http
GET /api/users/123
```

**JSON 응답**:
```json
{
  "id": 123,
  "name": "홍길동",
  "email": "hong@example.com"
}
```

---

## 2. 왜 REST API가 필요한가?

### 2.1 풀스택 vs API 서버

#### 풀스택 방식 (챕터 2에서 배운 방식)

```
브라우저
    ↓ HTTP 요청
Spring Boot (Controller + Thymeleaf)
    ↓
HTML 페이지 응답
    ↓
브라우저에 렌더링
```

**Controller (풀스택)**:
```java
@Controller
public class UserController {
    @GetMapping("/users/{id}")
    public String getUser(@PathVariable Long id, Model model) {
        User user = userService.findById(id);
        model.addAttribute("user", user);
        return "user-detail";  // HTML 페이지
    }
}
```

**장점**:
- ✅ 서버에서 완성된 HTML 제공 (SEO 유리)
- ✅ 간단한 구조

**단점**:
- ❌ 프론트엔드와 백엔드가 결합됨
- ❌ 모바일 앱 대응 어려움
- ❌ 프론트엔드 프레임워크(React, Vue) 사용 어려움

#### API 서버 방식 (이번 챕터)

```
브라우저 / 모바일 앱
    ↓ HTTP 요청
Spring Boot (REST API)
    ↓
JSON 데이터 응답
    ↓
클라이언트가 화면 렌더링
```

**Controller (API 서버)**:
```java
@RestController
public class UserApiController {
    @GetMapping("/api/users/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);  // JSON 자동 변환
    }
}
```

**JSON 응답**:
```json
{
  "id": 123,
  "name": "홍길동",
  "email": "hong@example.com"
}
```

**장점**:
- ✅ 프론트엔드와 백엔드 분리 (독립 개발 가능)
- ✅ 다양한 클라이언트 대응 (웹, 모바일, IoT)
- ✅ 프론트엔드 프레임워크 자유롭게 선택
- ✅ API 재사용 가능

**단점**:
- ❌ 초기 설정 복잡도 증가
- ❌ CORS 등 추가 고려 사항

### 2.2 실제 사례

**Instagram 예시**:
```
Instagram 웹 (React)     ────┐
Instagram 앱 (iOS)       ────┼──> Instagram REST API
Instagram 앱 (Android)   ────┘
```

**하나의 API 서버**로 모든 클라이언트를 지원!

---

## 3. REST 아키텍처 원칙

REST는 6가지 핵심 원칙이 있습니다.

### 3.1 클라이언트-서버 구조 (Client-Server)

**원칙**: 클라이언트와 서버가 **독립적**으로 개발/배포 가능

```
클라이언트                   서버
(React, Vue, Mobile)  ←→  (Spring Boot REST API)
    ↑                         ↑
  UI 관심사                데이터 관심사
```

**장점**:
- 프론트엔드 팀과 백엔드 팀이 독립적으로 작업
- 서버는 데이터만, 클라이언트는 UI만 담당

### 3.2 무상태성 (Stateless)

**원칙**: 서버는 클라이언트의 **상태를 저장하지 않음**

```java
// ❌ 잘못된 예 (상태 저장)
@RestController
public class BadController {
    private User currentUser;  // 서버에 상태 저장 (여러 사용자가 동시 접속 시 문제)

    @GetMapping("/api/user")
    public User getUser() {
        return currentUser;
    }
}

// ✅ 올바른 예 (무상태)
@RestController
public class GoodController {

    @GetMapping("/api/users/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);  // 매번 DB에서 조회
    }
}
```

**장점**:
- 서버 확장 용이 (로드 밸런싱)
- 서버 장애 시 다른 서버로 요청 가능

### 3.3 캐시 가능 (Cacheable)

**원칙**: HTTP의 캐싱 기능을 활용

```java
@GetMapping("/api/products")
public ResponseEntity<List<Product>> getProducts() {
    List<Product> products = productService.findAll();

    return ResponseEntity.ok()
        .cacheControl(CacheControl.maxAge(60, TimeUnit.SECONDS))
        .body(products);
}
```

**장점**:
- 네트워크 비용 감소
- 응답 속도 향상

### 3.4 계층 구조 (Layered System)

**원칙**: 클라이언트는 서버의 **내부 구조를 알 필요 없음**

```
클라이언트
    ↓
API Gateway
    ↓
Load Balancer
    ↓
서버 1, 2, 3...
    ↓
데이터베이스
```

클라이언트는 그냥 `/api/users` 호출, 내부는 몰라도 됨!

### 3.5 인터페이스 일관성 (Uniform Interface)

**원칙**: 일관된 인터페이스 제공

**리소스 식별**:
```
/api/users          (사용자 목록)
/api/users/123      (특정 사용자)
/api/products       (상품 목록)
/api/products/456   (특정 상품)
```

**HTTP 메서드 활용**:
- GET: 조회
- POST: 생성
- PUT: 전체 수정
- PATCH: 일부 수정
- DELETE: 삭제

### 3.6 Code on Demand (선택 사항)

**원칙**: 서버가 클라이언트에 실행 가능한 코드 전송

예: JavaScript 파일 다운로드 후 실행

---

## 4. RESTful API 설계 가이드

### 4.1 리소스 중심 설계

**리소스(Resource)**: API가 다루는 대상

**❌ 잘못된 설계 (동사 사용)**:
```
POST /api/createUser
GET  /api/getUser?id=123
POST /api/deleteUser
```

**✅ 올바른 설계 (명사 + HTTP 메서드)**:
```
POST   /api/users          (사용자 생성)
GET    /api/users/123      (사용자 조회)
DELETE /api/users/123      (사용자 삭제)
```

### 4.2 URI 설계 규칙

**1. 소문자 사용**:
```
✅ /api/users
❌ /api/Users
```

**2. 하이픈(-) 사용, 언더스코어(_) 지양**:
```
✅ /api/product-categories
❌ /api/product_categories
```

**3. 복수형 사용**:
```
✅ /api/users
❌ /api/user
```

**4. 계층 구조 표현**:
```
/api/users/123/posts         (사용자 123의 게시물 목록)
/api/users/123/posts/456     (사용자 123의 게시물 456)
```

### 4.3 HTTP 메서드별 의미

| 메서드 | 의미 | 예시 |
|--------|------|------|
| GET | 조회 (Read) | `GET /api/users` |
| POST | 생성 (Create) | `POST /api/users` |
| PUT | 전체 수정 (Update) | `PUT /api/users/123` |
| PATCH | 일부 수정 (Partial Update) | `PATCH /api/users/123` |
| DELETE | 삭제 (Delete) | `DELETE /api/users/123` |

### 4.4 HTTP 상태 코드

**2xx (성공)**:
- `200 OK`: 성공
- `201 Created`: 생성 성공
- `204 No Content`: 성공, 응답 본문 없음

**4xx (클라이언트 오류)**:
- `400 Bad Request`: 잘못된 요청
- `401 Unauthorized`: 인증 필요
- `403 Forbidden`: 권한 없음
- `404 Not Found`: 리소스 없음

**5xx (서버 오류)**:
- `500 Internal Server Error`: 서버 오류

### 4.5 실전 예시: 게시판 API

**게시물 CRUD**:
```
GET    /api/posts              (목록 조회)
GET    /api/posts/123          (상세 조회)
POST   /api/posts              (생성)
PUT    /api/posts/123          (전체 수정)
PATCH  /api/posts/123          (일부 수정)
DELETE /api/posts/123          (삭제)
```

**댓글 (게시물의 하위 리소스)**:
```
GET    /api/posts/123/comments       (게시물 123의 댓글 목록)
POST   /api/posts/123/comments       (댓글 생성)
DELETE /api/posts/123/comments/456   (댓글 456 삭제)
```

**검색 및 필터링**:
```
GET /api/posts?keyword=Spring        (검색)
GET /api/posts?category=tech         (카테고리 필터)
GET /api/posts?page=2&size=10        (페이징)
```

---

## 5. REST API 예시

### 5.1 사용자 API

**1. 사용자 목록 조회**:
```http
GET /api/users HTTP/1.1
Host: example.com
```

**응답**:
```json
[
  {
    "id": 1,
    "name": "홍길동",
    "email": "hong@example.com"
  },
  {
    "id": 2,
    "name": "김철수",
    "email": "kim@example.com"
  }
]
```

**2. 특정 사용자 조회**:
```http
GET /api/users/1 HTTP/1.1
Host: example.com
```

**응답**:
```json
{
  "id": 1,
  "name": "홍길동",
  "email": "hong@example.com",
  "age": 25
}
```

**3. 사용자 생성**:
```http
POST /api/users HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "이영희",
  "email": "lee@example.com",
  "age": 28
}
```

**응답** (201 Created):
```json
{
  "id": 3,
  "name": "이영희",
  "email": "lee@example.com",
  "age": 28
}
```

**4. 사용자 수정**:
```http
PUT /api/users/3 HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "이영희",
  "email": "lee.new@example.com",
  "age": 29
}
```

**5. 사용자 삭제**:
```http
DELETE /api/users/3 HTTP/1.1
Host: example.com
```

**응답** (204 No Content): 본문 없음

---

## 6. 풀스택 vs API 서버 비교

### 6.1 TODO 앱 비교

#### 풀스택 방식 (챕터 2)

**Controller**:
```java
@Controller
public class TodoController {

    @GetMapping("/todos")
    public String list(Model model) {
        List<Todo> todos = todoService.findAll();
        model.addAttribute("todos", todos);
        return "todo/list";  // HTML 반환
    }
}
```

**응답**: HTML 페이지
```html
<!DOCTYPE html>
<html>
<body>
    <h1>TODO 리스트</h1>
    <ul>
        <li>Spring Boot 공부</li>
        <li>프로젝트 진행</li>
    </ul>
</body>
</html>
```

#### API 서버 방식 (이번 챕터)

**Controller**:
```java
@RestController
public class TodoApiController {

    @GetMapping("/api/todos")
    public List<Todo> list() {
        return todoService.findAll();  // JSON 반환
    }
}
```

**응답**: JSON 데이터
```json
[
  {
    "id": 1,
    "title": "Spring Boot 공부",
    "completed": false
  },
  {
    "id": 2,
    "title": "프로젝트 진행",
    "completed": false
  }
]
```

**프론트엔드 (React 예시)**:
```javascript
// React가 JSON을 받아서 화면 렌더링
fetch('/api/todos')
  .then(res => res.json())
  .then(todos => {
    todos.forEach(todo => {
      console.log(todo.title);
    });
  });
```

### 6.2 언제 어떤 방식을 사용할까?

**풀스택 (Thymeleaf) 사용**:
- 간단한 관리자 페이지
- SEO가 중요한 웹사이트
- 프론트엔드 프레임워크 없이 빠른 개발

**API 서버 사용**:
- 모바일 앱 + 웹 동시 지원
- React, Vue, Angular 등 프론트엔드 프레임워크 사용
- 마이크로서비스 아키텍처
- 제3자에게 API 제공

**Instagram 프로젝트에서는**:
- 챕터 6-8: 풀스택 + API 서버 **둘 다** 구현
- 같은 기능을 두 방식으로 경험

---

## 7. REST API의 장단점

### 7.1 장점

**1. 플랫폼 독립성**:
```
하나의 API → 웹, 모바일, 데스크톱, IoT 모두 사용
```

**2. 확장성**:
```
클라이언트와 서버가 독립적으로 확장 가능
```

**3. 표준화**:
```
HTTP 표준 활용 → 별도 학습 불필요
```

**4. 재사용성**:
```
한 번 만든 API를 여러 곳에서 재사용
```

### 7.2 단점

**1. 오버페칭/언더페칭**:
```
필요한 것보다 많은 데이터 (오버페칭)
필요한 것보다 적은 데이터 (언더페칭)
→ GraphQL로 해결 가능
```

**2. 여러 번의 요청**:
```
사용자 정보 → GET /api/users/123
사용자의 게시물 → GET /api/users/123/posts
→ 두 번 요청 필요
```

**3. 버전 관리**:
```
API 변경 시 하위 호환성 유지 어려움
→ /api/v1/users, /api/v2/users 등으로 버전 관리
```

---

## 정리

### 핵심 요약

1. **REST API**:
   - HTTP 기반 데이터 전송 방식
   - JSON 형식 사용
   - 리소스 중심 설계

2. **REST 원칙**:
   - 클라이언트-서버 구조
   - 무상태성
   - 캐시 가능
   - 계층 구조
   - 인터페이스 일관성

3. **설계 가이드**:
   - 명사 사용 (리소스)
   - HTTP 메서드 활용 (GET, POST, PUT, DELETE)
   - 적절한 상태 코드
   - 복수형, 소문자, 하이픈

4. **풀스택 vs API**:
   - 풀스택: HTML 반환, 간단
   - API: JSON 반환, 확장성

### 다음 단계

다음 섹션에서는 Spring Boot로 실제 REST API를 만들어봅니다!
- @RestController 사용
- JSON 자동 변환
- Postman으로 테스트

---

## 강사 가이드

### 강의 진행 팁

**1. 실제 서비스 예시**:
- Instagram, Twitter API 문서 보여주기
- 학생들이 사용하는 서비스의 API 구조 설명

**2. Postman 미리 설치**:
- 다음 섹션에서 바로 사용하므로 미리 설치 확인
- 간단한 공개 API 호출 시연 (예: JSONPlaceholder)

**3. 비교 학습**:
- 챕터 2의 TODO 앱을 예로 들어 설명
- "HTML 대신 JSON을 반환한다" 강조

**4. 시각 자료**:
- 클라이언트-서버 구조 그림
- 풀스택 vs API 서버 흐름도

### 예상 질문과 답변

**Q: REST와 RESTful의 차이는?**
A: REST는 아키텍처 스타일, RESTful은 REST 원칙을 잘 따르는 API를 의미합니다. "RESTful API"는 "REST 원칙을 잘 지킨 API"입니다.

**Q: GraphQL과의 차이는?**
A: REST는 여러 엔드포인트(/users, /posts), GraphQL은 하나의 엔드포인트로 원하는 데이터를 쿼리합니다. GraphQL은 오버페칭/언더페칭 문제를 해결하지만 학습 곡선이 높습니다.

**Q: PUT과 PATCH의 차이는?**
A: PUT은 리소스 전체를 교체, PATCH는 일부만 수정합니다. 실무에서는 명확히 구분하지 않는 경우도 많습니다.

**Q: API 버전 관리는 어떻게?**
A: URL에 버전 포함(/api/v1/users), HTTP 헤더 사용 등 여러 방법이 있습니다. 가장 간단한 건 URL 방식입니다.

---

**[이전: 2.4 간단한 웹 페이지 만들기](../02_Spring_MVC_기초/2.4_간단한_웹_페이지_만들기.md)** | **[다음: 3.2 @RestController와 @RequestMapping](./3.2_RestController와_RequestMapping.md)**
