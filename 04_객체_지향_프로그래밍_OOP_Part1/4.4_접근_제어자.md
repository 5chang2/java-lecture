# 4.4. 접근 제어자

> 접근 제어자의 종류와 특징을 이해하고, 적절한 접근 제어자를 선택하여 캡슐화를 구현할 수 있다.

## 접근 제어자란?

**접근 제어자(Access Modifier)**는 클래스, 필드, 메서드, 생성자 등에 대한 **접근 범위를 제어**하는 키워드입니다. 이를 통해 정보 은닉(Information Hiding)과 캡슐화(Encapsulation)를 구현할 수 있습니다.

**JavaScript 비교**: JavaScript는 전통적으로 접근 제어자가 없었지만, ES2022부터 private 필드(`#`)를 지원합니다.

```javascript
// JavaScript - private 필드 (ES2022+)
class BankAccount {
    #balance = 0;  // private 필드

    deposit(amount) {
        this.#balance += amount;
    }

    getBalance() {
        return this.#balance;
    }
}

const account = new BankAccount();
// console.log(account.#balance);  // 에러! private 필드는 외부 접근 불가
```

---

## Java의 4가지 접근 제어자

Java는 4가지 접근 제어자를 제공합니다.

| 접근 제어자 | 같은 클래스 | 같은 패키지 | 다른 패키지의 자식 클래스 | 전체 |
|:---|:---:|:---:|:---:|:---:|
| `private` | ✅ | ❌ | ❌ | ❌ |
| `(default)` | ✅ | ✅ | ❌ | ❌ |
| `protected` | ✅ | ✅ | ✅ | ❌ |
| `public` | ✅ | ✅ | ✅ | ✅ |

**제한 범위**: `private` < `(default)` < `protected` < `public`

---

## 1. private - 가장 제한적

`private`은 **같은 클래스 내부**에서만 접근할 수 있습니다.

### 사용 예시

```java
public class BankAccount {
    private int balance;  // private 필드

    // private 메서드
    private boolean isValidAmount(int amount) {
        return amount > 0;
    }

    // public 메서드를 통해서만 접근 가능
    public void deposit(int amount) {
        if (isValidAmount(amount)) {  // 같은 클래스 내부에서는 접근 가능
            this.balance += amount;
        }
    }

    public int getBalance() {
        return this.balance;  // 같은 클래스 내부에서는 접근 가능
    }
}

public class Main {
    public static void main(String[] args) {
        BankAccount account = new BankAccount();

        // account.balance = 1000;  // 에러! private 필드는 외부 접근 불가
        // account.isValidAmount(100);  // 에러! private 메서드는 외부 접근 불가

        account.deposit(1000);  // ✅ public 메서드는 접근 가능
        System.out.println(account.getBalance());  // 1000
    }
}
```

### 언제 사용하나?

- **필드**: 거의 모든 필드는 `private`으로 선언 (캡슐화의 기본)
- **메서드**: 내부 구현 로직, 헬퍼 메서드
- **생성자**: 싱글톤 패턴 등 특별한 경우

**핵심 원칙**: 외부에 공개할 필요가 없다면 `private`!

---

## 2. default (package-private) - 패키지 범위

아무 접근 제어자도 붙이지 않으면 **같은 패키지 내**에서만 접근 가능합니다.

### 사용 예시

```java
// com.myapp.model.User.java
package com.myapp.model;

class User {  // default 접근 제어자 (클래스)
    String name;  // default 접근 제어자 (필드)

    void printInfo() {  // default 접근 제어자 (메서드)
        System.out.println("User: " + name);
    }
}

// com.myapp.model.UserService.java
package com.myapp.model;

public class UserService {
    public void test() {
        User user = new User();  // ✅ 같은 패키지이므로 접근 가능
        user.name = "홍길동";     // ✅ 같은 패키지이므로 접근 가능
        user.printInfo();        // ✅ 같은 패키지이므로 접근 가능
    }
}

// com.myapp.Main.java
package com.myapp;

import com.myapp.model.User;  // 에러! default 클래스는 다른 패키지에서 import 불가

public class Main {
    public static void main(String[] args) {
        // User user = new User();  // 에러! 다른 패키지에서 접근 불가
    }
}
```

### 언제 사용하나?

- 패키지 내부에서만 사용할 **유틸리티 클래스**
- 패키지 내부 구현 **헬퍼 클래스**
- **패키지 수준의 캡슐화**가 필요한 경우

**주의**: default는 키워드가 아닙니다! 아무것도 붙이지 않으면 default입니다.

---

## 3. protected - 상속 관계 포함

`protected`는 **같은 패키지** 또는 **다른 패키지의 자식 클래스**에서 접근 가능합니다.

### 사용 예시

```java
// com.myapp.model.Animal.java
package com.myapp.model;

public class Animal {
    protected String name;  // protected 필드

    protected void sleep() {  // protected 메서드
        System.out.println(name + "이(가) 잠을 잡니다.");
    }
}

// com.myapp.model.Dog.java (같은 패키지)
package com.myapp.model;

public class Dog extends Animal {
    public void bark() {
        System.out.println(name + "이(가) 짖습니다.");  // ✅ 같은 패키지이므로 접근 가능
        sleep();  // ✅ 같은 패키지이므로 접근 가능
    }
}

// com.myapp.service.Cat.java (다른 패키지)
package com.myapp.service;

import com.myapp.model.Animal;

public class Cat extends Animal {
    public void meow() {
        System.out.println(name + "이(가) 야옹합니다.");  // ✅ 자식 클래스이므로 접근 가능
        sleep();  // ✅ 자식 클래스이므로 접근 가능
    }
}

// com.myapp.Main.java
package com.myapp;

import com.myapp.model.Animal;

public class Main {
    public static void main(String[] args) {
        Animal animal = new Animal();
        // animal.name = "동물";  // 에러! protected는 자식 클래스가 아닌 외부에서 접근 불가
        // animal.sleep();       // 에러! protected는 자식 클래스가 아닌 외부에서 접근 불가
    }
}
```

### 언제 사용하나?

- **상속을 위해 설계된** 필드와 메서드
- 자식 클래스에서 **오버라이드 또는 접근**해야 하는 경우
- 상속 계층 내부에서만 사용할 기능

**주의**: `protected`는 같은 패키지에서도 접근 가능하므로, 완전한 캡슐화를 제공하지는 않습니다.

---

## 4. public - 모든 곳에서 접근 가능

`public`은 **어디서든** 접근 가능합니다.

### 사용 예시

```java
// com.myapp.model.User.java
package com.myapp.model;

public class User {  // public 클래스
    private String name;  // private 필드

    public User(String name) {  // public 생성자
        this.name = name;
    }

    public String getName() {  // public 메서드
        return name;
    }

    public void setName(String name) {  // public 메서드
        this.name = name;
    }
}

// com.myapp.Main.java (다른 패키지)
package com.myapp;

import com.myapp.model.User;

public class Main {
    public static void main(String[] args) {
        User user = new User("홍길동");  // ✅ public 생성자 접근 가능
        System.out.println(user.getName());  // ✅ public 메서드 접근 가능
        user.setName("김철수");  // ✅ public 메서드 접근 가능
    }
}
```

### 언제 사용하나?

- **외부에 공개할** 클래스
- **API로 제공할** 메서드
- **외부에서 사용할** 생성자
- **Getter/Setter** 메서드

**원칙**: 꼭 필요한 경우에만 `public`으로 공개!

---

## 클래스의 접근 제어자

클래스에는 `public` 또는 `default`만 사용할 수 있습니다.

### public 클래스

```java
// User.java
public class User {
    // 어디서든 접근 가능
}
```

**규칙**:
- ✅ **하나의 파일에 public 클래스는 하나만** 존재 가능
- ✅ **파일명과 public 클래스명이 일치**해야 함

```java
// User.java
public class User {  // ✅ 파일명과 일치
    // ...
}

class UserHelper {  // ✅ default 클래스는 여러 개 가능
    // ...
}
```

### default 클래스

```java
// Helper.java
class Helper {  // default 접근 제어자
    // 같은 패키지에서만 접근 가능
}
```

**사용 시기**: 패키지 내부에서만 사용할 유틸리티 클래스

---

## 캡슐화 (Encapsulation)

접근 제어자의 주요 목적은 **캡슐화**를 구현하는 것입니다.

### 캡슐화란?

객체의 내부 데이터(필드)를 외부로부터 보호하고, **public 메서드를 통해서만 접근**하도록 하는 것입니다.

### 나쁜 예 (캡슐화 X)

```java
public class BankAccount {
    public int balance;  // public 필드 (위험!)

    public BankAccount(int balance) {
        this.balance = balance;
    }
}

public class Main {
    public static void main(String[] args) {
        BankAccount account = new BankAccount(10000);

        // 외부에서 직접 수정 가능 (위험!)
        account.balance = -5000;  // 음수 잔액이 되어버림!
        account.balance = 1000000000;  // 임의로 잔액 증가!

        System.out.println(account.balance);
    }
}
```

### 좋은 예 (캡슐화 O)

```java
public class BankAccount {
    private int balance;  // private 필드 (보호!)

    public BankAccount(int balance) {
        if (balance < 0) {
            throw new IllegalArgumentException("초기 잔액은 0 이상이어야 합니다.");
        }
        this.balance = balance;
    }

    // public 메서드를 통해서만 접근
    public void deposit(int amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("입금액은 0보다 커야 합니다.");
        }
        this.balance += amount;
    }

    public void withdraw(int amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("출금액은 0보다 커야 합니다.");
        }
        if (this.balance < amount) {
            throw new IllegalArgumentException("잔액이 부족합니다.");
        }
        this.balance -= amount;
    }

    public int getBalance() {
        return this.balance;
    }
}

public class Main {
    public static void main(String[] args) {
        BankAccount account = new BankAccount(10000);

        // account.balance = -5000;  // 에러! private 필드는 직접 접근 불가

        account.deposit(5000);   // ✅ 메서드를 통해서만 변경 가능
        account.withdraw(3000);  // ✅ 유효성 검사 수행

        System.out.println(account.getBalance());  // 12000
    }
}
```

### 캡슐화의 장점

1. **데이터 보호**: 잘못된 값이 할당되는 것을 방지
2. **유효성 검사**: 메서드 내부에서 검증 로직 수행
3. **유지보수 용이**: 내부 구현 변경 시 외부 코드에 영향 없음
4. **정보 은닉**: 불필요한 정보를 외부에 노출하지 않음

**JavaScript 비교**:

```javascript
// JavaScript - Getter/Setter
class BankAccount {
    #balance;  // private 필드

    constructor(balance) {
        if (balance < 0) {
            throw new Error("초기 잔액은 0 이상이어야 합니다.");
        }
        this.#balance = balance;
    }

    deposit(amount) {
        if (amount <= 0) {
            throw new Error("입금액은 0보다 커야 합니다.");
        }
        this.#balance += amount;
    }

    getBalance() {
        return this.#balance;
    }
}
```

---

## Getter와 Setter

캡슐화를 구현하면서 필드에 접근하기 위해 **Getter/Setter** 메서드를 사용합니다.

### Getter

필드의 값을 **읽는(get)** 메서드입니다.

```java
public class Person {
    private String name;
    private int age;

    // Getter
    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}
```

**명명 규칙**: `get` + `필드명` (첫 글자 대문자)

**boolean 타입의 경우**:
```java
private boolean active;

// boolean 타입은 is + 필드명
public boolean isActive() {
    return active;
}
```

### Setter

필드의 값을 **변경하는(set)** 메서드입니다.

```java
public class Person {
    private String name;
    private int age;

    // Setter
    public void setName(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("이름은 비어있을 수 없습니다.");
        }
        this.name = name;
    }

    public void setAge(int age) {
        if (age < 0) {
            throw new IllegalArgumentException("나이는 0 이상이어야 합니다.");
        }
        this.age = age;
    }
}
```

**명명 규칙**: `set` + `필드명` (첫 글자 대문자)

### IntelliJ에서 자동 생성

1. 클래스 내부에서 `Alt + Insert` (Windows) / `Cmd + N` (Mac)
2. `Getter and Setter` 선택
3. 필드 선택 후 `OK`

**주의**: Setter는 항상 필요한 것은 아닙니다!
- 읽기 전용 필드는 Getter만 제공
- 불변 객체는 Setter 제공하지 않음

```java
public class Product {
    private final String id;  // 읽기 전용
    private String name;
    private int price;

    public Product(String id, String name, int price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }

    // id는 변경 불가하므로 Getter만 제공
    public String getId() {
        return id;
    }

    // name과 price는 변경 가능하므로 Getter/Setter 제공
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        if (price < 0) {
            throw new IllegalArgumentException("가격은 0 이상이어야 합니다.");
        }
        this.price = price;
    }
}
```

---

## 실전 예제

### 예제 1: 학생 클래스

```java
public class Student {
    private String name;
    private int age;
    private int score;

    public Student(String name, int age, int score) {
        this.name = name;
        setAge(age);  // Setter를 통해 유효성 검사
        setScore(score);
    }

    // Getter
    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public int getScore() {
        return score;
    }

    // Setter (유효성 검사 포함)
    public void setName(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("이름은 비어있을 수 없습니다.");
        }
        this.name = name;
    }

    public void setAge(int age) {
        if (age < 1 || age > 150) {
            throw new IllegalArgumentException("나이는 1~150 사이여야 합니다.");
        }
        this.age = age;
    }

    public void setScore(int score) {
        if (score < 0 || score > 100) {
            throw new IllegalArgumentException("점수는 0~100 사이여야 합니다.");
        }
        this.score = score;
    }

    // 학점 계산 (내부 로직)
    public String getGrade() {
        if (score >= 90) return "A";
        if (score >= 80) return "B";
        if (score >= 70) return "C";
        if (score >= 60) return "D";
        return "F";
    }
}

public class Main {
    public static void main(String[] args) {
        Student student = new Student("홍길동", 20, 85);

        System.out.println("이름: " + student.getName());
        System.out.println("나이: " + student.getAge());
        System.out.println("점수: " + student.getScore());
        System.out.println("학점: " + student.getGrade());

        // 점수 변경
        student.setScore(95);
        System.out.println("변경된 학점: " + student.getGrade());

        // student.setScore(150);  // 예외 발생!
    }
}
```

### 예제 2: 직사각형 클래스

```java
public class Rectangle {
    private int width;
    private int height;

    public Rectangle(int width, int height) {
        setWidth(width);
        setHeight(height);
    }

    public int getWidth() {
        return width;
    }

    public void setWidth(int width) {
        if (width <= 0) {
            throw new IllegalArgumentException("너비는 0보다 커야 합니다.");
        }
        this.width = width;
    }

    public int getHeight() {
        return height;
    }

    public void setHeight(int height) {
        if (height <= 0) {
            throw new IllegalArgumentException("높이는 0보다 커야 합니다.");
        }
        this.height = height;
    }

    // 읽기 전용 메서드 (계산 결과)
    public int getArea() {
        return width * height;
    }

    public int getPerimeter() {
        return 2 * (width + height);
    }

    public boolean isSquare() {
        return width == height;
    }
}
```

---

## 실습 문제

### 문제 1: 도서 클래스

다음 요구사항을 만족하는 `Book` 클래스를 작성하세요.

**필드** (모두 private):
- `String title` (제목)
- `String author` (저자)
- `int price` (가격)
- `boolean available` (대출 가능 여부)

**요구사항**:
- 모든 필드에 대해 Getter 제공
- 가격은 0 이상이어야 함
- 대출 가능 여부만 Setter 제공
- 책 정보를 출력하는 `printInfo()` 메서드 작성

### 문제 2: 은행 계좌 클래스

다음 요구사항을 만족하는 `Account` 클래스를 작성하세요.

**필드** (모두 private):
- `String accountNumber` (계좌번호, 읽기 전용)
- `String owner` (소유자)
- `int balance` (잔액)

**메서드**:
- `deposit(int amount)`: 입금 (0보다 커야 함)
- `withdraw(int amount)`: 출금 (잔액 부족 시 예외)
- `transfer(Account target, int amount)`: 이체
- `getBalance()`: 잔액 조회

---

## 요약

- **접근 제어자**: 클래스, 필드, 메서드의 접근 범위를 제어
- **4가지 종류**:
  - `private`: 같은 클래스 내부만
  - `default`: 같은 패키지만
  - `protected`: 같은 패키지 + 자식 클래스
  - `public`: 모든 곳
- **캡슐화**: 필드를 `private`으로 보호하고, `public` 메서드로 접근
- **Getter/Setter**: 필드 접근을 위한 메서드
  - Getter: `getFieldName()` (boolean은 `isFieldName()`)
  - Setter: `setFieldName()`
- **원칙**:
  - 필드는 기본적으로 `private`
  - 외부에 공개할 메서드만 `public`
  - 필요한 경우에만 `protected` 또는 `default`
- **장점**:
  - 데이터 보호
  - 유효성 검사
  - 유지보수 용이
  - 정보 은닉

**JavaScript와의 차이점**:
- Java: 4가지 명시적 접근 제어자
- JavaScript: `#` 기호로 private 필드 표현 (ES2022+)
