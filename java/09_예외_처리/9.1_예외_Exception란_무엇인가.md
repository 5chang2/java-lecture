# 9.1. 예외(Exception)란 무엇인가?

## 학습 목표
- 프로그램 오류의 종류를 이해한다
- Error와 Exception의 차이를 구분한다
- JavaScript의 오류 처리와 Java 예외의 차이를 비교한다
- Checked와 Unchecked 예외를 이해한다

---

## 1. 프로그램 오류의 종류

### 1.1. 세 가지 오류 유형

프로그램을 작성하다 보면 다양한 오류를 만나게 됩니다.

**1. 컴파일 에러 (Compile Error)**
- 컴파일 시점에 발생하는 오류
- 문법 오류, 타입 불일치 등
- 컴파일이 실패하여 실행 자체가 불가능

```java
public class Main {
    public static void main(String[] args) {
        int x = "hello";  // ❌ 컴파일 에러: 타입 불일치
        System.out.println(x)  // ❌ 컴파일 에러: 세미콜론 누락
    }
}
```

**2. 런타임 에러 (Runtime Error)**
- 실행 중에 발생하는 오류
- 프로그램이 예기치 않게 종료됨
- Java는 이를 Error와 Exception으로 구분

```java
public class Main {
    public static void main(String[] args) {
        int result = 10 / 0;  // ❌ 런타임 에러: ArithmeticException
        System.out.println(result);
    }
}
```

**3. 논리 에러 (Logic Error)**
- 실행은 되지만 의도와 다르게 동작
- 가장 찾기 어려운 오류

```java
public class Main {
    public static void main(String[] args) {
        // 평균을 구하려고 했지만 잘못 계산
        int sum = 10 + 20 + 30;
        int avg = sum * 3;  // ❌ 논리 에러: 나누기가 아닌 곱하기
        System.out.println("평균: " + avg);  // 180 출력 (잘못된 결과)
    }
}
```

### 1.2. JavaScript와 비교

#### JavaScript
```javascript
// 1. 문법 오류 (파싱 단계에서 발견)
const x = ;  // SyntaxError

// 2. 런타임 오류
const obj = null;
console.log(obj.name);  // TypeError: Cannot read property 'name' of null

// 3. 논리 오류
const sum = 10 + 20 + 30;
const avg = sum * 3;  // 잘못된 계산
console.log(avg);  // 180
```

| 오류 유형 | JavaScript | Java |
|---------|-----------|------|
| 컴파일 에러 | ❌ 없음 (인터프리터) | ✅ 있음 |
| 런타임 에러 | Error 객체 | Error + Exception |
| 논리 에러 | ✅ 있음 | ✅ 있음 |

---

## 2. Error vs Exception

Java는 런타임 오류를 **Error**와 **Exception**으로 구분합니다.

### 2.1. Error (에러)

**복구 불가능한 심각한 오류**

```java
// StackOverflowError 예시
public class Main {
    public static void main(String[] args) {
        recursion();  // 무한 재귀 호출
    }

    static void recursion() {
        recursion();  // 자기 자신을 계속 호출
    }
}
```

**Error 예시:**
- `OutOfMemoryError`: 메모리 부족
- `StackOverflowError`: 스택 메모리 초과
- `VirtualMachineError`: JVM 자체 오류

⚠️ **Error는 try-catch로 처리하지 않습니다** - 복구가 불가능하기 때문입니다.

### 2.2. Exception (예외)

**복구 가능한 비교적 덜 심각한 오류**

```java
public class Main {
    public static void main(String[] args) {
        try {
            int result = 10 / 0;  // ArithmeticException
        } catch (ArithmeticException e) {
            System.out.println("0으로 나눌 수 없습니다.");
            // 프로그램이 계속 실행됨
        }

        System.out.println("프로그램 계속 실행");
    }
}
```

**Exception 예시:**
- `NullPointerException`: null 참조
- `ArrayIndexOutOfBoundsException`: 배열 인덱스 초과
- `NumberFormatException`: 숫자 변환 실패
- `IOException`: 파일 입출력 오류

✅ **Exception은 try-catch로 처리 가능** - 적절히 처리하면 프로그램이 계속 실행됩니다.

### 2.3. 예외 클래스 계층 구조

```
Object
  └─ Throwable
       ├─ Error (복구 불가능)
       │    ├─ OutOfMemoryError
       │    ├─ StackOverflowError
       │    └─ ...
       │
       └─ Exception (복구 가능)
            ├─ IOException (Checked)
            ├─ SQLException (Checked)
            └─ RuntimeException (Unchecked)
                 ├─ NullPointerException
                 ├─ ArithmeticException
                 ├─ ArrayIndexOutOfBoundsException
                 └─ ...
```

---

## 3. 주요 예외 종류

### 3.1. NullPointerException

null 객체의 메서드나 필드에 접근할 때 발생합니다.

```java
public class Main {
    public static void main(String[] args) {
        String str = null;
        System.out.println(str.length());  // ❌ NullPointerException
    }
}
```

**JavaScript 비교:**
```javascript
const str = null;
console.log(str.length);  // TypeError: Cannot read property 'length' of null
```

### 3.2. ArrayIndexOutOfBoundsException

배열의 범위를 벗어난 인덱스에 접근할 때 발생합니다.

```java
public class Main {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};
        System.out.println(numbers[10]);  // ❌ ArrayIndexOutOfBoundsException
    }
}
```

**JavaScript 비교:**
```javascript
const numbers = [1, 2, 3, 4, 5];
console.log(numbers[10]);  // undefined (에러 발생 안함!)
```

### 3.3. ArithmeticException

산술 연산 오류가 발생할 때 나타납니다.

```java
public class Main {
    public static void main(String[] args) {
        int result = 10 / 0;  // ❌ ArithmeticException: / by zero
        System.out.println(result);
    }
}
```

**JavaScript 비교:**
```javascript
const result = 10 / 0;
console.log(result);  // Infinity (에러 발생 안함!)
```

### 3.4. NumberFormatException

문자열을 숫자로 변환할 수 없을 때 발생합니다.

```java
public class Main {
    public static void main(String[] args) {
        String str = "abc";
        int num = Integer.parseInt(str);  // ❌ NumberFormatException
        System.out.println(num);
    }
}
```

**JavaScript 비교:**
```javascript
const str = "abc";
const num = parseInt(str);
console.log(num);  // NaN (에러 발생 안함!)
```

### 3.5. ClassCastException

잘못된 타입 변환 시 발생합니다.

```java
public class Main {
    public static void main(String[] args) {
        Object obj = "Hello";
        Integer num = (Integer) obj;  // ❌ ClassCastException
    }
}
```

---

## 4. Checked vs Unchecked 예외

Java의 예외는 **Checked 예외**와 **Unchecked 예외**로 나뉩니다.

### 4.1. Checked 예외

**컴파일러가 예외 처리를 강제하는 예외**

```java
import java.io.*;

public class Main {
    public static void main(String[] args) {
        // ❌ 컴파일 에러: 예외 처리 필수
        FileReader file = new FileReader("test.txt");
    }
}
```

**해결 방법 1: try-catch**
```java
import java.io.*;

public class Main {
    public static void main(String[] args) {
        try {
            FileReader file = new FileReader("test.txt");  // ✅
        } catch (FileNotFoundException e) {
            System.out.println("파일을 찾을 수 없습니다.");
        }
    }
}
```

**해결 방법 2: throws**
```java
import java.io.*;

public class Main {
    public static void main(String[] args) throws FileNotFoundException {
        FileReader file = new FileReader("test.txt");  // ✅
    }
}
```

**Checked 예외 종류:**
- `IOException`: 입출력 오류
- `FileNotFoundException`: 파일 없음
- `SQLException`: 데이터베이스 오류
- `ClassNotFoundException`: 클래스 로딩 실패

### 4.2. Unchecked 예외

**컴파일러가 예외 처리를 강제하지 않는 예외**

```java
public class Main {
    public static void main(String[] args) {
        // 예외 처리 안 해도 컴파일 성공
        int result = 10 / 0;  // 실행 시 ArithmeticException
    }
}
```

**예외 처리는 선택사항:**
```java
public class Main {
    public static void main(String[] args) {
        // 처리 안 함 (선택)
        int[] numbers = {1, 2, 3};
        System.out.println(numbers[0]);

        // 처리 함 (선택)
        try {
            System.out.println(numbers[10]);
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("인덱스 범위를 벗어났습니다.");
        }
    }
}
```

**Unchecked 예외 종류 (RuntimeException의 하위):**
- `NullPointerException`
- `ArrayIndexOutOfBoundsException`
- `ArithmeticException`
- `NumberFormatException`
- `ClassCastException`

### 4.3. Checked vs Unchecked 비교

| 구분 | Checked | Unchecked |
|------|---------|-----------|
| 상속 | Exception (RuntimeException 제외) | RuntimeException |
| 처리 의무 | **필수** (컴파일 에러) | 선택 |
| 발생 시점 | 외부 환경 문제 | 프로그래머 실수 |
| 예시 | IOException, SQLException | NullPointerException, ArithmeticException |
| 복구 가능성 | 높음 (파일 다시 찾기 등) | 낮음 (코드 수정 필요) |

**왜 RuntimeException은 처리를 강제하지 않을까?**

```java
// 만약 강제한다면...
try {
    int[] arr = {1, 2, 3};
    try {
        System.out.println(arr[0]);  // 매번 try-catch 필요
    } catch (ArrayIndexOutOfBoundsException e) {
        // ...
    }

    try {
        String str = "hello";
        System.out.println(str.length());  // 이것도 try-catch 필요?
    } catch (NullPointerException e) {
        // ...
    }
} catch (Exception e) {
    // 모든 코드를 try-catch로 감싸야 함
}
```

→ **너무 불편하고 코드가 복잡해집니다!**

RuntimeException은 프로그래머가 주의하면 피할 수 있는 예외이므로, 처리를 강제하지 않습니다.

---

## 5. JavaScript와의 비교

### 5.1. JavaScript의 오류 처리

```javascript
// JavaScript는 모든 오류가 Error 객체
try {
    // 런타임 오류
    const result = someUndefinedFunction();
} catch (error) {
    console.log(error.name);     // ReferenceError
    console.log(error.message);  // someUndefinedFunction is not defined
}

// null 체크
const obj = null;
console.log(obj?.name);  // Optional chaining으로 안전하게 처리
```

### 5.2. Java의 예외 처리

```java
try {
    // 런타임 예외
    int result = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println(e.getClass().getName());  // java.lang.ArithmeticException
    System.out.println(e.getMessage());          // / by zero
}

// null 체크
String str = null;
if (str != null) {  // 명시적 null 체크 필요
    System.out.println(str.length());
}
```

### 5.3. 비교 정리

| 특징 | JavaScript | Java |
|------|-----------|------|
| 오류 타입 | Error 객체 하나 | Error + Exception 분리 |
| 예외 강제 | ❌ 없음 | ✅ Checked 예외 |
| null 안전성 | Optional chaining (`?.`) | 명시적 체크 필요 |
| 타입 안전성 | 동적 타입 (약함) | 정적 타입 (강함) |
| 예외 계층 | 단순 | 복잡하고 체계적 |

---

## 6. 예외 처리가 중요한 이유

### 6.1. 프로그램 안정성

```java
// ❌ 예외 처리 없음
public class BadExample {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("숫자 입력: ");
        int num = Integer.parseInt(scanner.nextLine());  // 문자 입력 시 예외!
        System.out.println("입력한 숫자: " + num);
        // 프로그램 비정상 종료
    }
}
```

```java
// ✅ 예외 처리 있음
public class GoodExample {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("숫자 입력: ");

        try {
            int num = Integer.parseInt(scanner.nextLine());
            System.out.println("입력한 숫자: " + num);
        } catch (NumberFormatException e) {
            System.out.println("올바른 숫자를 입력하세요.");
        }

        System.out.println("프로그램 계속 실행");  // 계속 실행됨
    }
}
```

### 6.2. 사용자 경험 개선

```java
// ❌ 나쁜 예
public void login(String userId) {
    User user = findUser(userId);  // null 가능
    System.out.println(user.getName());  // NullPointerException!
}

// ✅ 좋은 예
public void login(String userId) {
    try {
        User user = findUser(userId);
        if (user == null) {
            throw new IllegalArgumentException("사용자를 찾을 수 없습니다.");
        }
        System.out.println("환영합니다, " + user.getName() + "님!");
    } catch (IllegalArgumentException e) {
        System.out.println("로그인 실패: " + e.getMessage());
    }
}
```

---

## 7. 연습 문제

### 문제 1: 예외 종류 파악하기

다음 코드에서 발생할 수 있는 예외를 모두 찾으세요.

```java
public class Practice {
    public static void main(String[] args) {
        String[] words = {"apple", "banana", null, "cherry"};

        for (int i = 0; i <= words.length; i++) {
            System.out.println(words[i].toUpperCase());
        }
    }
}
```

<details>
<summary>답안 보기</summary>

발생 가능한 예외:
1. `ArrayIndexOutOfBoundsException`: `i <= words.length`에서 `i == 4`일 때
2. `NullPointerException`: `words[2]`가 null이므로 `.toUpperCase()` 호출 시

**수정된 코드:**
```java
public class Practice {
    public static void main(String[] args) {
        String[] words = {"apple", "banana", null, "cherry"};

        for (int i = 0; i < words.length; i++) {  // <= 를 < 로 수정
            if (words[i] != null) {  // null 체크 추가
                System.out.println(words[i].toUpperCase());
            }
        }
    }
}
```

</details>

---

### 문제 2: Checked vs Unchecked 구분하기

다음 예외들을 Checked와 Unchecked로 분류하세요.

- `IOException`
- `NullPointerException`
- `SQLException`
- `ArithmeticException`
- `FileNotFoundException`
- `NumberFormatException`

<details>
<summary>답안 보기</summary>

**Checked 예외 (예외 처리 필수):**
- `IOException`
- `SQLException`
- `FileNotFoundException`

**Unchecked 예외 (예외 처리 선택):**
- `NullPointerException`
- `ArithmeticException`
- `NumberFormatException`

</details>

---

## 8. 정리

### 핵심 개념

1. **오류의 종류**: 컴파일 에러, 런타임 에러, 논리 에러
2. **Error vs Exception**: Error는 복구 불가, Exception은 복구 가능
3. **Checked vs Unchecked**:
   - Checked: 처리 필수 (컴파일 에러)
   - Unchecked: 처리 선택 (RuntimeException)
4. **주요 예외**: NullPointerException, ArrayIndexOutOfBoundsException, ArithmeticException

### JavaScript vs Java

| 항목 | JavaScript | Java |
|------|-----------|------|
| 오류 구분 | Error 하나 | Error + Exception |
| 예외 강제 | 없음 | Checked 예외만 |
| null 처리 | `?.` 연산자 | 명시적 체크 |
| 타입 안전성 | 약함 | 강함 |

### 다음 단계

이제 **try-catch-finally**를 학습하여 예외를 실제로 처리하는 방법을 익혀봅시다!

---

**다음 섹션:** [9.2. try-catch-finally를 이용한 예외 처리](./9.2_try_catch_finally를_이용한_예외_처리.md)
