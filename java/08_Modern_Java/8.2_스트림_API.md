# 8.2. 스트림 (Stream) API

## 학습 목표
- 스트림 API의 개념과 필요성을 이해한다
- 스트림의 생성, 중간연산, 최종연산을 활용한다
- JavaScript 배열 메서드와 Java 스트림의 차이를 비교한다
- 실전에서 스트림 API를 효과적으로 사용한다

---

## 1. 스트림이란?

### 1.1. 개념

**스트림(Stream)**은 배열이나 컬렉션을 함수형 프로그래밍 스타일로 다루기 위한 추상화된 데이터 흐름입니다.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// 스트림을 사용한 처리
List<Integer> doubled = numbers.stream()      // 스트림 생성
    .map(n -> n * 2)                          // 중간연산: 변환
    .collect(Collectors.toList());            // 최종연산: 수집

System.out.println(doubled);  // [2, 4, 6, 8, 10]
```

### 1.2. JavaScript 배열 메서드와 비교

#### JavaScript
```javascript
const numbers = [1, 2, 3, 4, 5];

// 체이닝으로 처리
const result = numbers
    .filter(n => n % 2 === 0)  // 짝수만
    .map(n => n * 2)            // 2배로
    .reduce((sum, n) => sum + n, 0);  // 합계

console.log(result);  // 12 (2*2 + 4*2)
```

#### Java
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

int result = numbers.stream()
    .filter(n -> n % 2 == 0)        // 짝수만
    .map(n -> n * 2)                // 2배로
    .reduce(0, (sum, n) -> sum + n); // 합계

System.out.println(result);  // 12
```

**비교 정리:**

| 특징 | JavaScript 배열 | Java 스트림 |
|------|---------------|-----------|
| 메서드 체이닝 | ✅ 지원 | ✅ 지원 |
| 지연 연산 | ❌ 즉시 실행 | ✅ 지연 실행 |
| 재사용 | ✅ 가능 | ❌ 일회용 |
| 병렬 처리 | ❌ 기본 미지원 | ✅ 쉽게 가능 |
| 원본 변경 | ⚠️ 일부 메서드 | ❌ 불변 |

---

## 2. 스트림의 특징

### 2.1. 원본 데이터를 변경하지 않음

```java
List<Integer> original = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

List<Integer> doubled = original.stream()
    .map(n -> n * 2)
    .collect(Collectors.toList());

System.out.println("원본: " + original);  // [1, 2, 3, 4, 5]
System.out.println("결과: " + doubled);   // [2, 4, 6, 8, 10]
```

### 2.2. 일회용 (재사용 불가)

```java
Stream<Integer> stream = numbers.stream();

stream.forEach(System.out::println);  // ✅ 첫 사용

// stream.forEach(System.out::println);  // ❌ 에러!
// IllegalStateException: stream has already been operated upon or closed
```

### 2.3. 내부 반복 처리

```java
// 외부 반복 (전통적 방식)
List<Integer> result1 = new ArrayList<>();
for (Integer n : numbers) {
    if (n % 2 == 0) {
        result1.add(n * 2);
    }
}

// ✅ 내부 반복 (스트림)
List<Integer> result2 = numbers.stream()
    .filter(n -> n % 2 == 0)
    .map(n -> n * 2)
    .collect(Collectors.toList());
```

### 2.4. 지연 연산 (Lazy Evaluation)

중간연산은 최종연산이 호출될 때까지 실행되지 않습니다.

```java
Stream<Integer> stream = numbers.stream()
    .filter(n -> {
        System.out.println("filter: " + n);
        return n % 2 == 0;
    })
    .map(n -> {
        System.out.println("map: " + n);
        return n * 2;
    });

System.out.println("스트림 생성 완료 (아직 실행 안됨)");

List<Integer> result = stream.collect(Collectors.toList());  // 이때 실행!
```

**출력:**
```
스트림 생성 완료 (아직 실행 안됨)
filter: 1
filter: 2
map: 2
filter: 3
filter: 4
map: 4
filter: 5
```

---

## 3. 스트림 생성

### 3.1. 컬렉션으로부터 생성

```java
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> stream = list.stream();

Set<Integer> set = new HashSet<>(Arrays.asList(1, 2, 3));
Stream<Integer> stream2 = set.stream();
```

### 3.2. 배열로부터 생성

```java
String[] array = {"a", "b", "c"};

// 방법 1
Stream<String> stream1 = Stream.of(array);

// 방법 2
Stream<String> stream2 = Arrays.stream(array);

// 가변 인자
Stream<String> stream3 = Stream.of("a", "b", "c");
```

### 3.3. 기본 자료형 스트림

박싱/언박싱 오버헤드를 줄이기 위한 전용 스트림입니다.

```java
// IntStream
IntStream intStream1 = IntStream.of(1, 2, 3, 4, 5);
IntStream intStream2 = IntStream.range(1, 6);        // 1~5
IntStream intStream3 = IntStream.rangeClosed(1, 5);  // 1~5

// LongStream
LongStream longStream = LongStream.range(1L, 100L);

// DoubleStream
DoubleStream doubleStream = DoubleStream.of(1.5, 2.5, 3.5);
```

### 3.4. 빈 스트림

```java
Stream<String> emptyStream = Stream.empty();
System.out.println(emptyStream.count());  // 0
```

### 3.5. 무한 스트림

```java
// iterate: 초기값과 다음 값을 생성하는 함수
Stream<Integer> infiniteStream = Stream.iterate(0, n -> n + 1);
infiniteStream.limit(10).forEach(System.out::println);  // 0~9

// generate: Supplier로 값 생성
Stream<Double> randomStream = Stream.generate(Math::random);
randomStream.limit(5).forEach(System.out::println);  // 랜덤 5개
```

---

## 4. 중간 연산 (Intermediate Operations)

중간 연산은 **스트림을 반환**하므로 체이닝이 가능합니다.

### 4.1. filter() - 필터링

조건을 만족하는 요소만 통과시킵니다.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// 짝수만
List<Integer> evens = numbers.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());

System.out.println(evens);  // [2, 4, 6, 8, 10]

// 5보다 큰 수
List<Integer> greaterThan5 = numbers.stream()
    .filter(n -> n > 5)
    .collect(Collectors.toList());

System.out.println(greaterThan5);  // [6, 7, 8, 9, 10]
```

**JavaScript 비교:**
```javascript
const evens = numbers.filter(n => n % 2 === 0);
```

### 4.2. map() - 변환

각 요소를 다른 형태로 변환합니다.

```java
List<String> words = Arrays.asList("apple", "banana", "cherry");

// 대문자로 변환
List<String> upper = words.stream()
    .map(String::toUpperCase)
    .collect(Collectors.toList());

System.out.println(upper);  // [APPLE, BANANA, CHERRY]

// 길이로 변환
List<Integer> lengths = words.stream()
    .map(String::length)
    .collect(Collectors.toList());

System.out.println(lengths);  // [5, 6, 6]
```

**JavaScript 비교:**
```javascript
const upper = words.map(w => w.toUpperCase());
const lengths = words.map(w => w.length);
```

### 4.3. distinct() - 중복 제거

```java
List<Integer> numbers = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 5, 5);

List<Integer> unique = numbers.stream()
    .distinct()
    .collect(Collectors.toList());

System.out.println(unique);  // [1, 2, 3, 4, 5]
```

**JavaScript 비교:**
```javascript
const unique = [...new Set(numbers)];
```

### 4.4. sorted() - 정렬

```java
List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 9);

// 오름차순
List<Integer> ascending = numbers.stream()
    .sorted()
    .collect(Collectors.toList());

System.out.println(ascending);  // [1, 2, 5, 8, 9]

// 내림차순
List<Integer> descending = numbers.stream()
    .sorted(Comparator.reverseOrder())
    .collect(Collectors.toList());

System.out.println(descending);  // [9, 8, 5, 2, 1]
```

**문자열 정렬:**
```java
List<String> words = Arrays.asList("cherry", "apple", "banana");

// 알파벳 순
List<String> sorted = words.stream()
    .sorted()
    .collect(Collectors.toList());

// 길이 순
List<String> byLength = words.stream()
    .sorted(Comparator.comparingInt(String::length))
    .collect(Collectors.toList());
```

### 4.5. limit() / skip() - 자르기

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// 처음 5개만
List<Integer> first5 = numbers.stream()
    .limit(5)
    .collect(Collectors.toList());

System.out.println(first5);  // [1, 2, 3, 4, 5]

// 처음 3개 건너뛰기
List<Integer> skipFirst3 = numbers.stream()
    .skip(3)
    .collect(Collectors.toList());

System.out.println(skipFirst3);  // [4, 5, 6, 7, 8, 9, 10]

// 조합: 3개 건너뛰고 5개만
List<Integer> middle = numbers.stream()
    .skip(3)
    .limit(5)
    .collect(Collectors.toList());

System.out.println(middle);  // [4, 5, 6, 7, 8]
```

**JavaScript 비교:**
```javascript
const first5 = numbers.slice(0, 5);
const skipFirst3 = numbers.slice(3);
const middle = numbers.slice(3, 8);
```

### 4.6. peek() - 중간 확인 (디버깅용)

```java
List<Integer> result = numbers.stream()
    .peek(n -> System.out.println("원본: " + n))
    .filter(n -> n % 2 == 0)
    .peek(n -> System.out.println("필터 후: " + n))
    .map(n -> n * 2)
    .peek(n -> System.out.println("변환 후: " + n))
    .collect(Collectors.toList());
```

### 4.7. mapToInt / mapToLong / mapToDouble

일반 스트림을 기본 자료형 스트림으로 변환합니다.

```java
List<String> numbers = Arrays.asList("1", "2", "3", "4", "5");

// String -> int
int sum = numbers.stream()
    .mapToInt(Integer::parseInt)
    .sum();

System.out.println("합계: " + sum);  // 15

// 통계 정보
IntSummaryStatistics stats = numbers.stream()
    .mapToInt(Integer::parseInt)
    .summaryStatistics();

System.out.println("개수: " + stats.getCount());      // 5
System.out.println("합계: " + stats.getSum());        // 15
System.out.println("평균: " + stats.getAverage());    // 3.0
System.out.println("최소: " + stats.getMin());        // 1
System.out.println("최대: " + stats.getMax());        // 5
```

---

## 5. 최종 연산 (Terminal Operations)

최종 연산은 **결과를 반환**하며, 스트림을 소비합니다.

### 5.1. forEach() - 반복

```java
List<String> words = Arrays.asList("apple", "banana", "cherry");

words.stream()
    .forEach(System.out::println);
```

**JavaScript 비교:**
```javascript
words.forEach(word => console.log(word));
```

### 5.2. collect() - 수집

#### toList() - 리스트로 수집

```java
List<Integer> result = numbers.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());  // 가변 리스트

// Java 16+
List<Integer> result2 = numbers.stream()
    .filter(n -> n % 2 == 0)
    .toList();  // 불변 리스트 (권장)
```

#### toSet() - Set으로 수집

```java
List<Integer> numbers = Arrays.asList(1, 2, 2, 3, 3, 3, 4);

Set<Integer> uniqueNumbers = numbers.stream()
    .collect(Collectors.toSet());

System.out.println(uniqueNumbers);  // [1, 2, 3, 4]
```

#### toMap() - Map으로 수집

```java
List<String> words = Arrays.asList("apple", "banana", "cherry");

// 단어 -> 길이
Map<String, Integer> wordLengths = words.stream()
    .collect(Collectors.toMap(
        word -> word,           // key
        word -> word.length()   // value
    ));

System.out.println(wordLengths);
// {apple=5, banana=6, cherry=6}
```

#### joining() - 문자열 연결

```java
List<String> words = Arrays.asList("apple", "banana", "cherry");

String joined = words.stream()
    .collect(Collectors.joining(", "));

System.out.println(joined);  // apple, banana, cherry

// 접두사, 접미사 추가
String formatted = words.stream()
    .collect(Collectors.joining(", ", "[", "]"));

System.out.println(formatted);  // [apple, banana, cherry]
```

**JavaScript 비교:**
```javascript
const joined = words.join(", ");
```

### 5.3. reduce() - 누적 연산

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// 합계
int sum = numbers.stream()
    .reduce(0, (a, b) -> a + b);

System.out.println(sum);  // 15

// 곱셈
int product = numbers.stream()
    .reduce(1, (a, b) -> a * b);

System.out.println(product);  // 120

// 최대값
Optional<Integer> max = numbers.stream()
    .reduce((a, b) -> a > b ? a : b);

System.out.println(max.get());  // 5
```

**JavaScript 비교:**
```javascript
const sum = numbers.reduce((a, b) => a + b, 0);
const product = numbers.reduce((a, b) => a * b, 1);
```

### 5.4. count() / sum() / average() / max() / min()

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// 개수
long count = numbers.stream().count();
System.out.println("개수: " + count);  // 5

// IntStream으로 변환 후 집계
int sum = numbers.stream()
    .mapToInt(Integer::intValue)
    .sum();

OptionalDouble avg = numbers.stream()
    .mapToInt(Integer::intValue)
    .average();

OptionalInt max = numbers.stream()
    .mapToInt(Integer::intValue)
    .max();

System.out.println("합계: " + sum);             // 15
System.out.println("평균: " + avg.getAsDouble()); // 3.0
System.out.println("최대: " + max.getAsInt());    // 5
```

### 5.5. allMatch() / anyMatch() / noneMatch()

```java
List<Integer> numbers = Arrays.asList(2, 4, 6, 8, 10);

// 모두 짝수인가?
boolean allEven = numbers.stream()
    .allMatch(n -> n % 2 == 0);

System.out.println(allEven);  // true

// 하나라도 10보다 큰가?
boolean anyGreaterThan10 = numbers.stream()
    .anyMatch(n -> n > 10);

System.out.println(anyGreaterThan10);  // false

// 모두 음수가 아닌가?
boolean noneNegative = numbers.stream()
    .noneMatch(n -> n < 0);

System.out.println(noneNegative);  // true
```

**JavaScript 비교:**
```javascript
const allEven = numbers.every(n => n % 2 === 0);
const anyGreaterThan10 = numbers.some(n => n > 10);
```

### 5.6. findFirst() / findAny()

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// 첫 번째 요소
Optional<Integer> first = numbers.stream()
    .findFirst();

System.out.println(first.get());  // 1

// 조건을 만족하는 첫 요소
Optional<Integer> firstEven = numbers.stream()
    .filter(n -> n % 2 == 0)
    .findFirst();

System.out.println(firstEven.get());  // 2

// 임의의 요소 (병렬 스트림에서 유용)
Optional<Integer> any = numbers.stream()
    .findAny();
```

**JavaScript 비교:**
```javascript
const firstEven = numbers.find(n => n % 2 === 0);
```

---

## 6. 실전 예제

### 예제 1: 상품 목록 처리

```java
class Product {
    private String name;
    private int price;
    private String category;

    public Product(String name, int price, String category) {
        this.name = name;
        this.price = price;
        this.category = category;
    }

    public String getName() { return name; }
    public int getPrice() { return price; }
    public String getCategory() { return category; }
}

public class ProductExample {
    public static void main(String[] args) {
        List<Product> products = Arrays.asList(
            new Product("노트북", 1200000, "전자제품"),
            new Product("마우스", 50000, "전자제품"),
            new Product("키보드", 150000, "전자제품"),
            new Product("책상", 300000, "가구"),
            new Product("의자", 200000, "가구")
        );

        // 1. 전자제품만 필터링
        List<Product> electronics = products.stream()
            .filter(p -> p.getCategory().equals("전자제품"))
            .collect(Collectors.toList());

        System.out.println("=== 전자제품 ===");
        electronics.forEach(p -> System.out.println(p.getName()));

        // 2. 20만원 이상 상품의 이름
        List<String> expensiveProducts = products.stream()
            .filter(p -> p.getPrice() >= 200000)
            .map(Product::getName)
            .collect(Collectors.toList());

        System.out.println("\n=== 20만원 이상 상품 ===");
        System.out.println(expensiveProducts);

        // 3. 전자제품 가격 합계
        int totalElectronicsPrice = products.stream()
            .filter(p -> p.getCategory().equals("전자제품"))
            .mapToInt(Product::getPrice)
            .sum();

        System.out.println("\n=== 전자제품 총액 ===");
        System.out.printf("%,d원\n", totalElectronicsPrice);

        // 4. 카테고리별 그룹화
        Map<String, List<Product>> byCategory = products.stream()
            .collect(Collectors.groupingBy(Product::getCategory));

        System.out.println("\n=== 카테고리별 상품 ===");
        byCategory.forEach((category, items) -> {
            System.out.println(category + ": " + items.size() + "개");
        });

        // 5. 가장 비싼 상품
        Optional<Product> mostExpensive = products.stream()
            .max(Comparator.comparingInt(Product::getPrice));

        mostExpensive.ifPresent(p ->
            System.out.printf("\n=== 최고가 상품 ===\n%s: %,d원\n",
                p.getName(), p.getPrice())
        );
    }
}
```

**출력:**
```
=== 전자제품 ===
노트북
마우스
키보드

=== 20만원 이상 상품 ===
[노트북, 책상, 의자]

=== 전자제품 총액 ===
1,400,000원

=== 카테고리별 상품 ===
가구: 2개
전자제품: 3개

=== 최고가 상품 ===
노트북: 1,200,000원
```

### 예제 2: 학생 성적 분석

```java
class Student {
    private String name;
    private int score;

    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }

    public String getName() { return name; }
    public int getScore() { return score; }
}

public class StudentExample {
    public static void main(String[] args) {
        List<Student> students = Arrays.asList(
            new Student("김철수", 95),
            new Student("이영희", 88),
            new Student("박민수", 76),
            new Student("최지원", 92),
            new Student("정수진", 84)
        );

        // 1. 평균 점수
        double average = students.stream()
            .mapToInt(Student::getScore)
            .average()
            .orElse(0.0);

        System.out.printf("평균: %.1f점\n", average);

        // 2. 90점 이상 학생
        List<String> excellentStudents = students.stream()
            .filter(s -> s.getScore() >= 90)
            .map(Student::getName)
            .collect(Collectors.toList());

        System.out.println("우수 학생: " + excellentStudents);

        // 3. 점수 순 정렬
        List<Student> sorted = students.stream()
            .sorted(Comparator.comparingInt(Student::getScore).reversed())
            .collect(Collectors.toList());

        System.out.println("\n=== 성적 순위 ===");
        int rank = 1;
        for (Student s : sorted) {
            System.out.printf("%d등: %s (%d점)\n",
                rank++, s.getName(), s.getScore());
        }

        // 4. 통계
        IntSummaryStatistics stats = students.stream()
            .mapToInt(Student::getScore)
            .summaryStatistics();

        System.out.println("\n=== 통계 ===");
        System.out.println("최고점: " + stats.getMax());
        System.out.println("최저점: " + stats.getMin());
        System.out.printf("평균: %.1f점\n", stats.getAverage());
    }
}
```

**출력:**
```
평균: 87.0점
우수 학생: [김철수, 최지원]

=== 성적 순위 ===
1등: 김철수 (95점)
2등: 최지원 (92점)
3등: 이영희 (88점)
4등: 정수진 (84점)
5등: 박민수 (76점)

=== 통계 ===
최고점: 95
최저점: 76
평균: 87.0점
```

---

## 7. 고급 기능

### 7.1. flatMap() - 평탄화

중첩된 구조를 평탄화합니다.

```java
List<List<Integer>> nested = Arrays.asList(
    Arrays.asList(1, 2, 3),
    Arrays.asList(4, 5),
    Arrays.asList(6, 7, 8, 9)
);

// flatMap으로 평탄화
List<Integer> flattened = nested.stream()
    .flatMap(list -> list.stream())
    .collect(Collectors.toList());

System.out.println(flattened);
// [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**문자열 예시:**
```java
List<String> words = Arrays.asList("Hello", "World");

// 각 단어를 문자 스트림으로 변환 후 평탄화
List<String> letters = words.stream()
    .flatMap(word -> Arrays.stream(word.split("")))
    .distinct()
    .collect(Collectors.toList());

System.out.println(letters);
// [H, e, l, o, W, r, d]
```

**JavaScript 비교:**
```javascript
const nested = [[1, 2, 3], [4, 5], [6, 7, 8, 9]];
const flattened = nested.flat();
// 또는
const flattened2 = nested.flatMap(arr => arr);
```

### 7.2. 병렬 스트림

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// 순차 스트림
long start1 = System.currentTimeMillis();
int sum1 = numbers.stream()
    .mapToInt(Integer::intValue)
    .sum();
long end1 = System.currentTimeMillis();

// 병렬 스트림
long start2 = System.currentTimeMillis();
int sum2 = numbers.parallelStream()  // 병렬 처리
    .mapToInt(Integer::intValue)
    .sum();
long end2 = System.currentTimeMillis();

System.out.println("순차: " + (end1 - start1) + "ms");
System.out.println("병렬: " + (end2 - start2) + "ms");
```

⚠️ **주의:** 작은 데이터셋에서는 병렬 처리 오버헤드가 더 클 수 있습니다.

### 7.3. groupingBy() - 그룹화

```java
List<String> words = Arrays.asList(
    "apple", "banana", "cherry",
    "apricot", "blueberry", "coconut"
);

// 첫 글자로 그룹화
Map<Character, List<String>> grouped = words.stream()
    .collect(Collectors.groupingBy(w -> w.charAt(0)));

System.out.println(grouped);
// {a=[apple, apricot], b=[banana, blueberry], c=[cherry, coconut]}

// 길이로 그룹화
Map<Integer, List<String>> byLength = words.stream()
    .collect(Collectors.groupingBy(String::length));

System.out.println(byLength);
// {5=[apple], 6=[banana, cherry], 7=[apricot, coconut], 9=[blueberry]}
```

### 7.4. partitioningBy() - 분할

boolean 조건으로 두 그룹으로 분할합니다.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

Map<Boolean, List<Integer>> partitioned = numbers.stream()
    .collect(Collectors.partitioningBy(n -> n % 2 == 0));

System.out.println("짝수: " + partitioned.get(true));
System.out.println("홀수: " + partitioned.get(false));
```

---

## 8. 정리

### 핵심 개념

1. **스트림 파이프라인**: 생성 → 중간연산 → 최종연산
2. **지연 연산**: 최종연산이 호출될 때까지 실행 안됨
3. **불변성**: 원본 데이터를 변경하지 않음
4. **일회용**: 한 번 사용한 스트림은 재사용 불가

### 주요 연산 정리

| 연산 | JavaScript | Java Stream |
|------|-----------|------------|
| 필터링 | `filter()` | `filter()` |
| 변환 | `map()` | `map()` |
| 평탄화 | `flat()`, `flatMap()` | `flatMap()` |
| 정렬 | `sort()` | `sorted()` |
| 중복 제거 | `[...new Set()]` | `distinct()` |
| 자르기 | `slice()` | `limit()`, `skip()` |
| 누적 | `reduce()` | `reduce()` |
| 조건 검사 | `every()`, `some()` | `allMatch()`, `anyMatch()` |
| 찾기 | `find()` | `findFirst()`, `findAny()` |
| 반복 | `forEach()` | `forEach()` |
| 수집 | 배열 자체 | `collect()` |

### 다음 단계

이제 **실습**을 통해 람다와 스트림을 종합적으로 활용해봅시다!

---

**다음 섹션:** [8.3. 실습: 람다와 스트림 활용](./8.3_실습.md)
