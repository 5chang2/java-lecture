# 8.1. 함수형 인터페이스와 람다 표현식

## 학습 목표
- 함수형 인터페이스의 개념과 필요성을 이해한다
- 람다 표현식의 문법과 활용법을 익힌다
- JavaScript의 화살표 함수와 Java 람다의 차이를 비교한다
- 표준 함수형 인터페이스를 활용한다
- 메서드 참조를 이해하고 사용한다

---

## 1. 함수형 프로그래밍이란?

### 1.1. 개념

**함수형 프로그래밍(Functional Programming)**은 함수를 **일급 객체(First-Class Citizen)**로 취급하여 프로그래밍하는 패러다임입니다.

**일급 객체의 조건:**
1. 변수나 자료구조에 저장할 수 있다
2. 함수의 매개변수로 전달할 수 있다
3. 함수의 반환값으로 사용할 수 있다

### 1.2. JavaScript의 함수형 프로그래밍

JavaScript는 함수를 일급 객체로 취급합니다.

```javascript
// 1. 변수에 함수 할당
const greet = function(name) {
    return `Hello, ${name}!`;
};

// 2. 함수를 매개변수로 전달
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2);

// 3. 함수를 반환
function createMultiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

const double = createMultiplier(2);
console.log(double(5));  // 10
```

### 1.3. Java의 함수형 프로그래밍

Java는 순수한 객체 지향 언어였지만, **Java 8부터 람다 표현식**을 도입하여 함수형 프로그래밍을 지원합니다.

```java
// 람다 표현식 사용
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> doubled = numbers.stream()
    .map(n -> n * 2)
    .collect(Collectors.toList());

System.out.println(doubled);  // [2, 4, 6, 8, 10]
```

---

## 2. 함수형 인터페이스

### 2.1. 개념

**함수형 인터페이스(Functional Interface)**는 **추상 메서드가 단 하나만** 존재하는 인터페이스입니다.

```java
@FunctionalInterface
public interface Calculator {
    int calculate(int x, int y);  // 단 하나의 추상 메서드
}
```

**주요 특징:**
- 추상 메서드가 **정확히 1개**
- default 메서드와 static 메서드는 여러 개 가능
- `@FunctionalInterface` 어노테이션으로 검증

### 2.2. 함수형 인터페이스가 필요한 이유

Java에서 함수를 일급 객체처럼 다루기 위한 방법입니다.

**JavaScript와 비교:**

```javascript
// JavaScript - 함수를 바로 변수에 할당
const add = (x, y) => x + y;
console.log(add(5, 3));  // 8
```

```java
// Java - 함수형 인터페이스를 통해 람다를 변수에 할당
@FunctionalInterface
interface Calculator {
    int calculate(int x, int y);
}

public class Main {
    public static void main(String[] args) {
        Calculator add = (x, y) -> x + y;
        System.out.println(add.calculate(5, 3));  // 8
    }
}
```

---

## 3. 함수형 인터페이스 구현 방법

### 3.1. 방법 1: 인터페이스 구현 클래스

```java
@FunctionalInterface
interface Adder {
    int add(int a, int b);
}

// 별도 클래스로 구현
class MyAdder implements Adder {
    @Override
    public int add(int a, int b) {
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        Adder adder = new MyAdder();
        System.out.println(adder.add(5, 3));  // 8
    }
}
```

**단점:** 간단한 기능을 위해 별도의 클래스 파일이 필요함

### 3.2. 방법 2: 익명 클래스

```java
public class Main {
    public static void main(String[] args) {
        Adder adder = new Adder() {
            @Override
            public int add(int a, int b) {
                return a + b;
            }
        };

        System.out.println(adder.add(5, 3));  // 8
    }
}
```

**장점:** 별도 클래스 파일 불필요
**단점:** 코드가 길고 가독성이 떨어짐

### 3.3. 방법 3: 람다 표현식 ✅ (권장)

```java
public class Main {
    public static void main(String[] args) {
        Adder adder = (a, b) -> a + b;  // 람다 표현식
        System.out.println(adder.add(5, 3));  // 8
    }
}
```

**장점:** 간결하고 가독성이 좋음

---

## 4. 람다 표현식

### 4.1. 문법

```java
(매개변수) -> 구현부
```

**기본 예제:**

```java
// 매개변수 2개, 반환값 있음
Calculator add = (x, y) -> x + y;

// 매개변수 1개, 반환값 있음
Function<Integer, Integer> square = x -> x * x;

// 매개변수 없음, 반환값 없음
Runnable task = () -> System.out.println("Hello");
```

### 4.2. 람다 표현식 작성 규칙

#### 규칙 1: 구현부가 여러 줄이면 중괄호 사용

```java
Calculator add = (x, y) -> {
    int result = x + y;
    System.out.println("계산 중...");
    return result;
};
```

#### 규칙 2: 한 줄이고 반환값이 있으면 return 생략 가능

```java
// ❌ 불필요한 return
Calculator add = (x, y) -> { return x + y; };

// ✅ 간결한 표현
Calculator add = (x, y) -> x + y;
```

#### 규칙 3: 매개변수가 1개면 소괄호 생략 가능

```java
// 소괄호 있음
Function<Integer, Integer> square = (x) -> x * x;

// ✅ 소괄호 생략
Function<Integer, Integer> square = x -> x * x;
```

#### 규칙 4: 매개변수 타입은 생략 가능 (타입 추론)

```java
// 타입 명시
Calculator add = (int x, int y) -> x + y;

// ✅ 타입 추론 (권장)
Calculator add = (x, y) -> x + y;
```

### 4.3. JavaScript 화살표 함수와 비교

| 특징 | JavaScript | Java |
|------|-----------|------|
| 문법 | `(x, y) => x + y` | `(x, y) -> x + y` |
| 기호 | `=>` (화살표) | `->` (애로우) |
| 타입 | 타입 없음 (동적) | 타입 추론 가능 |
| this 바인딩 | 렉시컬 바인딩 | 없음 (함수 아님) |
| 사용 위치 | 어디서나 | 함수형 인터페이스 필요 |

**JavaScript:**
```javascript
const add = (x, y) => x + y;
const square = x => x * x;
const greet = () => console.log("Hello");

// 함수를 바로 호출
console.log(add(5, 3));
```

**Java:**
```java
// 함수형 인터페이스 필요
Calculator add = (x, y) -> x + y;
Function<Integer, Integer> square = x -> x * x;
Runnable greet = () -> System.out.println("Hello");

// 인터페이스 메서드를 통해 호출
System.out.println(add.calculate(5, 3));
```

---

## 5. 표준 함수형 인터페이스

Java는 자주 사용되는 함수형 인터페이스를 `java.util.function` 패키지에서 제공합니다.

### 5.1. 주요 표준 함수형 인터페이스

| 인터페이스 | 추상 메서드 | 설명 | JavaScript 비교 |
|----------|----------|------|---------------|
| `Runnable` | `void run()` | 매개변수 X, 반환값 X | `() => {}` |
| `Supplier<T>` | `T get()` | 매개변수 X, 반환값 O | `() => value` |
| `Consumer<T>` | `void accept(T)` | 매개변수 O, 반환값 X | `x => {}` |
| `Function<T, R>` | `R apply(T)` | 매개변수 O, 반환값 O | `x => result` |
| `Predicate<T>` | `boolean test(T)` | 조건 검사, boolean 반환 | `x => true/false` |

### 5.2. Runnable - 매개변수 X, 반환값 X

```java
public class Main {
    public static void main(String[] args) {
        Runnable task = () -> System.out.println("Task executed");
        task.run();  // Task executed
    }
}
```

**JavaScript 비교:**
```javascript
const task = () => console.log("Task executed");
task();  // Task executed
```

**실전 활용 - 스레드:**
```java
Thread thread = new Thread(() -> {
    System.out.println("스레드 실행 중...");
});
thread.start();
```

### 5.3. Supplier<T> - 매개변수 X, 반환값 O

```java
import java.util.function.Supplier;

public class Main {
    public static void main(String[] args) {
        Supplier<String> greeting = () -> "Hello, World!";
        System.out.println(greeting.get());  // Hello, World!

        Supplier<Double> randomValue = () -> Math.random();
        System.out.println(randomValue.get());  // 0.123456...
    }
}
```

**JavaScript 비교:**
```javascript
const greeting = () => "Hello, World!";
console.log(greeting());  // Hello, World!
```

### 5.4. Consumer<T> - 매개변수 O, 반환값 X

```java
import java.util.function.Consumer;

public class Main {
    public static void main(String[] args) {
        Consumer<String> printer = message -> System.out.println(message);
        printer.accept("Hello");  // Hello

        Consumer<Integer> logger = num -> System.out.println("숫자: " + num);
        logger.accept(42);  // 숫자: 42
    }
}
```

**BiConsumer - 매개변수 2개:**
```java
import java.util.function.BiConsumer;

BiConsumer<String, Integer> printInfo = (name, age) -> {
    System.out.printf("%s님은 %d살입니다.\n", name, age);
};

printInfo.accept("홍길동", 25);  // 홍길동님은 25살입니다.
```

**JavaScript 비교:**
```javascript
const printer = message => console.log(message);
printer("Hello");
```

### 5.5. Function<T, R> - 매개변수 O, 반환값 O

```java
import java.util.function.Function;

public class Main {
    public static void main(String[] args) {
        // String -> Integer
        Function<String, Integer> parser = s -> Integer.parseInt(s);
        System.out.println(parser.apply("100"));  // 100

        // Integer -> String
        Function<Integer, String> formatter = n -> "숫자: " + n;
        System.out.println(formatter.apply(42));  // 숫자: 42
    }
}
```

**BiFunction - 매개변수 2개:**
```java
import java.util.function.BiFunction;

BiFunction<Integer, Integer, Integer> add = (x, y) -> x + y;
System.out.println(add.apply(5, 3));  // 8

BiFunction<String, String, String> concat = (s1, s2) -> s1 + " " + s2;
System.out.println(concat.apply("Hello", "World"));  // Hello World
```

**JavaScript 비교:**
```javascript
const parser = s => parseInt(s);
const formatter = n => `숫자: ${n}`;
const add = (x, y) => x + y;
```

### 5.6. Predicate<T> - 조건 검사

```java
import java.util.function.Predicate;

public class Main {
    public static void main(String[] args) {
        Predicate<Integer> isEven = n -> n % 2 == 0;
        System.out.println(isEven.test(4));  // true
        System.out.println(isEven.test(5));  // false

        Predicate<String> isEmpty = s -> s.isEmpty();
        System.out.println(isEmpty.test(""));     // true
        System.out.println(isEmpty.test("hi"));   // false
    }
}
```

**Predicate 조합:**
```java
Predicate<Integer> isPositive = n -> n > 0;
Predicate<Integer> isEven = n -> n % 2 == 0;

// and: 두 조건 모두 만족
Predicate<Integer> isPositiveEven = isPositive.and(isEven);
System.out.println(isPositiveEven.test(4));   // true
System.out.println(isPositiveEven.test(-4));  // false

// or: 하나라도 만족
Predicate<Integer> isPositiveOrEven = isPositive.or(isEven);
System.out.println(isPositiveOrEven.test(-4));  // true (짝수)

// negate: 조건 반전
Predicate<Integer> isOdd = isEven.negate();
System.out.println(isOdd.test(5));  // true
```

**JavaScript 비교:**
```javascript
const isEven = n => n % 2 === 0;
const isEmpty = s => s.length === 0;
```

---

## 6. 메서드 참조

### 6.1. 개념

람다 표현식이 단 하나의 메서드만 호출하는 경우, 더 간결하게 표현할 수 있습니다.

```java
// 람다 표현식
Function<String, Integer> parser1 = s -> Integer.parseInt(s);

// 메서드 참조 ✅
Function<String, Integer> parser2 = Integer::parseInt;
```

**문법:** `클래스명::메서드명`

### 6.2. 메서드 참조 종류

| 종류 | 문법 | 예시 |
|------|------|------|
| 정적 메서드 참조 | `클래스명::메서드명` | `Integer::parseInt` |
| 인스턴스 메서드 참조 | `인스턴스명::메서드명` | `str::length` |
| 특정 타입의 메서드 참조 | `클래스명::메서드명` | `String::toUpperCase` |
| 생성자 참조 | `클래스명::new` | `ArrayList::new` |

### 6.3. 정적 메서드 참조

```java
// 람다
Function<String, Integer> parser = s -> Integer.parseInt(s);

// ✅ 메서드 참조
Function<String, Integer> parser = Integer::parseInt;

System.out.println(parser.apply("100"));  // 100
```

**더 많은 예시:**

```java
// Math.abs
Function<Integer, Integer> abs = Math::abs;
System.out.println(abs.apply(-10));  // 10

// Math.sqrt
Function<Double, Double> sqrt = Math::sqrt;
System.out.println(sqrt.apply(16.0));  // 4.0

// String.valueOf
Function<Integer, String> stringify = String::valueOf;
System.out.println(stringify.apply(42));  // "42"
```

### 6.4. 인스턴스 메서드 참조

```java
String str = "hello";

// 람다
Supplier<Integer> lengthGetter = () -> str.length();

// ✅ 메서드 참조
Supplier<Integer> lengthGetter = str::length;

System.out.println(lengthGetter.get());  // 5
```

**리스트 예시:**

```java
List<String> words = Arrays.asList("apple", "banana", "cherry");

// 람다
words.forEach(word -> System.out.println(word));

// ✅ 메서드 참조
words.forEach(System.out::println);
```

### 6.5. 특정 타입의 메서드 참조

매개변수의 메서드를 호출할 때 사용합니다.

```java
// 람다
Function<String, String> upper = s -> s.toUpperCase();

// ✅ 메서드 참조
Function<String, String> upper = String::toUpperCase;

System.out.println(upper.apply("hello"));  // HELLO
```

**BiFunction 예시:**

```java
// 람다
BiFunction<String, String, Boolean> startsWith = (s, prefix) -> s.startsWith(prefix);

// ✅ 메서드 참조
BiFunction<String, String, Boolean> startsWith = String::startsWith;

System.out.println(startsWith.apply("hello", "he"));  // true
```

### 6.6. 생성자 참조

```java
// 람다
Supplier<ArrayList<String>> listSupplier = () -> new ArrayList<>();

// ✅ 생성자 참조
Supplier<ArrayList<String>> listSupplier = ArrayList::new;

List<String> list = listSupplier.get();
```

**매개변수가 있는 생성자:**

```java
// String 생성자
Function<String, String> constructor = String::new;
String str = constructor.apply("Hello");

// StringBuilder 생성자
Function<String, StringBuilder> sbConstructor = StringBuilder::new;
StringBuilder sb = sbConstructor.apply("Hello");
```

---

## 7. 실전 예제

### 예제 1: 리스트 필터링

```java
import java.util.*;
import java.util.function.Predicate;

public class FilterExample {
    // 제네릭 필터 메서드
    public static <T> List<T> filter(List<T> list, Predicate<T> predicate) {
        List<T> result = new ArrayList<>();
        for (T item : list) {
            if (predicate.test(item)) {
                result.add(item);
            }
        }
        return result;
    }

    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // 짝수만 필터링
        List<Integer> evens = filter(numbers, n -> n % 2 == 0);
        System.out.println("짝수: " + evens);  // [2, 4, 6, 8, 10]

        // 5보다 큰 수만
        List<Integer> greaterThan5 = filter(numbers, n -> n > 5);
        System.out.println("5보다 큰 수: " + greaterThan5);  // [6, 7, 8, 9, 10]
    }
}
```

**JavaScript 비교:**
```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const evens = numbers.filter(n => n % 2 === 0);
const greaterThan5 = numbers.filter(n => n > 5);
```

### 예제 2: 리스트 변환 (map)

```java
import java.util.*;
import java.util.function.Function;

public class MapExample {
    public static <T, R> List<R> map(List<T> list, Function<T, R> mapper) {
        List<R> result = new ArrayList<>();
        for (T item : list) {
            result.add(mapper.apply(item));
        }
        return result;
    }

    public static void main(String[] args) {
        List<String> words = Arrays.asList("apple", "banana", "cherry");

        // 대문자로 변환
        List<String> upper = map(words, String::toUpperCase);
        System.out.println("대문자: " + upper);

        // 길이로 변환
        List<Integer> lengths = map(words, String::length);
        System.out.println("길이: " + lengths);
    }
}
```

**출력:**
```
대문자: [APPLE, BANANA, CHERRY]
길이: [5, 6, 6]
```

### 예제 3: 계산기 시스템

```java
import java.util.function.BiFunction;

public class CalculatorSystem {
    // 계산 실행 메서드
    public static int calculate(int x, int y, BiFunction<Integer, Integer, Integer> operation) {
        return operation.apply(x, y);
    }

    public static void main(String[] args) {
        int a = 10;
        int b = 3;

        // 다양한 연산
        int sum = calculate(a, b, (x, y) -> x + y);
        int difference = calculate(a, b, (x, y) -> x - y);
        int product = calculate(a, b, (x, y) -> x * y);
        int quotient = calculate(a, b, (x, y) -> x / y);

        System.out.println("합: " + sum);          // 13
        System.out.println("차: " + difference);   // 7
        System.out.println("곱: " + product);      // 30
        System.out.println("몫: " + quotient);     // 3
    }
}
```

---

## 8. 연습 문제

### 문제 1: 사용자 정의 함수형 인터페이스 (기본)

다음 요구사항을 만족하는 함수형 인터페이스를 작성하고 람다로 구현하세요.

**요구사항:**
- 이름: `StringProcessor`
- 메서드: `String process(String input)`
- 구현: 문자열을 받아 공백을 제거하고 대문자로 변환

<details>
<summary>답안 보기</summary>

```java
@FunctionalInterface
interface StringProcessor {
    String process(String input);
}

public class Main {
    public static void main(String[] args) {
        StringProcessor processor = s -> s.trim().toUpperCase();

        System.out.println(processor.process("  hello world  "));
        // HELLO WORLD
    }
}
```

</details>

---

### 문제 2: Predicate 활용 (중급)

정수 리스트에서 조건을 만족하는 첫 번째 요소를 찾는 메서드를 작성하세요.

**요구사항:**
- 메서드 시그니처: `public static Integer findFirst(List<Integer> list, Predicate<Integer> predicate)`
- 찾지 못하면 null 반환

<details>
<summary>답안 보기</summary>

```java
import java.util.*;
import java.util.function.Predicate;

public class PredicateExample {
    public static Integer findFirst(List<Integer> list, Predicate<Integer> predicate) {
        for (Integer num : list) {
            if (predicate.test(num)) {
                return num;
            }
        }
        return null;
    }

    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 3, 5, 8, 10, 15);

        Integer firstEven = findFirst(numbers, n -> n % 2 == 0);
        System.out.println("첫 번째 짝수: " + firstEven);  // 8

        Integer firstGreaterThan10 = findFirst(numbers, n -> n > 10);
        System.out.println("10보다 큰 첫 수: " + firstGreaterThan10);  // 15

        Integer firstNegative = findFirst(numbers, n -> n < 0);
        System.out.println("첫 번째 음수: " + firstNegative);  // null
    }
}
```

</details>

---

### 문제 3: Function 체이닝 (고급)

여러 Function을 연결하여 데이터를 변환하는 파이프라인을 구현하세요.

**요구사항:**
- 입력: 문자열 숫자 ("  123  ")
- 과정: 공백 제거 → 정수 변환 → 2배로 만들기 → 문자열로 변환
- 출력: "246"

<details>
<summary>답안 보기</summary>

```java
import java.util.function.Function;

public class FunctionChaining {
    public static void main(String[] args) {
        // 각 단계별 Function 정의
        Function<String, String> trimmer = String::trim;
        Function<String, Integer> parser = Integer::parseInt;
        Function<Integer, Integer> doubler = n -> n * 2;
        Function<Integer, String> stringifier = String::valueOf;

        // andThen으로 체이닝
        Function<String, String> pipeline = trimmer
            .andThen(parser)
            .andThen(doubler)
            .andThen(stringifier);

        String result = pipeline.apply("  123  ");
        System.out.println("결과: " + result);  // 246

        // 다른 입력
        System.out.println(pipeline.apply("50"));  // 100
    }
}
```

**compose 사용 (역순 체이닝):**
```java
// compose는 역순으로 실행
Function<Integer, String> pipeline2 = stringifier
    .compose(doubler)
    .compose(parser)
    .compose(trimmer);

// 실행 순서: trimmer -> parser -> doubler -> stringifier
```

</details>

---

## 9. 정리

### 핵심 개념

1. **함수형 인터페이스**: 추상 메서드가 1개인 인터페이스
2. **람다 표현식**: `(매개변수) -> 구현부` 형태의 간결한 함수 표현
3. **표준 함수형 인터페이스**: `Runnable`, `Supplier`, `Consumer`, `Function`, `Predicate`
4. **메서드 참조**: `클래스명::메서드명` 형태로 더 간결하게 표현

### JavaScript vs Java 람다

| 특징 | JavaScript | Java |
|------|-----------|------|
| 함수 일급 객체 | ✅ 기본 지원 | ⚠️ 람다로 흉내 |
| 문법 | `=>` | `->` |
| 타입 | 동적 타입 | 정적 타입 (추론 가능) |
| 사용처 | 어디서나 | 함수형 인터페이스 필요 |
| 클로저 | ✅ 완전 지원 | ✅ effectively final만 |

### 다음 단계

이제 **스트림 API**를 학습하여 람다 표현식을 실전에서 활용할 준비가 되었습니다!

---

**다음 섹션:** [8.2. 스트림 (Stream) API](./8.2_스트림_API.md)
