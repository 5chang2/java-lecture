
# 예외 처리

## 프로그램 오류

`에러 또는 오류`란, 프로그램이 실행 중에 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우를 말한다. 에러는 크게 아래와 같이 세 가지의 종류가 존재한다.

- 컴파일 에러 : 컴파일 시에 발생하는 에러
- 런타임 에러 : 실행 시에 발생하는 에러
- 논리적 에러 : 실행은 되지만, 의도와 다르게 동작하는 것

Java는 실행(런타임) 시, 발생할 수 있는 프로그램 오류를 `에러(Error)`와 `예외(Exception)`로 구분한다.

- `에러(Error)` : 메모리 부족이나 스택 오버 플로우와 같이 발생하면 복구할 수 없는 치명적인 오류
- `예외(Exception)` : 발생하더라도 수습될 수 있는 비교적 덜 치명적인 오류

---

## 예외 클래스의 계층구조

![[Pasted image 20250924165530.png]]

[https://interviewnoodle.com/exception-in-java-89a0b41e0c45](https://interviewnoodle.com/exception-in-java-89a0b41e0c45)

Java에서는 실행 시 발생할 수 있는 `에러(Error)와 예외(Exception)를 클래스로 정의`한다.

모든 클래스의 조상은 Object 클래스이므로, 에러와 예외 클래스도 Object의 자손이다.

모든 예외의 최상위 조상은 Exception 클래스이다.

---

## 예외 처리하기 (try ~ catch문)

### 개념

예외 처리(Exception Handling)란, 프로그램 실행 시 발생할 수 있는 `예외에 대비한 코드를 작성하는 것`을 말한다. 프로그램의 비정상 종료를 막고, 정상적인 실행상태를 유지하기 위해 진행한다. 처리되지 못한 예외는 프로그램을 비정상적으로 종료시키며, JVM의 예외 처리기(UncaughtExceptionHandler)는 예외의 원인을 콘솔에 출력한다.

### try ~ catch문

Java에서는 `try ~ catch문`이라는 예외 처리 관련 문법을 제공한다.

```java
try {
    // 예외가 발생할 가능성이 있는 동작
} catch (Exception1 e) {
    // Exception1이 발생한 경우의 실행하는 동작
} catch (Exception2 e) {
    // Exception2이 발생한 경우의 실행하는 동작
} catch (Exception3 e) {
    // Exception3이 발생한 경우의 실행하는 동작
}
```

- catch 블록은 두 부분으로 나누어진다.
    - `괄호()`내에는 처리하고자 하는 예외와 같은 타입의 참조변수 하나를 선언한다.
    - `블록{}`은 괄호()내에 처리된 예외가 발생한 경우 실행할 동작을 작성한다.
- 발생한 예외의 종류와 일치하는 단 한 개의 catch 블록만 수행된다.
- 예외가 발생한 경우와 발생하지 않은 경우의 흐름은 아래와 같다.
    - `예외가 발생한 경우`
        1. 발생한 예외와 일치하는 catch 블록이 있는지 확인한다.
        2. 일치하는 catch 블록을 찾으면, 해당 블록의 동작을 수행하고 전체 try ~ catch문을 빠져나가 그 다음 동작을 계속 수행한다.
        3. 만약 일치하는 catch 블록이 없다면 예외는 처리되지 않는다.
    - `예외가 발생하지 않은 경우`
        1. catch 블록을 거치지 않고 전체 try ~ catch문을 빠져나가 이후 동작을 수행한다.

### 예외처리 순서

```java
public class Main {

    public static void main(String[] args) {
        System.out.println("try~catch문 전의 동작은 실행된다.");

        try {
            System.out.println("예외 발생 전의 동작은 실행된다.");
            System.out.println(0 / 0); // ArithmeticException 발생!!
            System.out.println("예외 발생 후의 동작은 실행되지 않는다.");
        } catch (ArithmeticException e) {
            System.out.println("ArithmeticException catch 블록은 실행된다.");
        } catch (Exception e) {
            System.out.println("Exception catch 블록은 실행되지 않는다.");
        }

        System.out.println("try~catch문 후의 동작은 실행된다.");
    }
}
```

```
try~catch문 전의 동작은 실행된다.
예외 발생 전의 동작은 실행된다.
ArithmeticException catch 블록은 실행된다.
try~catch문 후의 동작은 실행된다.
```

1. try ~ catch문 이전의 동작을 수행한다.
2. try문 안에서 예외가 발생하면, 발생한 예외 클래스의 인스턴스가 생성된다.
3. 맨 위 catch 블록부터 차례로 내려가면서, 생성된 예외 인스턴스가 `괄호()`내에 선언된 예외 클래스에 해당하는지 `isinstanceof` 연산자를 통해 검사한다.
    - 모든 예외 클래스는 Exception 클래스의 자손이므로, catch의 `괄호()`에 Exception 클래스 타입을 선언하면 어떤 종류의 예외가 발생해도 해당 catch 블록에 의해 처리된다.
    - 단, 여러 catch 블록에서 처리 될 수 있는 예외는 `가장 먼저 만나는 catch 블록에서 먼저 처리`되므로, 여기에서는 Exception이 아니라 ArithmeticException 블록에서 처리된다.
4. 검사 결과가 true이면 catch의 `블록{}`에 있는 동작을 모두 수행하고 try ~ catch문을 탈출한다.
5. try ~ catch문 이후의 동작을 수행한다.

### 예외 메시지 확인하기

예외가 발생했을 때, 생성되는 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨있다.

```java
public class Main {

    public static void main(String[] args) {
        System.out.println("try~catch문 전의 동작은 실행된다.");

        try {
            System.out.println("예외 발생 전의 동작은 실행된다.");
            System.out.println(0 / 0); // ArithmeticException 발생!!
            System.out.println("예외 발생 후의 동작은 실행되지 않는다.");
        } catch (ArithmeticException e) {
            System.out.println("ArithmeticException : " + e.getMessage());
        } catch (Exception e) {
            System.out.println("Exception : " + e.getMessage());
        }

        System.out.println("try~catch문 후의 동작은 실행된다.");
    }
}
```

```
try~catch문 전의 동작은 실행된다.
예외 발생 전의 동작은 실행된다.
ArithmeticException : / by zero
try~catch문 후의 동작은 실행된다.
```

- 예외가 발생했을 때, 생성되는 예외 인스턴스에는 발생한 예외에 관한 정보가 담겨있다.
    - `printStackTrace()` : 스택 영역에 있던 메서드의 정보와 예외 메시지를 출력한다.
    - `getMessage()` : 예외 인스턴스에 저장된 메시지를 반환한다.

### 멀티 catch 블록

JDK 1.7부터 여러 catch블록을 `|` 기호를 이용해 하나의 catch 블록으로 합칠 수 있다.

```java
try {
    ...
} catch (Exception1 | Exception2 e) {
    e.printStackTrace();
}
```

- 연결할 수 있는 예외 클래스의 개수에는 제한이 없다.
- 단, 연결된 예외 클래스가 상속 관계에 있다면 컴파일 에러가 발생한다. (다형성에 의해 동일하다고 인식)
- 예외 인스턴스 e가 정확히 어떤 타입의 예외 클래스인지 모르기 때문에, **멀티 catch 블록에서는 e의 메서드를 사용할 때, 나열된 예외 클래스들의 공통 조상에 선언된 메서드만 사용할 수 있다.**

---

## 예외 발생시키기 (throw)

의도적으로 예외를 발생시키는 경우에는 `throw` 키워드를 사용한다.

```java
try {
    Exception e = new Exception("예외 발생");
    throw e;
} catch (Exception e) {
    System.out.println("Exception : " + e.getMessage());
}
```

```
Exception : 예외 발생
```

1. 연산자 new를 이용해서 발생시키려는 예외 클래스의 인스턴스를 만든다.
    - 생성자에 문자열을 넣어주면, 해당 문자열이 예외 메시지로 저장된다.
    - 해당 메시지는 `getMessage()` 메서드를 통해 얻을 수 있다.
2. `throw` 키워드를 이용해서 예외를 발생시킨다.

보통 조건문을 이용한 `값의 유효성 검증`을 위해 throw 키워드를 사용한다.

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("숫자를 입력하세요 : ");
        int number = scanner.nextInt();

        // 유효성 검증 (음수를 입력한 경우 예외 발생)
        if (number < 0) {
            throw new RuntimeException("0이상의 정수만 입력 가능합니다.");
        }

        System.out.println("입력하신 숫자 : " + number);
    }
}
```

```
>>> 숫자를 입력하세요 : -1
Exception in thread "main" java.lang.RuntimeException: 0이상의 정수만 입력 가능합니다.
	at com.test.practice.Main.main(Main.java:15)
```

- 특정 데이터의 값이 정상적이지 않은(=유효하지 않은) 경우 예외를 발생시킨다.
- 예외가 발생하면 프로그램 자체가 종료되므로, 정상적이지 않은 상태에서 로직이 더 진행되는 경우를 방지할 수 있다.

---

## Checked vs Unchecked

위에서 예외 클래스는 RuntimeException과 그 외로 나눌 수 있다고 하였는데, 이를 조금 더 공식적으로는 아래와 같이 나눌 수 있다.

### Checked 예외

- 컴파일러가 예외처리를 확인하는 예외 (ex. RuntimeException을 제외한 예외)
- 반드시 try ~ catch문을 이용해서 발생할 가능성이 있는 예외에 대한 처리를 해야 한다.
- 예외 처리를 해놓지 않으면 컴파일 단계에서 에러를 발생시킨다. (실행 자체가 안됨)

### Unchecked 예외

- 컴파일러가 예외처리를 확인하지 않는 예외 (ex. RuntimeException)
    
- checked 예외와는 달리, try ~ catch문을 통한 예외처리를 강제하지 않는다.
    
- 런타임에서 발생하는 예외들은 프로그래머의 실수에 의해서 일어나기 때문에, 실수가 없다면 일어나지 않을 예외이다. 따라서 예외가 발생할 수도, 하지 않을 수도 있으므로 예외 처리를 강제하지는 않는다.
    
    ```java
    try {
        int[] arr = {1, 2, 3, 4, 5};
        System.out.println(arr[0]);
    } catch (ArrayIndexOutOfBoundsException e) {
        e.printStackTrace();
    }
    ```
    
    만약 RuntimeException에 대해 예외 처리를 강제한다면, 프로그래머들이 흔히 작성하는 배열에 대한 인덱스 접근도 위와 같이 예외 처리 해주어야 할 것이다. 왜냐하면 `arr[5]`와 같이 범위를 벗어난 인덱스 참조가 일어날 수도 있기 때문이다. 이는 매우 불편하다.
    

---

## 메서드에 예외 선언하기

예외가 발생했을 때, try ~ catch문으로 직접 처리하는 방법 대신 `예외 처리의 책임을 메서드의 바깥으로 넘겨주는` 방법도 존재한다.

```java
public void method() throws Exception1, Exception2, ... {
    ...
}
```

- 메서드의 선언부에 `throws` 키워드를 사용하여, 발생할 가능성이 있는 예외에 대한 처리를 강제할 수 있다.
- 메서드를 사용하려는 사람이 메서드의 선언부를 보았을 때, 이 메서드를 사용하기 위해서는 어떠한 예외들이 처리되어야 하는지 알 수 있다.
- **메서드에 예외를 선언할 때 일반적으로 RuntimeException 클래스들은 적지 않는다. 보통은 반드시 처리해야 하는 예외들만 선언한다. (Checked 예외를 주로 선언)**
- throws를 통한 예외 선언은, 정확히 말하면 예외를 처리하는 것이 아니라 `해당 메서드를 호출한 부분에 예외를 넘겨주는 것`이다. 따라서 어느 한 곳에서는 반드시 try ~ catch문을 이용해 예외처리를 해야한다.

---

## finally 블록

`finally 블록`은 예외의 발생여부에 관계없이 실행되어야할 코드를 포함시킬 목적으로 사용한다.

```java
try {
    // 예외가 발생할 가능성이 있는 동작
} catch (Exception e) {
    // 예외가 발생한 경우의 실행하는 동작
} finally {
    // 예외 발생여부에 관계없이 항상 실행하는 동작
}
```

try 블록에 return이 있다면, finally 블록의 동작들이 먼저 실행된 후 return 된다.

```java
public class Main {

    public static void main(String[] args) {
        String result = method();
        System.out.println(result);
    }

    private static String method() {
        try {
            System.out.println("method가 호출");
            return "try 블록 안에서 return";
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            System.out.println("finally 블록 실행");
        }

        return "try 블록 바깥에서 return";
    }
}
```

```
method가 호출
finally 블록 실행
try 블록 안에서 return
```

---

## 사용자 정의 예외 만들기

Java 표준 예외 클래스 대신, Exception 혹은 RuntimeException 클래스를 상속받아 `사용자 정의 예외 클래스`를 직접 만들 수 있다. `커스텀 예외 클래스`라고도 한다.

```java
public class CustomException extends RuntimeException {

    CustomException(String message) {
        super(message);
    }
}
```

사용자 정의 예외 클래스를 만들면, 예외를 발생시킬 때 내가 필요한 값을 원하는대로 기록할 수 있다는 장점이 있다. 예를 들어, 아래는 예외를 발생시킬 때 별도의 에러 코드를 부여하기 위한 사용자 정의 예외 클래스를 선언하는 코드이다.

```java
public class CustomException extends RuntimeException {

    private final int errorCode; // 에러 코드
    
    CustomException(String message, int errorCode) {
        super(message);
        this.errorCode = errorCode;
    }
    
    CustomException(String message) {
        this(message, 400); // 예외 메시지만 입력되는 경우, 자동으로 400 에러 코드로 부여
    }
    
    public int getErrorCode() {
        return this.errorCode;
    }
}
```

- 예외가 발생하면 `getMessage()`를 통해서는 예외 메시지를, `getErrorCode()`를 통해서는 에러 코드를 얻어서 예외 상황에 대한 정보를 더 자세하게 제공할 수 있다.
- 요즘은 checked 예외보다는 unchecked 예외 클래스를 상속받아서 사용자 정의 예외 클래스를 만드는 편이다.