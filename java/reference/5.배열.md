
## 배열(Array)이란?

### 개념

배열(Array)은 동일한 자료형의 여러 변수를 하나로 묶을 수 있는 자료구조이다.

### 선언 및 초기화

1. **배열은 아래와 같이 두 가지 방법으로 선언할 수 있다.**
    
    ```java
    타입[] 변수명;
    타입 변수명[];
    ```
    
    ```java
    int[] numbers;
    int numbers[];
    ```
    
    - 배열을 선언할 때는 `대괄호([])`를 사용한다.
    - 보통은 전자(`int[] numbers;`)의 방법을 주로 사용한다. 후자는 C언어 스타일의 배열 선언이다.
2. **배열을 선언했다면 new 키워드를 이용해 값을 초기화 할 수 있다.**
    
    ```java
    변수명 = new 타입[길이];
    ```
    
    ```java
    int[] numbers; // 선언
    numbers = new int[5]; // 초기화
    ```
    
    - 대괄호 안에 길이를 작성하여 원하는 길이로 배열을 초기화 할 수 있다.
    - 단순히 길이만 지정하고 초기값을 부여하지 않으면, 배열의 원소들은 기본값으로 초기화된다.
    - 배열은 이처럼 길이를 초기에 지정하기 때문에, `한번 생성하면 이후 길이를 늘리거나 줄일 수 없다.` 만약 길이를 변경하고 싶다면, 변경한 길이의 새로운 배열을 생성해야 한다.
    
    `Arrays.toString(배열)`을 이용하면 배열의 모습을 출력할 수 있다. numbers를 출력해보자.
    
    ```java
    import java.util.Arrays;
    
    public class Main {
    
        public static void main(String[] args) {
            int[] numbers; // 선언
            numbers = new int[5]; // 초기화
    
            System.out.println(Arrays.toString(numbers)); // 배열 출력
        }
    }
    ```
    
    ```
    [0, 0, 0, 0, 0]
    ```
    
    - `Arrays.toString()`을 사용하기 위해서는 `import java.util.Arrays;`을 작성해야 한다.
    - 정수 배열의 원소는 기본값이 `0`이므로, 원소들이 해당 기본값으로 초기화 되었음을 알 수 있다.
3. **선언과 초기화를 한 번에 할 수 있다.**
    
    ```java
    타입[] 변수명 = new 타입[길이];
    ```
    
    ```java
    int[] numbers = new int[5]; // 선언과 동시에 기본값으로 초기화
    ```
    
4. **기본값이 아닌 원하는 값으로도 초기화 할 수 있다.**
    
    ```java
    타입[] 변수명 = new 타입[] {원소};
    타입[] 변수명 = {원소};
    ```
    
    ```java
    int[] numbers = new int[] {10, 20, 30, 40, 50}; // 선언과 동시에 원하는 값으로 초기화
    int[] numbers = {10, 20, 30, 40, 50}; // 이때는 뒤의 타입 생략 가능
    ```
    
    - 이때는 원하는 값으로 넣은 만큼 배열의 길이가 되기 때문에, 따로 대괄호 안에 길이를 넣지 않는다.
    - 또한, 원하는 값으로 초기화 할 때에는 `new 타입[]` 을 생략해도 된다. 어차피 변수명을 작성하는 곳에서 타입을 적기 때문에 추론이 가능하다.
    
    단, 선언과 초기화를 따로 할 때는 `new 타입[]` 을 생략할 수 없다.
    
    ```java
    int[] numbers; // 선언
    numbers = {10, 20, 30, 40, 50}; // 문법 오류!
    ```
    
5. **[참고] 자료형에 따른 배열 원소의 기본값은 아래와 같다.**
    
| **자료형**     | **설명**            | **배열 원소의 기본값**              |
| ----------- | ----------------- | --------------------------- |
| **byte**    | 8비트 정수            | `0`                         |
| **short**   | 16비트 정수           | `0`                         |
| **char**    | 16비트 문자 (유니코드)    | `'\u0000'` (null character) |
| **int**     | 32비트 정수           | `0`                         |
| **long**    | 64비트 정수           | `0`                         |
| **float**   | 32비트 부동소수점 숫자     | `0.0f`                      |
| **double**  | 64비트 부동소수점 숫자     | `0.0`                       |
| **boolean** | 1비트 참/거짓(boolean) | `false`                     |
| **String**  | 문자열 (참조형)         | `null`                      |

```java
import java.util.Arrays;

public class Main {

    public static void main(String[] args) {
        byte[] byteArray = new byte[5];
        short[] shortArray = new short[5];
        char[] charArray = new char[5];
        int[] intArray = new int[5];
        long[] longArray = new long[5];
        float[] floatArray = new float[5];
        double[] doubleArray = new double[5];
        boolean[] booleanArray = new boolean[5];
        String[] stringArray = new String[5];

        System.out.println("byteArray : " + Arrays.toString(byteArray));
        System.out.println("shortArray : " + Arrays.toString(shortArray));
        System.out.println("charArray : " + Arrays.toString(charArray));
        System.out.println("intArray : " + Arrays.toString(intArray));
        System.out.println("longArray : " + Arrays.toString(longArray));
        System.out.println("floatArray : " + Arrays.toString(floatArray));
        System.out.println("doubleArray : " + Arrays.toString(doubleArray));
        System.out.println("booleanArray : " + Arrays.toString(booleanArray));
        System.out.println("stringArray : " + Arrays.toString(stringArray));
    }
}
```
    
```
byteArray : [0, 0, 0, 0, 0]
shortArray : [0, 0, 0, 0, 0]
charArray : [, , , , ]
intArray : [0, 0, 0, 0, 0]
longArray : [0, 0, 0, 0, 0]
floatArray : [0.0, 0.0, 0.0, 0.0, 0.0]
doubleArray : [0.0, 0.0, 0.0, 0.0, 0.0]
booleanArray : [false, false, false, false, false]
stringArray : [null, null, null, null, null]
```
    

### 길이

배열의 길이를 알기 위해서는 `.length`를 이용하면 된다.

```java
public class Main {

    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50};
        
        System.out.println(numbers.length);
    }
}
```

```
5
```

- 이후에 나올 반복문과 배열을 함께 사용하는 과정에서 `.length`가 유용하게 사용되므로 꼭 숙지한다.

### 인덱스(Index)

지금까지는 하나의 묶음으로써만 배열을 다뤄보았다. 하지만 실제로는 배열의 원소들을 각각 다루는 작업을 더욱 많이 하게 된다. `인덱스(Index)`라는 개념을 이용하면 배열의 원소에 개별적으로 접근할 수 있다.

인덱스는 목차라는 의미이다. 그래서 배열에서 각각의 원소가 어느 위치에 있는지를 알려주는 목차라고 생각하면 된다. 인덱스는 `0에서 시작`하여 순차적으로 증가한다.

- 가장 앞에 있는 원소는 배열의 0번째 인덱스이다. (컴퓨터는 숫자를 0부터 센다)
- 그 다음에 있는 원소는 배열의 1번째 인덱스이다.
- …(생략)
- 가장 뒤에 있는 원소는 배열의 (길이 - 1)번째 인덱스이다.

이러한 특성으로 인해, 인덱스를 배열의 원소를 조회하거나 수정하는 목적으로 자주 사용한다.

1. **배열의 원소 조회하기**
    
    ```java
    public class Main {
    
        public static void main(String[] args) {
            int[] numbers = {10, 20, 30, 40, 50}; // 길이 5
    
            System.out.println(numbers[0]); // 가장 앞에 있는 원소
            System.out.println(numbers[1]);
            System.out.println(numbers[2]);
            System.out.println(numbers[3]);
            System.out.println(numbers[4]); // 가장 뒤에 있는 원소
        }
    }
    ```
    
    ```
    10
    20
    30
    40
    50
    ```
    
    가장 뒤에 있는 원소는 아래와 같은 방법으로도 접근할 수 있다. 자주 사용하는 방법이니 기억해두자.
    
    ```java
    public class Main {
    
        public static void main(String[] args) {
            int[] numbers = {10, 20, 30, 40, 50};
    
            System.out.println(numbers[numbers.length - 1]);
        }
    }
    ```
    
    ```
    50
    ```
    
2. **배열의 원소 수정하기**
    
    ```java
    import java.util.Arrays;
    
    public class Main {
    
        public static void main(String[] args) {
            int[] numbers = {10, 20, 30, 40, 50};
            numbers[0] = -1; // 0번째 원소를 -1로 수정 (10 -> -1)
    
            System.out.println(Arrays.toString(numbers));
        }
    }
    ```
    
    ```
    [-1, 20, 30, 40, 50]
    ```
    
    - 인덱스를 통해 단순 조회 뿐만 아니라, 원소의 값을 수정할 수 있다.
    - 수정이라고 해서 뭔가 특별한 것은 아니다. 변수에 값을 재할당 하는 것과 같은 원리라고 보면 된다.

---

## 배열의 활용

### 배열의 반복

```java
public class Main {

    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50};

        for (int i = 0; i < numbers.length; i++) {
            System.out.println(numbers[i]);
        }
    }
}
```

```
10
20
30
40
50
```

- 변수 `i`는 `numbers` 배열의 인덱스로써, 0부터 (길이-1)번째에 해당하는 모든 원소를 출력한다.

반복문과 배열을 함께 사용하면 다양한 방면으로 활용 가능하다. 아래 네 가지 로직은 앞으로도 많이 사용하게 될 것들이므로 잘 숙지하자.

1. **배열의 길이 구하기**
    
    ```java
    public class Main {
    
        public static void main(String[] args) {
            int[] numbers = {10, 20, 30, 40, 50};
            int length = 0; // 길이
    
            for (int i = 0; i < numbers.length; i++) {
                length += 1;
            }
    
            System.out.println(length);
        }
    }
    ```
    
    ```
    5
    ```
    
2. **배열의 최솟값 구하기**
    
    ```java
    public class Main {
    
        public static void main(String[] args) {
            int[] numbers = {30, 10, 50, 25, 100};
            int minNumber = 9999999; // 최솟값 (일단 매우 큰 수로 초기화)
    
            for (int i = 0; i < numbers.length; i++) {
                if (numbers[i] < minNumber) { // 만약 배열의 원소가 최솟값보다 작으면
                    minNumber = numbers[i]; // 최솟값을 갱신
                }
            }
    
            System.out.println(minNumber);
        }
    }
    ```
    
    ```
    10
    ```
    
3. **배열의 최댓값 구하기**
    
    ```java
    public class Main {
    
        public static void main(String[] args) {
            int[] numbers = {30, 10, 50, 25, 100};
            int maxNumber = -9999999; // 최댓값 (일단 매우 작은 수로 초기화)
    
            for (int i = 0; i < numbers.length; i++) {
                if (numbers[i] > maxNumber) { // 만약 배열의 원소가 최댓값보다 크면
                    maxNumber = numbers[i]; // 최댓값을 갱신
                }
            }
    
            System.out.println(maxNumber);
        }
    }
    ```
    
    ```
    100
    ```
    
4. **배열의 총합 구하기**
    
    ```java
    public class Main {
    
        public static void main(String[] args) {
            int[] numbers = {10, 20, 30, 40, 50};
            int total = 0; // 총합
    
            for (int i = 0; i < numbers.length; i++) {
                total += numbers[i]; // 배열 원소들을 차곡차곡 더함
            }
    
            System.out.println(total);
        }
    }
    ```
    
    ```
    150
    ```
    

### 향상된 for문

Java에서는 배열과 같이 여러 값을 담은 자료형에서 반복문을 사용할 때, 더욱 편리하게 사용할 수 있도록 `향상된(enhanced) for문`이라는 기능을 제공한다.

```java
for (타입 변수명 : 배열) {
    반복하는 동안 실행되는 동작 1
    반복하는 동안 실행되는 동작 2
    ...
}
```

1. 기존 for문과 달리 초기화, 조건식, 증감식이 존재하지 않는다.
2. `타입 변수명`부분은 배열에서 원소를 하나씩 꺼내서 임시로 담는 변수를 의미한다.
3. 따라서 해당 변수는 향상된 for문 블록 안에서만 사용 가능하다.

예시를 보면 더욱 쉽게 이해할 수 있다.

```java
public class Main {

    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50};

        for (int number : numbers) {
            System.out.println(number); // 임시 변수 활용
        }
    }
}
```

```
10
20
30
40
50
```

- `int number : numbers` 부분은 결국 numbers에서 원소를 하나씩 꺼내서 number라는 임시 변수에 할당한다는 의미이다. 그리고 number는 for문 블록 안에서만 사용할 수 있다.
- 초기화, 조건식, 증감식이 없고 `numbers[i]`와 같은 형태로 작성하지 않기 때문에, 훨씬 의미가 명확하고 가독성이 있다는 장점이 있다.
- 만약 배열에 반복문을 사용할 때 인덱스 변수를 사용하지 않아도 되는 경우라면, 향상된 for문을 적극적으로 사용하자.

### 배열의 정렬

배열의 원소를 오름차순으로 정렬할 때는 `Arrays.sort(배열)`를 이용할 수 있다.

```java
import java.util.Arrays;

public class Main {

    public static void main(String[] args) {
        int[] numbers = {50, 30, 10, 40, 20};

        Arrays.sort(numbers); // 오름차순 정렬

        System.out.println(Arrays.toString(numbers));
    }
}
```

```
[10, 20, 30, 40, 50]
```

- numbers 배열의 원본 자체가 오름차순으로 정렬됨에 주의한다.