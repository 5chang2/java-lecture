# 메서드

## 메서드(Method)란?

> 메서드란 클래스 내부에 정의된 함수이다.

## 메서드 사용하기

### 선언 및 호출

메서드는 다음과 같은 문법으로 `선언`할 수 있다.

```java
public class 클래스명 {

		public 반환타입 메서드명(매개변수) {
				메서드 내부에서 실행하는 동작 1;
				메서드 내부에서 실행하는 동작 2;
				...
		}
}
```

- 메서드는 기본적으로 클래스의 멤버이므로 클래스 내부에 작성되어야 한다.
- 메서드명은 변수명과 마찬가지로 `카멜 케이스`를 따른다.
- 메서드는 객체가 어떤 동작을 할 수 있는지를 정의한 것이므로, 메서드명은 `동사`로 시작하는 것을 권장한다. (ex. getBigger, setName, calculateArea 등)
- 메서드명은 변수명, 클래스명과 마찬가지로 예약어로 작성할 수 없다.

메서드에 특정 값을 전달하여 결과를 반환하도록 하는 것을 메서드를 `호출(call)`한다고 말한다.

호출은 `메서드명(인자)`를 통해 할 수 있다.

```java
public class Main {

    public static void main(String[] args) {
        int bigger = getBigger(1, 2); // 메서드 호출
        System.out.println(bigger);
    }

    // 두 개의 숫자 중 큰 숫자를 반환하는 메서드
    public static int getBigger(int number1, int number2) {
        if (number1 > number2) {
            return number1;
        } else {
            return number2;
        }
    }
}
```

### 매개변수, 인자, 반환값

1. `매개변수(Parameters)`란, 메서드로 전달된 값이 할당되는 변수를 말한다. (이후 메서드 내에서 사용)
2. `인자(Arguments)`란, 메서드를 호출 할 때 실제로 전달하는 값을 말한다.
    - 매개변수와 인자는 엄연히 다른 개념이긴 하지만, 암묵적으로 혼용해서 쓰기도 한다.
3. `반환값`이란, 메서드 안에서 일련의 로직을 통해 계산된 결과값을 말한다.
    - 반환값은 `return`이라는 키워드를 통해 지정할 수 있다.
    - 메서드를 선언할 때 작성하는 반환 타입에 맞는 값만 반환할 수 있다.

```java
public class Main {

    public static void main(String[] args) {
		    // 인자 1과 2를 전달하며 메서드를 호출하고, 그 반환값을 bigger에 할당
        int bigger = getBigger(1, 2);
        System.out.println(bigger);
    }

    // 위에서 전달한 인자 1, 2는 각각 number1과 number2라는 매개변수에 할당된다.
    // 반환 타입이 int이므로 int 값만 반환할 수 있다.
    public static int getBigger(int number1, int number2) {
        if (number1 > number2) {
            return number1; // number1이 큰 경우, 이를 반환
        } else {
            return number2; // number2가 큰 경우, 이를 반환
        }
    }
}
```

### 지역 변수와 스코프

메서드 안에 선언된 변수들은 해당 메서드에서만 사용할 수 있다. 이를 `지역 변수(Local Variable)`라 한다.

```java
public class Main {

    public static void main(String[] args) {
        int number = 10; // main 메서드의 지역 변수

        System.out.println("main 메서드 안의 number : " + number); // temp 호출 전
        temp(); // temp 호출
        System.out.println("main 메서드 안의 number : " + number); // temp 호출 후
    }

    public static void temp() {
        int number = 3; // temp 메서드의 지역 변수
        System.out.println("temp 메서드 안의 number : " + number);
    }
}
```

```
main 메서드 안의 number : 10
temp 메서드 안의 number : 3
main 메서드 안의 number : 10
```

- main 메서드에서 number에 10이 먼저 할당된 후 temp 메서드가 호출되므로, main 메서드의 number가 3으로 바뀐다고 생각할 수 있지만 그렇지 않다.
- main 메서드와 temp 메서드에 있는 변수 number는 이름은 같지만 서로 다른 `스코프(범위, scope)`에 속한 지역 변수이기 때문이다.

**변수는 선언된 위치에 따라 서로 다른 영향 범위(스코프)를 가진다.**

- `클래스 변수` : 클래스 스코프를 가지므로, 변수가 변경되면 해당 클래스의 모든 인스턴스가 영향을 받는다.
- `인스턴스 변수` : 인스턴스 스코프를 가지므로, 변수가 변경되면 해당 인스턴스의 모든 메서드가 영향을 받는다. 다른 인스턴스는 영향을 받지 않는다.
- `지역 변수` : 메서드 스코프를 가지므로, 변수가 변경되면 해당 메서드만 영향을 받는다. 다른 메서드는 영향을 받지 않는다.

클래스 변수, 인스턴스 변수와는 달리 **지역 변수는 자료형에 따른 기본값으로 초기화되지 않는다**.

지역 변수에 값을 초기화 하지 않고 미리 선언만 하는 것은 가능하다.

하지만 이후 **지역 변수를 사용하기 위해서는 반드시 값을 명시적으로 초기화 하는 과정이 필요**하다.

```java
public class Main {

    public static void main(String[] args) {
        int number; // 미리 선언은 가능
        System.out.println(number); // 하지만 사용하기 위해서는 명시적인 초기화가 필요함
    }
}
```

```
java: variable number might not have been initialized
```

- 지역 변수 number를 선언만 하는 것은 가능하나, 이후 출력을 위해 사용하려면 number에 값을 초기화 하는 과정이 있었어야 한다. 하지만 초기화를 하지 않았으므로 `컴파일 에러`가 발생한다.

---

## 메서드의 다양한 형태

메서드의 매개변수와 반환값은 유동적으로 존재한다. 둘 다 있거나 없을 수도 있고, 하나만 있을 수도 있다.

### 매개변수 O, 반환값 O

데이터를 넘겨받아 처리한 결과를 반환하는 가장 기본적인 경우에 해당한다.

```java
public class Main {

    public static void main(String[] args) {
        int result = add(1, 2); // 반환값을 별도의 변수에 할당
        System.out.println(result);
    }

		// 매개변수와 반환값이 모두 존재함
    public static int add(int x, int y) {
        return x + y;
    }
}
```

```
3
```

### 매개변수 O, 반환값 X

데이터를 넘겨받아 처리하지만 결과를 반환할 필요가 없는 경우에 해당한다.

```java
public class Main {

    public static void main(String[] args) {
        hello("kyle"); // 반환값이 존재하지 않으므로, 별도의 변수에 할당하지 않음
        hello("alex");
    }

		// 매개변수는 존재하나, 반환값은 존재하지 않음
    public static void hello(String name) {
        System.out.println("Hello! " + name);
    }
}
```

```
Hello! kyle
Hello! alex
```

- 반환값이 존재하지 않을 때는 메서드의 반환 타입을 `void(비어있는)`로 설정한다.

### 매개변수 X, 반환값 O

데이터를 넘겨받지 않고 항상 정해진대로 처리한 결과를 반환하는 경우에 해당한다.

```java
import java.util.Arrays;

public class Main {

    public static void main(String[] args) {
        int[] evenNumbers = getEvenNumbersUnderTen(); // 반환값을 별도의 변수에 할당

        System.out.println(Arrays.toString(evenNumbers));
    }

		// 매개변수는 존재하지 않고, 반환값만 존재함
    public static int[] getEvenNumbersUnderTen() {
        int[] evenNumbers = {2, 4, 6, 8};

        return evenNumbers;
    }
}
```

```
[2, 4, 6, 8]
```

### 매개변수 X, 반환값 X

데이터를 넘겨받지 않고 항상 정해진대로 처리하면서, 결과를 반환할 필요가 없는 경우에 해당한다.

```java
public class Main {

    public static void main(String[] args) {
        welcome();
    }

		// 매개변수와 반환값이 모두 존재하지 않음
    public static void welcome() {
        System.out.println("Welcome to Java world!");
    }
}
```

```
Welcome to Java world!
```

---

## 클래스 메서드와 인스턴스 메서드

클래스의 멤버에는 변수, 생성자, 메서드가 있다.
멤버 변수에도 클래스 변수와 인스턴스 변수가 있는 것처럼, 메서드에도 클래스 메서드와 인스턴스 메서드가 있다.

### 클래스 메서드(=정적 메서드)

클래스 메서드는 `static`이라는 키워드가 붙은 메서드로, 인스턴스가 아닌 **클래스 자체에 속해 있는 메서드**를 의미한다.

클래스 메서드의 대표적인 `특징`은 아래와 같다.

1. 별도의 인스턴스를 생성하지 않아도 사용할 수 있다.
2. 클래스 메서드에서는 인스턴스 변수를 사용하거나, 인스턴스 메서드를 호출할 수 없다.

### 인스턴스 메서드

인스턴스 메서드는 **클래스의 인스턴스에 속해있는 메서드**를 의미하며, 보통 인스턴스 변수와 관련한 작업을 수행한다. 따라서 클래스 메서드와는 달리 반드시 인스턴스를 생성해야만 사용할 수 있다.

### 클래스 메서드와 인스턴스 메서드의 예시

```java
public class Rectangle {

    // 클래스 변수
    public static String color = "red";

    // 인스턴스 변수
    public int width;
    public int height;

    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }

    // 클래스 메서드
    public static void printColor() {
        System.out.println("사각형의 색깔 : " + color);
    }

    // 인스턴스 메서드
    public void printArea() {
        int area = this.width * this.height;
        System.out.println("사각형의 면적 : " + area);
    }
}
```

```java
public class Main {

    public static void main(String[] args) {
        Rectangle.printColor(); // 클래스 메서드 호출

        Rectangle rectangle = new Rectangle(10, 5);
        rectangle.printArea(); // 인스턴스 메서드 호출
    }
}
```

```
사각형의 색깔 : red
사각형의 면적 : 50
```

- 클래스 메서드는 `클래스명.메서드명()`으로 호출할 수 있다. 별도의 인스턴스를 생성하지 않아도 된다.
- 인스턴스 메서드는 `인스턴스명.메서드명()`으로 호출할 수 있다. 반드시 인스턴스를 생성해야 한다.

### 주의사항

클래스 메서드는 인스턴스 여부와 상관없이 처음 클래스가 로딩될 때, 메모리의 static 영역에 고정된다.

따라서 클래스 메서드는 인스턴스를 생성하지 않더라도 사용할 수 있으므로, **클래스 메서드에서는 인스턴스 변수를 사용하거나 인스턴스 메서드를 호출할 수 없다는 것**을 항상 주의해야 한다.

아직 존재하지도 않는 인스턴스의 변수나 메서드를 당연히 사용할 수 없기 때문이다.

예를 들어 만약 사각형 클래스를 아래와 같이 작성했다고 가정해보자.

```java
public class Rectangle {

    // 클래스 변수
    public static String color = "red";

    // 인스턴스 변수
    public int width;
    public int height;

    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }

    // 클래스 메서드에서 인스턴스 변수를 사용
    public static void printInfomation() {
        System.out.println("사각형의 색깔 : " + color);

        int area = this.width * this.height; // 문법 오류!!!
        System.out.println("사각형의 면적 : " + area);
    }
}
```

```java
public class Main {

    public static void main(String[] args) {
        Rectangle.printInfomation(); // 클래스 메서드 호출
    }
}
```

```
java: non-static variable this cannot be referenced from a static context
```

- 클래스 메서드는 Rectangle이라는 클래스가 처음 로딩될 때부터 메모리 영역에 적재되므로, 아직 생성되지도 않은 인스턴스의 변수를 사용할 수 없다. 따라서 에러가 발생한다.

---

## 메서드 시그니처와 오버로딩

### 메서드 시그니처

메서드 시그니처(Signature)란, `메서드의 이름, 매개변수의 타입, 매개변수의 개수`를 의미한다.

시그니처란 `서명`이라는 의미이므로, 메서드 시그니처는 해당 **메서드를 식별할 수 있는 고유의 서명**이라는 의미이다. 따라서, 메서드 시그니처에 해당하는 요소들이 모두 같으면 동일한 메서드라고 취급한다. 반대로 해당 요소들 중 하나라도 같지 않으면 다른 메서드라고 취급한다.

### 메서드 오버로딩

메서드 오버로딩(Overloading)이란, **하나의 클래스에서 이름이 같은 메서드를 여러 개 선언**하는 것을 말한다.

앞서, 동일한 메서드란 메서드의 이름만 같은 것이 아니라, 메서드 시그니처의 요소들이 모두 같은 메서드를 의미한다고 하였다. 따라서 이름은 같아도 매개변수의 타입, 개수 중에 다른 것이 있다면 다른 메서드로 취급하므로, 같은 이름의 메서드를 여러 개 선언할 수 있다.

예를 들면, 두 수를 더한 값을 반환하는 add 메서드가 오버로딩을 통해 여러 타입을 지원하도록 할 수 있다.

```java
public class Main {

    public static void main(String[] args) {
        int intResult = add(1, 2);
        long longResult = add(1L, 2L);
        float floatResult = add(1.0f, 2.0f);
        double doubleResult = add(1.0, 2.0);

        System.out.println("intResult : " + intResult);
        System.out.println("longResult : " + longResult);
        System.out.println("floatResult : " + floatResult);
        System.out.println("doubleResult : " + doubleResult);
    }

    public static int add(int number1, int number2) {
        return number1 + number2;
    }

    public static long add(long number1, long number2) {
        return number1 + number2;
    }

    public static float add(float number1, float number2) {
        return number1 + number2;
    }

    public static double add(double number1, double number2) {
        return number1 + number2;
    }
}
```

```
intResult : 3
longResult : 3
floatResult : 3.0
doubleResult : 3.0
```

- int, long, float, double 타입의 수를 더하는 메서드들의 이름이 모두 add로 같다. 하지만 에러가 발생하지 않는데, 그 이유는 이름이 같아도 매개변수의 타입이 다르므로 엄연히 메서드 시그니처가 달라 다른 메서드로 취급하기 때문이다.
- **반환 타입만 달라도 오버로딩이 가능하다고 생각하는 경우가 있는데, 그렇지 않다. 반환 타입은 메서드 시그니처에 포함되지 않으므로 주의해야 한다.**

그렇다면, 메서드 오버로딩이라는 기능을 지원하는 이유는 무엇일까?

만약, 메서드 오버로딩을 Java에서 지원하지 않는다면 위의 코드는 아래와 같이 변경되어야 할 것이다.

```java
public class Main {

    public static void main(String[] args) {
        int intResult = addInt(1, 2);
        long longResult = addLong(1L, 2L);
        float floatResult = addFloat(1.0f, 2.0f);
        double doubleResult = addDouble(1.0, 2.0);

        System.out.println("intResult : " + intResult);
        System.out.println("longResult : " + longResult);
        System.out.println("floatResult : " + floatResult);
        System.out.println("doubleResult : " + doubleResult);
    }

    public static int addInt(int number1, int number2) {
        return number1 + number2;
    }

    public static long addLong(long number1, long number2) {
        return number1 + number2;
    }

    public static float addFloat(float number1, float number2) {
        return number1 + number2;
    }

    public static double addDouble(double number1, double number2) {
        return number1 + number2;
    }
}
```

```
intResult : 3
longResult : 3
floatResult : 3.0
doubleResult : 3.0
```

- 메서드 오버로딩을 지원하지 않으면, 같은 이름의 메서드를 여러 개 만들 수 없다는 뜻이므로 모든 메서드들은 각자 다른 이름을 가져야 할 것이다.
- 하지만 addInt, addLong, addFloat, addDouble은 매개변수의 타입만 다를 뿐, 두 수를 더한다는 수학적인 기능은 동일하다. 따라서 이를 단순히 타입이 다르다는 이유로 이름을 구분하면, `누군가는 기능 자체가 다르다고 오해`할 수도 있다. 또한 메서드를 만드는 입장에서도 `계속 새로운 이름으로 메서드를 만들어야 하고`, 메서드를 사용하는 입장에서도 `각기 다른 이름을 모두 기억`해야 하기 때문에 여러모로 불편하다.

### 가변인자

메서드 오버로딩과 함께 사용할 수 있는 효율적인 기능에는 `가변인자(Variable Arguments)`라는 것이 있다.

가변인자란 메서드의 매개변수의 개수를 동적으로 설정할 수 있는 기능을 말한다.

`타입… 매개변수명`의 형식으로 가변인자를 사용할 수 있고, 이 때 가변인자 매개변수는 `배열`로 취급된다.

만약, 두 수를 더하는 메서드 뿐만 아니라 세 개의 수, 네 개의 수를 더해야 한다면 어떻게 할 수 있을까?

매개변수의 개수가 다르면 메서드 시그니처가 다르므로 오버로딩을 통해 각각의 메서드들을 선언할 수 있다.

```java
public class Main {

    public static void main(String[] args) {
        int result1 = add(1, 2);
        int result2 = add(1, 2, 3);
        int result3 = add(1, 2, 3, 4);

        System.out.println(result1);
        System.out.println(result2);
        System.out.println(result3);
    }

    public static int add(int number1, int number2) {
        return number1 + number2;
    }

    public static int add(int number1, int number2, int number3) {
        return number1 + number2 + number3;
    }

    public static int add(int number1, int number2, int number3, int number4) {
        return number1 + number2 + number3 + number4;
    }
}
```

```
3
6
10
```

하지만 다섯 개의 수, 여섯 개의 수 등등 더해야 하는 수가 계속 늘어난다면 어떻게 해야할까?

현재로써는 메서드를 추가로 선언해야 한다. 따라서 이런 비효율을 개선하기 위해 가변인자를 도입할 수 있다.

```java
public class Main {

    public static void main(String[] args) {
        int result1 = add(1, 2);
        int result2 = add(1, 2, 3);
        int result3 = add(1, 2, 3, 4);

        System.out.println(result1);
        System.out.println(result2);
        System.out.println(result3);
    }

		// 가변인자를 도입하여 여러 메서드를 하나로 통합
    public static int add(int... numbers) {
        int result = 0;

        for (int number : numbers) {
            result += number;
        }

        return result;
    }
}
```

- `int… numbers`라는 가변인자를 통해 `add()`를 호출할 때 각기 다른 개수의 인자를 넘기더라도 `배열`로 전달 받을 수 있게 하였다.
- 그리고 배열의 모든 원소를 더하는 로직을 메서드 안에 작성함으로써, 개수와 상관없이 결과를 반환할 수 있도록 만들어 주었다.