# 컬렉션 프레임워크(List, Set, Map)

## 컬렉션 프레임워크(Collection Framework)란?

### 개념

컬렉션 프레임워크(Collection Framework)란, `데이터를 효율적으로 관리하고 처리하기 위한 클래스와 인터페이스의 집합`을 말한다. 각 클래스와 인터페이스는 하나의 자료구조로써, 특성에 맞게 데이터를 저장, 조회, 정렬 등 다양한 조작을 수행할 수 있는 기능(메서드)을 제공한다.

컬렉션 프레임워크는 아래와 같은 `계층 구조`를 가진다.

![[Pasted image 20250924162720.png]]

[https://medium.com/@mbanaee61/mastering-the-java-collections-framework-hierarchy-with-java-code-and-junit-testing-ab2eb87746ed](https://medium.com/@mbanaee61/mastering-the-java-collections-framework-hierarchy-with-java-code-and-junit-testing-ab2eb87746ed)

이 중에서 가장 많이 사용되는 주요 자료구조로 List, Map, Set이 있다.

**이들은 모두 인터페이스이므로 실제로 사용할 때는 각각의 구현체를 사용해야 한다.**

- `List(리스트)` : 순서가 있는 자료구조이며, 데이터의 중복을 허용한다.
    - ArrayList를 구현체로 많이 사용한다.
- `Map(맵)` : 순서가 없는 자료구조이며, 데이터를 키(key)와 값(value)의 쌍으로 저장한다. 키는 중복을 허용하지 않고, 값은 중복을 허용한다.
    - HashMap을 구현체로 많이 사용한다.
- `Set(집합, 셋)` : 순서가 없는 자료구조이며, 데이터의 중복을 허용하지 않는다.
    - HashSet을 구현체로 많이 사용한다.

컬렉션 프레임워크는 구현체의 인스턴스를 생성하여 사용할 수 있다.
아래는 List 인터페이스의 구현체인 ArrayList 인스턴스를 생성하는 예시이다.

```java
ArrayList<Integer> list = new ArrayList<>();
```

- 컬렉션 프레임워크는 `<Integer>`와 같이 내부에 담는 자료형을 꺽쇠(`<>`) 안에 선언해야 한다. 이를 `제네릭(Generics)`이라고 한다. (제네릭은 추후 자세히 학습 예정)
- 앞에서 제네릭을 통해 내부 타입을 지정했다면, 뒤에 `new` 부분에서는 제네릭을 생략할 수 있다.
- **제네릭에는 참조 자료형만 지정할 수 있다.** 따라서 int, long, double 등의 기본 자료형은 지정할 수 없다. 기본 자료형을 지정하고 싶다면, 예시처럼 `래퍼 클래스(Wrapper Class)`를 활용해야 한다.

### 래퍼 클래스

래퍼 클래스(Wrapper Class)란, Java의 `기본 자료형을 참조 자료형처럼 사용`하기 위한 포장 클래스를 말한다.

래퍼 클래스는 참조 자료형이므로 기본 자료형으로는 사용할 수 없는 다양한 메서드들을 가지고 있다. 이를 통해 기본 자료형을 더욱 다양한 방법으로 활용할 수 있도록 하였다.

래퍼 클래스는 아래와 같은 `종류`가 있다.

|**기본 자료형**|**래퍼 클래스**|
|---|---|
|byte|Byte|
|short|Short|
|char|Character|
|int|Integer|
|long|Long|
|float|Float|
|double|Double|
|boolean|Boolean|

기본 자료형과 래퍼 클래스는 서로 박싱과 언박싱을 통해 변환할 수 있다.

- `박싱(Boxing)` : 기본 자료형 값을 래퍼 클래스의 인스턴스로 포장하는 과정
    
    ```java
    Integer boxedNumber = Integer.valueOf(10); // 기본 타입 -> 래퍼 타입
    ```
    
- `언박싱(Unboxing)` : 래퍼 클래스의 인스턴스를 기본 자료형 값으로 꺼내는 과정
    
    ```java
    int unboxedNumber = boxedNumber.intValue(); // 래퍼 타입 -> 기본 타입
    ```
    

Java 컴파일러는 박싱과 언박싱을 자동으로 처리해주기도 한다. 이를 `오토 박싱(Auto Boxing)`과 `오토 언박싱(Auto Unboxing)`이라고 한다.

```java
Integer boxedNumber = 10; // 오토 박싱 (기본 타입 -> 래퍼 타입)
int unboxedNumber = boxedNumber; // 오토 언박싱 (래퍼 타입 -> 기본 타입)
```

래퍼 클래스는 주로 `컬렉션 프레임워크의 제네릭 타입을 위해 사용`되거나, `기본 자료형의 형 변환을 위해 사용`된다. 자료형에 관해 학습할 때 사용한 형변환 문법이 사실은 래퍼 클래스를 활용한 것이었다.

```java
public class Main {

    public static void main(String[] args) {
        String byteString = "127";
        String shortString = "32767";
        String intString = "2147483647";
        String longString = "9223372036854775807";
        String floatString = "3.14";
        String doubleString = "3.141592653589793";
        String booleanString = "true";

        byte byteValue = Byte.parseByte(byteString);
        short shortValue = Short.parseShort(shortString);
        int intValue = Integer.parseInt(intString);
        long longValue = Long.parseLong(longString);
        float floatValue = Float.parseFloat(floatString);
        double doubleValue = Double.parseDouble(doubleString);
        boolean booleanValue = Boolean.parseBoolean(booleanString);

        System.out.println("byteValue: " + byteValue);
        System.out.println("shortValue: " + shortValue);
        System.out.println("intValue: " + intValue);
        System.out.println("longValue: " + longValue);
        System.out.println("floatValue: " + floatValue);
        System.out.println("doubleValue: " + doubleValue);
        System.out.println("booleanValue: " + booleanValue);
    }
}
```

```
byteValue: 127
shortValue: 32767
intValue: 2147483647
longValue: 9223372036854775807
floatValue: 3.14
doubleValue: 3.141592653589793
booleanValue: true
```

---

## List (리스트)

### 개념

List(리스트) 인터페이스는 데이터의 `중복을 허용하면서 순서가 있는` 자료구조를 구현하기 위해 사용된다.
참고로, 순서가 있다는 말은 정렬 되었다는 말과는 다르다. 순서가 있다는 것은 인덱스가 있다는 의미이다.

List 인터페이스는 아래와 같은 구현체들이 존재한다.

- **ArrayList**
- LinkedList
- Vector

이들 중, 주로 ArrayList를 구현체로 많이 사용한다.

### ArrayList

ArrayList는 용어 그대로, `배열(Array)을 활용`해 List를 구현한 자료구조이다.
ArrayList를 생성하면 내부적으로는 배열로 존재하고, 첫 번째로 저장한 데이터는 해당 배열의 0번째에 위치한다.
이런식으로 계속 내부 배열에 저장되다가, 배열이 가득차면 크기가 증가한 새로운 배열을 생성하여 데이터를 복사한다. 따라서, 내부적으로 배열을 사용하지만 `길이가 고정되어 있지 않고 동적으로 변화`하여 데이터를 유동적으로 관리할 수 있다는 장점이 있다.

ArrayList는 아래와 같이 선언할 수 있다.

```java
ArrayList<Integer> list = new ArrayList<>();
```

참고로 실무에서는 아래와 같이 상위 타입으로 선언하는 것을 선호한다.
이는 다형성을 활용하여, ArrayList 대신 다른 List 구현체가 사용되더라도 변경을 최소화 할 수 있기 때문이다.

```java
List<Integer> list = new ArrayList<>();
```

- 단, 상위 타입으로 선언하는 경우 List 인터페이스에 정의된 메서드만 사용할 수 있다는 점을 주의한다.

ArrayList는 데이터를 다루기 위한 다양한 메서드를 지원한다. 아래에서 자세히 살펴보자.

### .add(Object element)

ArrayList의 `끝`에 새로운 원소 element를 `삽입`한다.

```java
import java.util.ArrayList;
import java.util.List;

public class Main {

    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(2);

        System.out.println(list);
    }
}
```

```
[1, 2]
```

### .add(int index, Object element)

ArrayList의 `index 위치`에 새로운 원소 element를 `삽입`한다.

```java
import java.util.ArrayList;
import java.util.List;

public class Main {

    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(2);

        System.out.println(list);
        
        list.add(1, 4); // 1번째 위치에 4를 삽입
        
        System.out.println(list);
    }
}
```

```
[1, 2]
[1, 4, 2]
```

### .get(int index)

ArrayList의 index 위치에 있는 원소를 `조회`한다.

```java
import java.util.ArrayList;
import java.util.List;

public class Main {

    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(2);

        System.out.println(list.get(0));
        System.out.println(list.get(1));
    }
}
```

```
1
2
```

### .set(int index, Object element)

ArrayList의 index 위치에 있는 원소를, 새로운 원소 element로 `교체`한다.

```java
import java.util.ArrayList;
import java.util.List;

public class Main {

    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(2);

        System.out.println(list);

        list.set(0, 4); // 0번째 원소를 4로 교체

        System.out.println(list);
    }
}
```

```
[1, 2]
[4, 2]
```

### .size()

ArrayList의 `길이`를 반환한다.

```java
import java.util.ArrayList;
import java.util.List;

public class Main {

    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(2);

        System.out.println(list.size());
    }
}
```

```
2
```

### .isEmpty()

ArrayList가 `비어있는지 여부(true/false)`를 반환한다.

```java
import java.util.ArrayList;
import java.util.List;

public class Main {

    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();

        System.out.println(list.isEmpty());
    }
}
```

```
true
```

### .contains(Object element)

ArrayList에 특정 원소 element의 `포함 여부(true/false)`를 반환한다.

```java
import java.util.ArrayList;
import java.util.List;

public class Main {

    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(2);

        System.out.println(list.contains(1));
        System.out.println(list.contains(4));
    }
}
```

```
true
false
```

### .remove(int index)

ArrayList에서 특정 index 위치의 원소를 `제거`한다.

```java
import java.util.ArrayList;
import java.util.List;

public class Main {

    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(2);

        System.out.println(list);

        list.remove(1); // 1번째 원소 제거

        System.out.println(list);
    }
}
```

```
[1, 2]
[1]
```

---

## Map (맵)

### 개념

Map(맵) 인터페이스는 데이터를 키(Key)와 값(Value)의 쌍으로 저장하는 자료구조를 구현하기 위해 사용된다.

키는 중복을 허용하지 않으며, 각 키는 자신만의 값과 매칭된다. 값은 중복될 수 있다.

Map 인터페이스는 아래와 같은 구현체들이 존재한다.

- **HashMap**
- LinkedHashMap
- TreeMap
- HashTable

이들 중, 주로 HashMap을 구현체로 많이 사용한다.

### HashMap

HashMap은 용어 그대로, `해시(Hash) 테이블을 활용`해 Map을 구현한 자료구조이다.

특정 키(Key)를 해시 함수에 넣었을 때 반환되는 해시값이 해시 테이블의 인덱스가 되고, 해당 인덱스에 값(Value)이 저장된다.

![[Pasted image 20250924163026.png]]

따라서 동일한 키에 대해서는 항상 같은 해시값을 반환하므로, 중복 데이터를 허용하지 않는다.

중복 여부는 객체의 `equals()`와 `hashCode()` 메서드의 반환값을 기준으로 판별하므로, 반드시 HashMap에 삽입되는 객체에 대해 해당 메서드들을 알맞게 재정의해야 한다. (상속 파트의 Object 클래스 항목 참고)

HashMap은 아래와 같이 선언할 수 있다.

Map은 키와 값의 쌍을 저장하므로, 제네릭도 키와 값 타입을 각각 지정해야 한다. (`<키 타입, 값 타입>`)

```java
HashMap<String, Integer> map = new HashMap<>();
```

HashMap도 실무에서 아래와 같이 상위 타입으로 선언하는 것을 선호한다.

```java
Map<String, Integer> map = new HashMap<>();
```

- 단, 상위 타입으로 선언하는 경우 Map 인터페이스에 정의된 메서드만 사용할 수 있다는 점을 주의한다.

HashMap은 데이터를 다루기 위한 다양한 메서드를 지원한다. 아래에서 자세히 살펴보자.

### .put(Object key, Object value)

1. HashMap에 새로운 key=value 쌍을 `삽입`한다.
    
    ```java
    import java.util.HashMap;
    import java.util.Map;
    
    public class Main {
    
        public static void main(String[] args) {
            Map<String, Integer> map = new HashMap<>();
            map.put("kyle", 2);
            map.put("alex", 1);
            map.put("haley", 5);
    
            System.out.println(map);
        }
    }
    ```
    
    ```
    {haley=5, alex=1, kyle=2}
    ```
    
2. 이미 해당 key에 대한 value가 존재한다면, 그 value를 새로운 값으로 `교체`한다.
    
    ```java
    import java.util.HashMap;
    import java.util.Map;
    
    public class Main {
    
        public static void main(String[] args) {
            Map<String, Integer> map = new HashMap<>();
            map.put("kyle", 2);
            map.put("alex", 1);
            map.put("haley", 5);
    
            System.out.println(map);
    
            map.put("kyle", 20); // kyle이라는 key의 value를 20으로 교체
    
            System.out.println(map);
        }
    }
    ```
    
    ```
    {haley=5, alex=1, kyle=2}
    {haley=5, alex=1, kyle=20}
    ```
    

### .get(Object key)

HashMap에서 key에 해당하는 value를 `조회`한다. (key가 존재하지 않는 경우 `null`을 반환)

```java
import java.util.HashMap;
import java.util.Map;

public class Main {

    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("kyle", 2);
        map.put("alex", 1);
        map.put("haley", 5);

        System.out.println(map.get("kyle"));
        System.out.println(map.get("haley"));
        System.out.println(map.get("justin")); // 해당 키가 존재하지 않음
    }
}
```

```
2
5
null
```

### .getOrDefault(Object key, Object defaultValue)

HashMap에서 key에 해당하는 value를 `조회`한다. (key가 존재하지 않는다면 `defaultValue`를 반환)

```java
import java.util.HashMap;
import java.util.Map;

public class Main {

    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("kyle", 2);
        map.put("alex", 1);
        map.put("haley", 5);

        System.out.println(map.getOrDefault("kyle", 10));
        System.out.println(map.getOrDefault("justin", 10)); // 해당 키가 존재하지 않음
    }
}

```

```
2
10
```

### .size()

HashMap의 `크기`를 반환한다.

```java
import java.util.HashMap;
import java.util.Map;

public class Main {

    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("kyle", 2);
        map.put("alex", 1);
        map.put("haley", 5);

        System.out.println(map.size());
    }
}
```

```
3
```

### .containsKey(Object key) / .containsValue(Object value)

HashMap에서 특정 key 혹은 특정 value의 `존재 여부(true/false)`를 반환한다.

```java
import java.util.HashMap;
import java.util.Map;

public class Main {

    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("kyle", 2);
        map.put("alex", 1);
        map.put("haley", 5);

        System.out.println(map.containsKey("kyle"));
        System.out.println(map.containsKey("justin"));

        System.out.println(map.containsValue(2));
        System.out.println(map.containsValue(4));
    }
}
```

```
true
false
true
false
```

### .remove(Object key)

HashMap에서 특정 key에 해당하는 key=value 쌍을 `제거`한다.

```java
import java.util.HashMap;
import java.util.Map;

public class Main {

    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("kyle", 2);
        map.put("alex", 1);
        map.put("haley", 5);

        System.out.println(map);

        map.remove("kyle"); // kyle이라는 key의 key=value 쌍 제거

        System.out.println(map);
    }
}
```

```
{haley=5, alex=1, kyle=2}
{haley=5, alex=1}
```

### .keySet()

HashMap에 저장된 `key의 집합`을 반환한다. (보통 전체 데이터를 순회하기 위해 반복문과 함께 사용)

```java
import java.util.HashMap;
import java.util.Map;

public class Main {

    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("kyle", 2);
        map.put("alex", 1);
        map.put("haley", 5);

        for (String key : map.keySet()) {
            System.out.println(key + " : " + map.get(key));
        }
    }
}
```

```
haley : 5
alex : 1
kyle : 2
```

---

## Set (집합, 셋)

### 개념

Set(집합, 셋) 인터페이스는 데이터의 `중복을 허용하지 않으면서 순서가 없는` 자료구조를 구현하기 위해 사용된다.

Set 인터페이스는 아래와 같은 구현체들이 존재한다.

- **HashSet**
- TreeSet
- LinkedHashSet

이들 중, 주로 HashSet을 구현체로 많이 사용한다.

### HashSet

HashSet은 내부적으로 `HashMap을 활용`해 Set을 구현한 자료구조이다.

따라서, HashMap과 마찬가지로 해시 테이블을 이용해 데이터의 중복을 허용하지 않는다.

HashSet에 삽입되는 객체도 `equals()`와 `hashCode()`의 반환값을 기준으로 중복 여부를 판단하므로, 반드시 해당 메서드들을 알맞게 재정의해야 한다.

HashSet은 아래와 같이 선언할 수 있다.

```java
HashSet<Integer> set = new HashSet<>();
```

HashSet도 실무에서 아래와 같이 상위 타입으로 선언하는 것을 선호한다.

```java
Set<Integer> set = new HashSet<>();
```

- 단, 상위 타입으로 선언하는 경우 Set 인터페이스에 정의된 메서드만 사용할 수 있다는 점을 주의한다.

HashSet은 데이터를 다루기 위한 다양한 메서드를 지원한다. 아래에서 자세히 살펴보자.

### .add(Object element)

HashSet에 새로운 원소 element를 `삽입`한다.

```java
import java.util.HashSet;
import java.util.Set;

public class Main {

    public static void main(String[] args) {
        Set<Integer> set = new HashSet<>();
        set.add(1);
        set.add(2);

        System.out.println(set);
    }
}
```

```
[1, 2]
```

### .addAll(Collection c)

HashSet에 컬렉션 c의 모든 원소를 `삽입`한다.

```java
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class Main {

    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(2);
        list.add(3);

        Set<Integer> set = new HashSet<>();
        set.addAll(list);

        System.out.println(set);
    }
}
```

```
[1, 2, 3]
```

### .size()

HashSet의 `크기`를 반환한다.

```java
import java.util.HashSet;
import java.util.Set;

public class Main {

    public static void main(String[] args) {
        Set<Integer> set = new HashSet<>();
        set.add(1);
        set.add(2);

        System.out.println(set.size());
    }
}
```

```
2
```

### .isEmpty()

HashSet이 `비어있는지 여부(true/false)`를 반환한다.

```java
import java.util.HashSet;
import java.util.Set;

public class Main {

    public static void main(String[] args) {
        Set<Integer> set = new HashSet<>();

        System.out.println(set.isEmpty());
    }
}
```

```
true
```

### .contains(Object element)

HashSet에 특정 원소 element의 `포함 여부(true/false)`를 반환한다.

```java
import java.util.HashSet;
import java.util.Set;

public class Main {

    public static void main(String[] args) {
        Set<Integer> set = new HashSet<>();
        set.add(1);
        set.add(2);

        System.out.println(set.contains(1));
        System.out.println(set.contains(4));
    }
}
```

```
true
false
```

### .remove(Object element)

HashSet에서 특정 원소 element를 `제거`한다.

```java
import java.util.HashSet;
import java.util.Set;

public class Main {

    public static void main(String[] args) {
        Set<Integer> set = new HashSet<>();
        set.add(1);
        set.add(2);

        System.out.println(set);

        set.remove(1); // 원소 1 제거

        System.out.println(set);
    }
}
```


```
[1, 2]
[2]
```



---


# 실습

- String타입의 ArrayList를 만들고, 주어진 메서드들을 연습하시오.
    
- Key와 Value가 모두 String 타입인 HashMap을 만들고, 주어진 메서드들을 연습하시오.
    
- String 타입의 HashSet을 만들고, 주어진 메서드들을 연습하시오.
    
- `30, 20, 10`이 들어있는 ArrayList를 만들고, 합계와 평균을 계산하시오
    
- 다음을 참고하여 학생 성적 관리 시스템을 구현하시오
    
    - Student 클래스
        - 이름(String), 나이(int)
        - 과목별 성적 저장
        - 성적의 평균 계산
    - StudentManager 클래스
        - 학생들의 목록을 관리(가지고 있음)
        - 학생 추가, 검색
        - 학생들의 정보 조회