# 문자열

## 문자열(String)이란?

### 개념

문자열(String)은 문자(char)들의 집합으로, 텍스트 데이터를 표현하는 데 사용되는 자료형이다.

문자열은 불변(immutable) 객체로, 한번 생성된 문자열은 내용을 변경할 수 없다.

### 선언 및 초기화

문자열은 두 가지 방법으로 선언 및 초기화를 할 수 있다.

```java
String word = new String("hello");
String word = "hello"
```

- 문자열은 `큰 따옴표("")`로 감싸야한다.
- 두 줄 모두 결과적으로 word라는 변수에 `"hello"`라는 문자열이 할당된다. 그럼 어떤 차이가 있을까?

```java
public class Main {

    public static void main(String[] args) {
        String word1 = new String("hello");
        String word2 = new String("hello");
        String word3 = "hello";
        String word4 = "hello";

        System.out.println("word1 : " + System.identityHashCode(word1));
        System.out.println("word2 : " + System.identityHashCode(word2));
        System.out.println("word3 : " + System.identityHashCode(word3));
        System.out.println("word4 : " + System.identityHashCode(word4));
    }
}
word1 : 664740647
word2 : 168423058
word3 : 821270929
word4 : 821270929
```

- `System.identityHashCode()`는 객체의 원래 해시코드를 보여준다. 해시코드는 서로 다른 객체에게 다르게 부여되는 객체 자체의 고유한 번호이다.
- `new String()`으로 생성한 문자열은 객체 자체를 새로 생성한다. 그래서 word1과 word2는 동일한 코드로 문자열을 생성했지만 서로 다른 객체이므로 해시코드가 다르다.
- `리터럴("")`로 생성한 문자열은 동일한 객체를 재사용한다. 그래서 word3와 word4는 해시코드가 같다.
- 문자열은 변경 불가능한 객체이기 때문에 리터럴을 통해 여러 번 재사용해도 별다른 문제가 없다. 그래서 메모리의 효율성과 가독성을 고려하여 리터럴 방식을 주로 사용하는 편이다.

### 문자열의 결합(Concatenation)

문자열은 덧셈 연산자(+)를 통해 결합할 수 있다. 이를 통해 원하는 형식으로 출력하도록 만들 수 있다.

```java
public class Main {

    public static void main(String[] args) {
        System.out.println("Hello" + " " + "Java!");
        System.out.println("Java" + 21);
        System.out.println(2024 + "-" + 10 + "-" + 30);
    }
}
Hello Java!
Java21
2024-10-30
```

- 문자열끼리의 덧셈 뿐만 아니라, 문자열과 다른 자료형도 더할 수 있다.
- 다른 자료형과 합쳐지면 자연스럽게 문자열로 형변환된다.

다만, 다른 자료형과 더할 때는 순서가 중요하다. 덧셈은 왼쪽부터 순차적으로 이루어지므로 의도한 대로 결과가 나타나지 않을 수도 있다.

```java
public class Main {

    public static void main(String[] args) {
        System.out.println(1 + 1 + "1");
        System.out.println("1" + 1 + 1);
        System.out.println(1 + "1" + 1);
    }
}
21
111
111
```

- 세 줄 모두 문자열 “1” 한 개와 숫자 1 두 개를 결합하는 코드이다. 하지만 결과가 다르다.
- 왼쪽부터 순차적으로 더해지기 때문에, 첫 번째 줄의 경우에는 숫자 1과 숫자 1이 먼저 산술 연산되어 숫자 2가 되고, 이후에 문자열 “1”과 더해져 최종적으로 문자열 “21”이 되었다.

**참고로, 문자열은 변경 불가능(immutable)하므로 `결합 시 새로운 문자열이 생성`된다는 것에 주의한다.**

```java
public class Main {

    public static void main(String[] args) {
        String word1 = "hello";
        String word2 = "world";

        System.out.println(System.identityHashCode(word1));

        word1 += word2; // word1 자기 자신에 word2를 결합

        System.out.println(System.identityHashCode(word1));
    }
}
664740647
804564176
```

- 흔히 word1 자기 자신에 word2를 결합했기 때문에, word1의 값인 “hello”는 그대로 있고 “world”가 뒤에 붙은 것이 아닌가라는 착각을 한다.
- 하지만 문자열은 변경 불가능하기 때문에, “hello”라는 문자열 객체 자체가 변경된 것이 아니라 단순히 “helloworld”라는 결합된 모양의 새로운 문자열이 만들어지고 이를 word1의 변수에 재할당하는 것 뿐이다.
- 객체의 해시코드를 살펴보면 `+=` 이후에 해시코드가 달라짐을 확인할 수 있다. 이는 `word1`이라는 변수에 `+=` 이전과 이후에 할당된 객체 자체가 달라짐을 의미한다. 같은 객체를 가지면서 단순히 값만 변경된 것이 아니라는 것이다.

------

## 자주 사용하는 메서드

### .length()

> 문자열의 길이를 반환한다.

```java
public class Main {

    public static void main(String[] args) {
        String word = "banana";
        
        System.out.println(word.length());
    }
}
6
```

### .isEmpty()

> 문자열의 길이가 0인지의 여부(true/false)를 반환한다. (빈 문자열 여부 판별)

```java
public class Main {

    public static void main(String[] args) {
        String word1 = ""; // 빈 문자열
        String word2 = "      "; // 띄어쓰기만 있는 문자열

        System.out.println(word1.isEmpty());
        System.out.println(word2.isEmpty()); // 띄어쓰기만 있는 문자열은 empty는 아니다.
    }
}
true
false
```

### .isBlank()

> 문자열의 길이가 0이거나, 공백 문자만으로 이루어져 있는지 여부(true/false)를 반환한다. 공백 문자란 `띄어쓰기, 탭, 개행` 등을 포함한다.

```java
public class Main {

    public static void main(String[] args) {
        String word1 = ""; // 빈 문자열
        String word2 = "      "; // 띄어쓰기만 있는 문자열
        String word3 = "\\n"; // 개행

        System.out.println(word1.isBlank());
        System.out.println(word2.isBlank());
        System.out.println(word3.isBlank());
    }
}
true
true
true
```

### .charAt(int index)

> 문자열의 index 번째에 위치한 문자(char)를 반환한다. (문자열 인덱싱)

```java
public class Main {

    public static void main(String[] args) {
        String word = "banana";
        
        System.out.println(word.charAt(1));
        System.out.println(word.charAt(4));
    }
}
a
n
```

### .toCharArray()

> 문자열을 문자(char) 배열로 쪼개서 반환한다. 보통 향상된 for문과 함께 문자열을 순회할 때 많이 사용한다.

```java
import java.util.Arrays;

public class Main {

    public static void main(String[] args) {
        String word = "banana";
        char[] characters = word.toCharArray();

        System.out.println(Arrays.toString(characters));
    }
}
```


```
[b, a, n, a, n, a]
```


- toCharArray를 통해 생성된 char를 String으로 사용하기 위해서는 형변환을 시켜줘야 한다.

```java
public class Main {

    public static void main(String[] args) {
        String word = "banana";
        char[] characters = word.toCharArray();

        for (char character : characters) {
            String s = String.valueOf(character);
            System.out.println(s);
        }

    }
}
```

### .contains(String str)

> 특정 문자열 str의 포함 여부(true/false)를 반환한다.

```java
public class Main {

    public static void main(String[] args) {
        String word = "banana";
        
        System.out.println(word.contains("n"));
        System.out.println(word.contains("ana"));
        System.out.println(word.contains("f"));
    }
}
```

```
true
true
false
```

### .indexOf(String str)

> 특정 문자열 str이 원본 문자열의 몇 번째 인덱스에 있는지 반환한다. str이 두 글자 이상인 경우에는 처음으로 매칭되는 곳의 인덱스 번호를 반환한다. str을 찾지 못한 경우에는 `-1`을 반환한다.

```java
public class Main {

    public static void main(String[] args) {
        String word = "banana";
        
        System.out.println(word.indexOf("b"));
        System.out.println(word.indexOf("a"));
        System.out.println(word.indexOf("nana"));
        System.out.println(word.indexOf("f")); // 존재하지 않는 문자열
    }
}
```

```
0
1
2
-1
```

### .trim()

> 문자열의 앞뒤 공백을 제거한 새로운 문자열을 반환한다.

```java
public class Main {

    public static void main(String[] args) {
        String word = "     Hello World!    ";
        String trimmedWord = word.trim(); // 앞뒤 공백을 제거한 새로운 문자열 반환

        System.out.println(word);
        System.out.println(trimmedWord);
    }
}
```

```
     Hello World!    
Hello World!
```

### .replace(String old, String new)

> 특정 문자열에서 old 문자열을 `모두` new 문자열로 교체한 새로운 문자열을 반환한다. 문자열은 변경 불가능한(immutable) 객체이므로, 원본이 변경되는 것이 아니라 변경된 모습의 새로운 문자열을 반환한다는 점에 주의한다.

```java
public class Main {

    public static void main(String[] args) {
        String word = "banana";
        
        System.out.println(word.replace("a", "b")); // a -> b
        System.out.println(word.replace("an", "TT")); // an -> TT
        System.out.println(word.replace("b", "")); // b를 제거하는 효과
        System.out.println(word); // 원본은 변하지 않음
    }
}
```

```
bbnbnb
bTTTTa
anana
banana
```

### .substring(int start, int end)

> 문자열을 특정 구간만큼 자른 새로운 문자열을 반환한다. start는 포함하며, end는 포함하지 않는다. (`start ~ end-1`)

```java
public class Main {

    public static void main(String[] args) {
        String word = "banana";

        System.out.println(word.substring(1, 3));
    }
}
```

```
an
```

### .split(String regex)

> 문자열을 정규표현식 regex를 기준으로 분할하여 새로운 `배열`로 반환한다.

```java
public class Main {

    public static void main(String[] args) {
        String sentence = "Hello new world";
        String[] tokens = sentence.split(" "); // 공백 기준 분할
        
        System.out.println(Arrays.toString(tokens));
    }
}
```

```
[Hello, new, world]
```

```java
public class Problem {

    public static void main(String[] args) {
        String email = "hello@world.com";
        String[] tokens = email.split("@"); // 특정 문자 기준 분할

        System.out.println(Arrays.toString(tokens));
    }
}
```

```
[hello, world.com]
```

### .equals(String str)

> 특정 문자열 str과 같은 문자열인지 여부(true/false)를 반환한다.

`==`은 두 변수의 값이 서로 같은지 확인하는 연산자이다. 정수나 실수와 같은 기본 자료형과 달리, 문자열과 같은 참조 자료형은 `==`로 비교하면 값이 같은지 확인하지 않고 서로 같은 객체인지 확인한다. (`동일성`)

`new String()`으로 문자열을 생성하면 새로운 객체가 만들어진다. 그래서 두 문자열이 같은 값을 가지더라도, 서로 다른 객체이므로 `==`로 비교했을 때 `false`로 판별된다. 이를 값을 기준으로 비교하기 위해, 문자열을 비교할 때는 반드시 `equals()`를 이용해 비교해야 한다. (`동등성`)

```java
public class Main {

    public static void main(String[] args) {
        String a = new String("hello");
        String b = "hello";

        System.out.println(a == b); // 동일성
        System.out.println(a.equals(b)); // 동등성
        System.out.println(b.equals(a)); // 동등성
    }
}
false
true
true
```

### String.join(String delimiter, String[] words)

> 문자열 배열 words를 구분 문자 delimiter를 기준으로 결합한 새로운 문자열을 반환한다.

```java
public class Main {

    public static void main(String[] args) {
        String[] words = {"Hello", "new", "world"};
        String sentence = String.join(" ", words); // 공백 기준 결합

        System.out.println(sentence);
    }
}
```

```
Hello new world
```

```java
public class Problem {

    public static void main(String[] args) {
        String[] words = {"Hello", "new", "world"};
        String sentence = String.join("-", words); // 특정 문자 기준 결합

        System.out.println(sentence);
    }
}
```

```
Hello-new-world
```

------

## 문자열 포매팅

동적으로 변하는 값들을 이용해서 문자열을 원하는대로 만드는 것을 `문자열 포매팅(formatting)`이라 한다.

Java에서 자주 사용하는 문자열 포매팅 방식으로는 아래와 같은 세 가지 방식이 있다.

1. **System.out.printf(String pattern, Object.. args)**

   ```java
   public class Main {
   
       public static void main(String[] args) {
           String pattern = "저는 %d살의 %s입니다.";
           int age = 30;
           String name = "kyle";
   
           System.out.printf(pattern, age, name);
       }
   }
   ```

   ```
   저는 30살의 kyle입니다.
   ```

   - 형식에 맞춰서 문자열 포매팅한 결과를 출력한다. `System.out.println()`과 달리, 문장의 끝에서 개행하지 않음에 주의한다.
   - `지시자(Specifier)`를 통해 각 값을 대입할 수 있다. 이때 **지시자와 값의 순서가 일치해야 한다.**
   - 지시자의 종류는 아래와 같다.
     - `%s` : 문자열
     - `%c` : 문자
     - `%d` : 10진수
     - `%o` : 8진수
     - `%x, %X` : 16진수
     - `%f` : 부동 소수점
     - `%b` : boolean
     - `%n` : 개행

2. **String.format(String pattern, Object.. args)**

   ```java
   public class Main {
   
       public static void main(String[] args) {
           String pattern = "저는 %d살의 %s입니다.";
           int age = 30;
           String name = "kyle";
   
           String sentence = String.format(pattern, age, name);
   
           System.out.println(sentence);
       }
   }
   ```

   ```
   저는 30살의 kyle입니다.
   ```

   - 형식에 맞춰서 문자열 포매팅한 결과를 반환한다. `System.out.printf()`와 달리, 바로 출력하는 것이 아니라 포매팅한 문자열 자체를 반환한다는 차이가 있다. 따라서 결과를 변수에 할당할 수도 있다.
   - `System.out.println()`와 마찬가지로 지시자를 통해 각 값을 대입할 수 있으며, 지시자와 값의 순서가 일치해야 한다.

3. **MessageFormat.format(String pattern, Object.. args)**

   ```java
   import java.text.MessageFormat;
   
   public class Main {
   
       public static void main(String[] args) {
           String pattern = "저는 {0}살의 {1}입니다.";
           int age = 30;
           String name = "kyle";
   
           String sentence = MessageFormat.format(pattern, age, name);
   
           System.out.println(sentence);
       }
   }
   ```

   ```
   저는 30살의 kyle입니다.
   ```

   - `java.text` 패키지에 있는 `MessageFormat`을 이용해서도 문자열 포매팅을 할 수 있다.
   - `System.out.println()`나 `String.format()`과 달리 `MessageFormat`은 지시자를 이용하지 않는다. 대신 **0번째부터 시작하는 위치로 어디에 대입할지 결정**한다.
   - 위치를 통해 지정하므로 훨씬 직관적이고, 각 대입 값들의 타입을 신경쓰지 않아도 된다는 장점이 있다.

------

## StringBuilder를 이용하여 문자열 다루기

### 개념

문자열은 `변경 불가능(immutable)`하므로, 연산 시 새로운 문자열이 계속 만들어져 메모리 효율성이 떨어진다.

문자열에 대한 연산이나 변경이 잦은 경우를 위해 Java에서는 `변경 가능한(mutable)` 자료구조로 문자열을 다룰 수 있도록 `StringBuilder`라는 클래스를 제공한다. StringBuilder는 연산 시 새로운 객체가 생성되지 않고 기존 객체에 대한 내용이 변경되므로 메모리 효율성이 좋다.

### 선언 및 초기화

```java
StringBuilder stringBuilder = new StringBuilder();
```

- `new StringBuilder()`를 이용해 새로운 StringBuilder 객체를 생성할 수 있다.

### 주요 기능

1. **.append(String str)**

   > StringBuilder에 문자열 str을 삽입한다.

   ```java
   public class Main {
   
       public static void main(String[] args) {
           StringBuilder stringBuilder = new StringBuilder();
           stringBuilder.append("a");
           stringBuilder.append("b");
           stringBuilder.append("c");
   
           String word = stringBuilder.toString(); // StringBuilder -> String
           System.out.println(word);
       }
   }
   ```

   ```
   abc
   ```

   - StringBuilder는 문자열을 다루는 도구지만, 그 자체가 문자열은 아니다. 따라서 StringBuilder를 문자열로 변경하려면 `.toString()`을 사용한다.

2. **.insert(int index, String str)**

   > StringBuilder의 index 위치에 특정 문자열 str을 삽입한다.

   ```java
   public class Main {
   
       public static void main(String[] args) {
           StringBuilder stringBuilder = new StringBuilder();
           stringBuilder.append("ACD");
           
           stringBuilder.insert(1, "B"); // 1번 인덱스에 B 삽입
           
           String word = stringBuilder.toString();
           System.out.println(word);
       }
   }
   ```

   ```
   ABCD
   ```

3. **.delete(int start, int end)**

   > StringBuilder에서 특정 구간만큼 문자열을 삭제한다. start는 포함하며, end는 포함하지 않는다. (`start ~ end-1`)

   ```java
   public class Main {
   
       public static void main(String[] args) {
           StringBuilder stringBuilder = new StringBuilder();
           stringBuilder.append("Algorithm");
   
           stringBuilder.delete(2, 6); // 2~5번째 인덱스의 문자열 삭제
   
           String word = stringBuilder.toString();
           System.out.println(word);
       }
   }
   ```

   ```
   Althm
   ```

   참고로, `deleteCharAt(int index)`을 활용하면 특정 인덱스의 문자열 `1개만` 지울수도 있다.

   ```java
   public class Main {
   
       public static void main(String[] args) {
           StringBuilder stringBuilder = new StringBuilder();
           stringBuilder.append("Algorithm");
   
           stringBuilder.deleteCharAt(2); // 2번째 인덱스의 문자열 삭제
   
           String word = stringBuilder.toString();
           System.out.println(word);
       }
   }
   ```

   ```
   Alorithm
   ```

4. **.substring(int start, int end)**

   > StringBuilder를 특정 구간만큼 잘라 새로운 문자열로 반환한다. 참고로, 원본은 변하지 않는다. start는 포함하며, end는 포함하지 않는다. (`start ~ end-1`)

   ```java
   public class Main {
   
       public static void main(String[] args) {
           StringBuilder stringBuilder = new StringBuilder();
           stringBuilder.append("Algorithm");
   
           String token = stringBuilder.substring(2, 6); // 2~5번째 인덱스의 문자열만큼 잘라냄
           String word = stringBuilder.toString(); // 원본
   
           System.out.println(token);
           System.out.println(word); // 원본은 변하지 않는다.
       }
   }
   ```

   ```
   gori
   Algorithm
   ```

5. **.reverse(int start, int end)**

   > StringBuilder의 문자열을 뒤집는다.
   
```java
 public class Main {
     public static void main(String[] args) {
         StringBuilder stringBuilder = new StringBuilder("abc");
         stringBuilder.reverse();

         String word = stringBuilder.toString(); 
         System.out.println(word);
     }
 }
```

```
cba
```