# 클래스와 객체

## 기존 프로그래밍 방식의 한계

사각형의 너비와 높이를 이용해 면적을 계산하는 코드를 아래와 같이 작성하였다.

```java
public class Main {

    public static void main(String[] args) {
        int width = 10; // 너비
        int height = 5; // 높이
        int rectangleArea = width * height; // 면적 = 너비 x 높이
        System.out.println(rectangleArea);
    }
}
```

```
50
```

만약 사각형이 한 개가 아니라, 여러 개라면 어떨까? 단순히 동일한 로직을 여러 번 반복하면 된다.

```java
public class Main {

    public static void main(String[] args) {
        // 첫 번째 사각형
        int width1 = 10;
        int height1 = 5;
        int rectangleArea1 = width1 * height1;
        System.out.println(rectangleArea1);

        // 두 번째 사각형
        int width2 = 7;
        int height2 = 3;
        int rectangleArea2 = width2 * height2;
        System.out.println(rectangleArea2);

        // 세 번째 사각형
        int width3 = 1;
        int height3 = 10;
        int rectangleArea3 = width3 * height3;
        System.out.println(rectangleArea3);
    }
}
```

```
50
21
10
```

- 동일한 로직을 여러 번 반복하여 중복이 발생한다.
- 또한, `width * height`가 정확히 어떤 걸 의미하는건지 파악하기 어렵다. 수학적인 맥락이 있다면 면적을 구하는 공식이라는 걸 쉽게 예측 가능하지만, 맥락이 없는 사람도 알 수 있도록 곱셈이 정확히 뭘 의미하는지 코드로 표현하는 것이 좋다. 만약 이 코드가 여러 줄에 걸쳐 작성되는 복잡한 코드였다면 그 의미는 더욱 파악하기 힘들었을 것이다.

따라서 이를 별도의 메서드로 분리하면 의미를 명확하게 만들 수 있다. 

메서드는 일단 반복되는 작업을 하나로 묶어서 여러 곳에서 재사용 할 수 있게 하는 도구라고 생각하고 넘어가자. 

그리고 메서드에 이름을 지을 수 있기 때문에, `해당 코드가 어떤 동작을 하는지 메서드명을 통해 명시`할 수 있다.

```java
public class Main {

    public static void main(String[] args) {
        // 첫 번째 사각형
        int width1 = 10;
        int height1 = 5;
        int rectangleArea1 = calculateRectangleArea(width1, height1);
        System.out.println(rectangleArea1);

        // 두 번째 사각형
        int width2 = 7;
        int height2 = 3;
        int rectangleArea2 = calculateRectangleArea(width2, height2);
        System.out.println(rectangleArea2);

        // 세 번째 사각형
        int width3 = 1;
        int height3 = 10;
        int rectangleArea3 = calculateRectangleArea(width3, height3);
        System.out.println(rectangleArea3);
    }

    // 사각형의 면적을 구하는 메서드
    public static int calculateRectangleArea(int width, int height) {
        return width * height;
    }
}
```

- 메서드 내에서 `return`이라는 키워드를 통해 결과값을 내보낼 수 있다. 이를 `값을 반환한다`고 표현한다.
- `calculateRectangleArea()`라는 메서드를 통해, **width와 height를 이용해 사각형의 면적을 계산한 값을 rectangleArea에 할당한다**는 의미가 명확해졌다.

상황을 하나 더 추가해보자. 만약, 사각형이 아니라 `원의 면적도 구해야 한다면` 어떨까?

```java
public class Main {

    public static void main(String[] args) {
        // 첫 번째 사각형
        int width1 = 10;
        int height1 = 5;
        int rectangleArea1 = calculateRectangleArea(width1, height1);
        System.out.println(rectangleArea1);

        // 두 번째 사각형
        int width2 = 7;
        int height2 = 3;
        int rectangleArea2 = calculateRectangleArea(width2, height2);
        System.out.println(rectangleArea2);

        // 세 번째 사각형
        int width3 = 1;
        int height3 = 10;
        int rectangleArea3 = calculateRectangleArea(width3, height3);
        System.out.println(rectangleArea3);

        // 첫 번째 원
        int radius1 = 5;
        double circleArea1 = calculateCircleArea(radius1);
        System.out.println(circleArea1);

        // 두 번째 원
        int radius2 = 10;
        double circleArea2 = calculateCircleArea(radius2);
        System.out.println(circleArea2);
    }

    // 사각형의 면적을 구하는 메서드
    public static int calculateRectangleArea(int width, int height) {
        return width * height;
    }

    // 원의 면적을 구하는 메서드
    public static double calculateCircleArea(int radius) {
        return radius * radius * 3.14;
    }
}
```

```
50
21
10
78.5
314.0
```

- 단순하게 `calculateCircleArea()` 메서드를 추가하여 원의 면적을 구할 수 있다.

현재 하나의 Main이라는 곳 안에 사각형의 면적을 구하는 기능과 원의 면적을 구하는 기능이 함께 존재한다. 사각형과 원은 도형이라는 항목에 속해있지만 엄연히 속성과 기능이 다르다. 따라서 Main이라는 하나의 장소에 서로  다른 속성과 기능들이 모여있는 것이다. 

만약 삼각형, 오각형 등과 같이 다른 도형이 추가된다면, Main 하나에 관련 도형의 속성과 기능이 계속 추가될 것이다. 이로 인해 Main에 과도하게 기능이 몰리게 되고, 이는 곧 복잡도를 증가시키고 유지보수를 어렵게 만든다.

따라서 같은 속성과 기능들을 모아서 따로 관리한다면 복잡도는 감소하고 유지보수성은 향상될 것이다. Java에서는 비슷한 속성과 기능을 한 곳에 정의하고 사용할 수 있도록 `클래스(Class)`라는 문법을 제공한다. 클래스를 이용해 이 문제를 어떤식으로 개선할 수 있는지 아래에서 살펴보자.

---

## 클래스

### 개념

클래스(Class)란, 비슷한 `속성과 기능`을 모아 새로운 `타입`을 정의할 수 있는 `설계도`이다.

새로운 `.java` 파일(=클래스)을 생성하고 아래와 같은 문법을 통해 클래스를 정의할 수 있다.

```java
public class 클래스명 {
    속성과 기능을 정의
}
```

- `class`라는 키워드와 함께 클래스명을 작성하고 중괄호 블록을 지정한다.
- 클래스명은 명사로 해야한다.
- 클래스명은 `대문자로 시작`해야 하며, 파스칼 케이스(Pascal Case)를 따른다.
- 클래스명은 Java의 예약어로 지을 수 없다.

### 속성과 기능

먼저, 위의 예시에 등장한 사각형과 원을 통해 속성과 기능이 무엇인지 알아보자.

- **사각형**
    - `속성` : 너비(width), 높이(height)
    - `기능` : 너비와 높이를 곱하여 면적(area)을 구한다.
- **원**
    - `속성` : 반지름(radius)
    - `기능` : 반지름의 제곱과 3.14를 곱하여 면적(area)을 구한다.

`속성(Property)`은 대상을 이루는 특성 혹은 상태를 의미한다. 이는 코드에서 `변수`로 나타낸다.

- **필드(Field)**라고도 한다.

`기능(Function)`은 대상의 속성을 이용해 할 수 있는 행위를 의미한다.

- **메서드(Method)**라고도 한다.

클래스는 아래처럼 대상을 먼저 정의하고 그 안에 해당 대상의 속성과 기능을 함께 정의한다.

다른 코드는 신경쓰지 말고, 일단 속성과 기능을 어떻게 정의했는지에 집중한다.

```java
public class Rectangle {

		// 속성(필드)
    public int width;
    public int height;

    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }

		// 기능(메서드)
    public int calculateArea() {
        return this.width * this.height;
    }
}
```

```java
public class Circle {

		// 속성(필드)
    public int radius;

    public Circle(int radius) {
        this.radius = radius;
    }

		// 기능(메서드)
    public double calculateArea() {
        return this.radius * this.radius * 3.14;
    }
}
```

- 사각형과 원을 각각 Java의 클래스를 이용하여 표현하였다.
- 비슷한 속성과 기능끼리 사각형과 원이라는 클래스로 묶음으로써, 더욱 의미가 명확해짐을 알 수 있다.
- **이제 새로운 도형이 추가되더라도 Main에 몰리지 않는다. 새로운 도형 클래스를 생성하면 된다.**

### 클래스는 타입이다.

**클래스는 결국 자료형(타입)이다.** Java에서 기본적으로 제공하지 않는 타입을 내가 직접 만드는 것이다.

정수나 실수와 같은 기본 자료형과 달리, 클래스를 통해 만들어지는 자료형은 `참조 자료형`으로 구분된다.

대표적인 참조 자료형으로 알려진 `문자열(String)` 또한 사실은 클래스이다. 단순히 이미 누가 만들었을 뿐이다.

![[Pasted image 20250924154203.png]]

---

## 객체(Object)와 인스턴스(Instance)

### 개념

클래스를 정의했다고 해서 바로 사용할 수 있는 것은 아니다. 앞서 말했듯 클래스는 단순히 `설계도`일 뿐이다.
따라서 설계도에 따라 실제로 구현한 실체를 만들어야 의미가 있다.
이때, 클래스라는 설계도를 기반으로 만들어진 실체를 `객체(Object)` 혹은 `인스턴스(Instance)`라고 한다.
객체 혹은 인스턴스를 생성해야 비로소 속성과 기능을 실제로 사용할 수 있다.

**객체(인스턴스)를 생성하는 문법은 아래와 같다.**

```java
클래스명 변수명 = new 클래스명(속성);
```

예를 들어 **사각형 클래스의 인스턴스**는 아래와 같이 생성할 수 있다.

```java
Rectangle rectangle = new Rectangle(10, 5); // 너비 : 10, 높이 : 5
```

- Rectangle이라는 클래스(설계도)를 바탕으로 실제 속성값(10, 5)을 넣어 인스턴스를 생성한다.

### 객체지향 프로그래밍

Main 클래스에 모든 속성과 기능이 모여있던 기존 코드를 클래스와 객체(인스턴스) 기반으로 개선해보자.

일단 아래는 기존 코드이다.

```java
public class Main {

    public static void main(String[] args) {
        // 첫 번째 사각형
        int width1 = 10;
        int height1 = 5;
        int rectangleArea1 = calculateRectangleArea(width1, height1);
        System.out.println(rectangleArea1);

        // 두 번째 사각형
        int width2 = 7;
        int height2 = 3;
        int rectangleArea2 = calculateRectangleArea(width2, height2);
        System.out.println(rectangleArea2);

        // 세 번째 사각형
        int width3 = 1;
        int height3 = 10;
        int rectangleArea3 = calculateRectangleArea(width3, height3);
        System.out.println(rectangleArea3);

        // 첫 번째 원
        int radius1 = 5;
        double circleArea1 = calculateCircleArea(radius1);
        System.out.println(circleArea1);

        // 두 번째 원
        int radius2 = 10;
        double circleArea2 = calculateCircleArea(radius2);
        System.out.println(circleArea2);
    }

    // 사각형의 면적을 구하는 메서드
    public static int calculateRectangleArea(int width, int height) {
        return width * height;
    }

    // 원의 면적을 구하는 메서드
    public static double calculateCircleArea(int radius) {
        return radius * radius * 3.14;
    }
}
```

이제 위 코드를 객체(인스턴스)를 기반으로 개선해보자.

실제 실행은 항상 `public static void main(String[] args)`라는 main 메서드를 통해 이루어져야 한다.

따라서 main 메서드에서 Rectangle, Circle 클래스의 인스턴스를 생성해 사용한다.

```java
public class Main {

    public static void main(String[] args) {
        // 첫 번째 사각형
        Rectangle rectangle1 = new Rectangle(10, 5);
        int rectangleArea1 = rectangle1.calculateArea();
        System.out.println(rectangleArea1);

        // 두 번째 사각형
        Rectangle rectangle2 = new Rectangle(7, 3);
        int rectangleArea2 = rectangle2.calculateArea();
        System.out.println(rectangleArea2);

        // 세 번째 사각형
        Rectangle rectangle3 = new Rectangle(1, 10);
        int rectangleArea3 = rectangle3.calculateArea();
        System.out.println(rectangleArea3);

        // 첫 번째 원
        Circle circle1 = new Circle(5);
        double circleArea1 = circle1.calculateArea();
        System.out.println(circleArea1);

        // 두 번째 원
        Circle circle2 = new Circle(10);
        double circleArea2 = circle2.calculateArea();
        System.out.println(circleArea2);
    }
}
```

```
50
21
10
78.5
314.0
```

- Main 클래스는 이제 도형의 구체적인 구현에 관여하지 않고, 객체의 메서드를 호출하는 역할만 담당한다.
- 구체적인 구현 내용을 보지 않아도, `rectangle.calculateArea(), circle.calculateArea()` 를 통해 각각 “사각형의 면적을 계산한다.”와 “원의 면적을 계산한다.”는 의미를 명확히 알 수 있다.
- 새로운 도형이 추가되더라도 Main 클래스에 기능이 추가되지 않으며, 새롭게 정의된 도형 클래스를 사용하기만 하면 된다. 따라서 변화에 유연하고 확장성이 증가한다.

Main 클래스 한 곳에 몰려있던 속성과 기능을 각 도형 클래스에 분배하고, 객체를 생성해 사용까지 해보았다.

객체가 가지는 책임을 각각 스스로 가질 수 있게 분리하는 것을 `책임을 분리한다`고 표현한다.

즉, 면적을 계산하라는 명령은 Main에서 호출하지만 실제 면적에 대한 계산은 각 객체에서 이루어진다는 것이다.

이렇듯 한 곳에서 실제 계산과 구현을 모두 담당하지 않고, 각 객체에게 책임을 분리하여 계산과 구현을 맡긴 후 그 결과만 조합해서 사용하는 프로그래밍 방식을 `객체지향 프로그래밍(Object-Oriented Programming, OOP)`이라고 한다. 객체지향 프로그래밍은 **변화에 유연하고, 코드의 중복을 줄이며, 유지보수가 용이**한 코드를 작성하도록 돕는다. 이러한 이유로 현대의 대부분의 소프트웨어는 객체지향 프로그래밍 방식을 채택하고 있다.


💡**객체(Object)와 인스턴스(Instance)의 차이**

객체와 인스턴스는 기본적으로 같은 의미를 가진다. 하지만 객체는 모든 인스턴스를 대표하는 개념적인 의미가 강하고, 인스턴스는 특정 클래스로 부터 만들어진 객체라는 의미가 강하다.

따라서 `Rectangle rectangle = new Rectangle(10, 5);` 라고 선언했을 때,
”rectangle은 객체다.” 는 자연스럽지만, “rectangle은 인스턴스다.” 는 자연스럽지 않다.

대신, “rectangle은 Rectangle 클래스의 인스턴스다.” 라는 말이 더욱 자연스럽다. 

인스턴스는 그 자체만으로 존재할 수 있는 개념이라기 보다는 어떤 클래스의 인스턴스로써만 존재할 수 있는 개념이라고 보면된다.

실제로는 이 둘을 너무 엄격하게 구분할 필요는 없다. 의미만 통한다면 어떤 용어를 사용해도 상관없다.



---

## 클래스 변수와 인스턴스 변수

### 멤버

클래스에는 각 인스턴스가 가져야 할 구성원들이 선언된다. 이 구성원들을 클래스의 `멤버(Member)`라고 한다.

멤버는 다음과 같이 세 종류가 존재한다.

1. `속성(필드, 멤버변수)`
    - 클래스 변수(=정적 변수)
    - 인스턴스 변수
2. `생성자`
    - 기본 생성자
    - 매개변수가 있는 생성자
3. `메서드`
    - 정적 메서드
    - 인스턴스 메서드

가장 먼저 속성에 해당하는 클래스 변수와 인스턴스 변수에 대해 알아보자.

### 클래스 변수(=정적 변수)

클래스 변수는 `static`이라는 키워드가 붙은 변수로, 인스턴스가 아닌 **클래스 자체에 속해 있어 모든 인스턴스에서 값을 공유할 수 있는 변수**를 의미한다. 

`static`은 “정적인, 고정된”이라는 뜻을 가진 단어인데, 인스턴스를 생성할 때마다 값이 달라지지 않고 어느 인스턴스에서나 고정된 값을 유지할 수 있는 변수라는 의미이다. 그래서 `정적 변수`라고도 부른다.

클래스 변수의 대표적인 `특징`은 아래와 같다.

1. static 영역에 고정되기 때문에, 인스턴스의 생성과 소멸에 관계없이 프로그램 종료까지 값이 유지된다.
2. 별도의 인스턴스를 생성하지 않아도 사용할 수 있다.
3. 클래스의 모든 인스턴스에서 값을 공유할 수 있다.

### 인스턴스 변수

인스턴스 변수는 **클래스의 각 인스턴스에만 속하는 변수**를 의미하며, 일반적인 변수 선언과 동일하게 선언한다.

따라서 클래스 변수처럼 여러 인스턴스가 값을 공유할 수 없고, 각 인스턴스마다 별도의 값을 가진다.

### 클래스 변수와 인스턴스 변수의 예시

사각형은 각각 다른 너비와 높이를 가지지만, 모두 동일한 색깔을 가지는 경우를 아래처럼 나타낼 수 있다.

```java
public class Rectangle {

    // 클래스 변수
    public static String color = "red";

    // 인스턴스 변수
    public int width;
    public int height;

		// 생성자
    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }

    public void printColor() {
        System.out.println("사각형의 색깔: " + color);
    }

    public void printSize() {
        System.out.println("사각형의 크기: " + width + " x " + height);
    }
}
```

- `printColor()`는 클래스 변수에 해당하는 사각형의 색깔을 출력하는 메서드이다.
- `printSize()`는 인스턴스 변수에 해당하는 사각형의 너비와 높이를 출력하는 메서드이다.

Main 클래스에서 두 개의 사각형 인스턴스를 생성하고 메서드를 사용해보자.

```java
public class Main {

    public static void main(String[] args) {
        // 첫 번째 사각형
        Rectangle rectangle1 = new Rectangle(10, 5);
        rectangle1.printColor();
        rectangle1.printSize();

        System.out.println(); // 구분을 위한 공백

        // 두 번째 사각형
        Rectangle rectangle2 = new Rectangle(3, 8);
        rectangle2.printColor();
        rectangle2.printSize();
    }
}

```

```
사각형의 색깔: red
사각형의 크기: 10 x 5

사각형의 색깔: red
사각형의 크기: 3 x 8
```

- 색깔은 클래스 변수이므로, 모든 인스턴스에서 같은 값을 공유한다. 따라서 첫 번째와 두 번째 사각형에서 모두 `red`가 출력되었다.
- 하지만 너비와 높이는 인스턴스 변수이므로, 첫 번째와 두 번째 사각형에서 각각 다른 값이 출력되었다. 이는 어디까지나 해당 인스턴스 내에서만 유효하다. 다른 인스턴스끼리 공유하지 않는다.

만약 클래스 변수를 변경하면 어떻게 될까?

```java
public class Main {

    public static void main(String[] args) {
        // 첫 번째 사각형
        Rectangle rectangle1 = new Rectangle(10, 5);
        rectangle1.printColor();
        rectangle1.printSize();

        System.out.println(); // 구분을 위한 공백

        // 두 번째 사각형
        Rectangle rectangle2 = new Rectangle(3, 8);
        rectangle2.printColor();
        rectangle2.printSize();

        System.out.println(); // 구분을 위한 공백

				// 클래스 변수를 변경
        Rectangle.color = "yellow";
        rectangle1.printColor();
        rectangle2.printColor();
    }
}
```

```
사각형의 색깔: red
사각형의 크기: 10 x 5

사각형의 색깔: red
사각형의 크기: 3 x 8

사각형의 색깔: yellow
사각형의 색깔: yellow
```

- 클래스 변수에 접근할 때는 `클래스명.변수명`으로 접근할 수 있다.
- 클래스 변수를 변경하면 모든 인스턴스가 영향을 받는다.
- 따라서 클래스 변수는 **인스턴스에 따라 변하지 않는 값이 필요하거나, 값의 변경 사항을 모든 인스턴스가 공유해야 하는 경우에 사용**한다.

이번에는 인스턴스 변수를 변경해보자.

```java
public class Main {

    public static void main(String[] args) {
        // 첫 번째 사각형
        Rectangle rectangle1 = new Rectangle(10, 5);
        rectangle1.printColor();
        rectangle1.printSize();

        System.out.println(); // 구분을 위한 공백

        // 두 번째 사각형
        Rectangle rectangle2 = new Rectangle(3, 8);
        rectangle2.printColor();
        rectangle2.printSize();

        System.out.println(); // 구분을 위한 공백

        // 첫 번째 사각형의 인스턴스 변수를 변경
        rectangle1.width = 100;
        rectangle1.height = 50;

        rectangle1.printSize();
        rectangle2.printSize();
    }
}
```

```
사각형의 색깔: red
사각형의 크기: 10 x 5

사각형의 색깔: red
사각형의 크기: 3 x 8

사각형의 크기: 100 x 50
사각형의 크기: 3 x 8
```

- 인스턴스 변수에 접근할 때는 `인스턴스명.변수명`으로 접근할 수 있다.
- 인스턴스 변수를 변경하면, 해당 인스턴스만 영향을 받는다. 그래서 두 번째 사각형의 크기는 변하지 않는다.

---

## 생성자

### 개념

생성자(Constructor)는 인스턴스가 생성될 때 호출되는 `인스턴스 초기화 메서드`를 의미한다.

`인스턴스 초기화`란 인스턴스를 생성하는 과정에서 **인스턴스 변수들의 값을 초기화** 하는 것을 말한다.

생성자는 아래와 같은 문법으로 작성할 수 있다.

```java
public class 클래스명 {

    인스턴스 변수1;
    인스턴스 변수2;
    
    // 기본 생성자
    public 클래스명() {
	      ...
    }
    
    // 매개변수가 있는 생성자
    public 클래스명(변수1, 변수2) {
	      ...
    }
}
```

- 생성자는 `매개변수가 없는 기본 생성자`와 `매개변수가 있는 생성자`로 나누어진다.
- 생성자 블록 안에는 인스턴스 변수들을 초기화 할 수 있는 로직이 작성되어야 한다.
- **생성자의 이름은 클래스명과 동일해야 한다.**
- 생성자는 return 키워드에 의한 반환 값이 존재하지 않는다.
- 생성자는 `new 클래스명()`을 통해 호출 할 수 있다.

### 기본 생성자

기본 생성자(Default Constructor)는 매개변수가 없는 기본적인 생성자를 의미한다.

```java
public class Rectangle {

    // 인스턴스 변수
    public int width;
    public int height;

    // 기본 생성자 - 인스턴스 변수에 기본값을 세팅할 때 주로 사용
    public Rectangle() {
        this.width = 5;
        this.height = 5;
    }
}
```

```java
public class Main {

    public static void main(String[] args) {
        Rectangle rectangle = new Rectangle(); // 생성자 호출
        System.out.println(rectangle.width);
        System.out.println(rectangle.height);
    }
}
```

```
5
5
```

- 기본 생성자는 주로 인스턴스 변수에 고정적인 기본값을 설정할 때 사용한다.
- 따라서 Main 클래스에서 인스턴스를 생성할 때 너비와 높이 값을 따로 부여하지 않아도, 기본값으로 설정된 인스턴스가 생성된다.

기본 생성자는 생략도 가능하다. 생략했을 때는 Java 컴파일러가 자동으로 생성해준다.

```java
public class Rectangle {

    // 인스턴스 변수
    public int width;
    public int height;
		
		// 기본 생성자 생략 가능 - 이때는 아무 로직도 없는 빈 껍데기의 기본 생성자가 자동으로 생성
}
```

```java
public class Main {

    public static void main(String[] args) {
        Rectangle rectangle = new Rectangle(); // 생성자 호출
        System.out.println(rectangle.width);
        System.out.println(rectangle.height);
    }
}
```

```
0
0
```

- 기본 생성자를 생략했을 때, 컴파일러가 자동으로 생성해주는 기본 생성자에는 어떠한 로직도 존재하지 않는다. 따라서 인스턴스 변수를 초기화 하는 로직 또한 존재하지 않는다.
- 만약 인스턴스 변수가 별도로 초기화 되지 않으면, 자동적으로 각 자료형의 기본값으로 초기화 된다.

### 매개변수가 있는 생성자

매개변수가 있는 생성자는 호출 시 값을 넘겨받아서 인스턴스 초기화 작업에 사용할 수 있는 생성자를 의미한다.

```java
public class Rectangle {

    // 인스턴스 변수
    public int width;
    public int height;

    // 매개변수가 있는 생성자 - 생성자를 호출하는 곳에서 매개변수를 넘겨받아 초기화에 사용
    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }
}
```

```java
public class Main {

    public static void main(String[] args) {
        Rectangle rectangle = new Rectangle(10, 5); // 생성자 호출
        System.out.println(rectangle.width);
        System.out.println(rectangle.height);
    }
}
```

```
10
5
```

- 매개변수가 있는 생성자는 주로 인스턴스 변수에 동적으로 값을 설정할 때 사용한다.
- 따라서 Main 클래스에서 인스턴스를 생성할 때 너비와 높이 값을 따로 부여하여야 한다.
- `this`라는 키워드는 인스턴스 변수와 생성자의 매개변수가 이름이 같은 경우, 이를 구분하기 위해 사용한다.
`this`는 **인스턴스 자신**을 가리키므로, `this.변수명`은 현재 자기 자신에 속한 인스턴스 변수를 가리킨다. 따라서 클래스 변수에는 `this` 키워드를 사용할 수 없다.

앞서 기본 생성자는 생략이 가능하다고 했다. 하지만 매개변수가 있는 생성자가 존재한다면 Java 컴파일러는 기본 생성자를 자동으로 생성하지 않는다.

```java
public class Main {

    public static void main(String[] args) {
        Rectangle rectangle1 = new Rectangle(10, 5);
        Rectangle rectangle2 = new Rectangle(); // 문법 오류 (기본 생성자가 없음)
    }
}
```

따라서 기본 생성자와 매개변수가 있는 생성자를 동시에 활용하고 싶다면, 기본 생성자를 따로 생성해야 한다.

```java
public class Rectangle {

    // 인스턴스 변수
    public int width;
    public int height;

    // 기본 생성자도 따로 생성해야함
    public Rectangle() {
        this.width = 5;
        this.height = 5;
    }
    
    // 매개변수가 있는 생성자
    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }
}
```

이처럼 기본 생성자와 매개변수가 있는 생성자를 동시에 활용하면, 어떤 사각형 객체는 기본값을 부여하고 어떤 사각형 객체는 원하는 값을 부여할 수 있다. 즉, 다양한 방법으로 객체를 생성할 수 있다.

```java
public class Main {

    public static void main(String[] args) {
        // 매개변수가 있는 생성자를 통해 생성한 사각형
        Rectangle rectangle1 = new Rectangle(10, 5);
        System.out.println(rectangle1.width);
        System.out.println(rectangle1.height);

        System.out.println(); // 구분을 위한 공백

        // 기본 생성자를 통해 생성한 사각형
        Rectangle rectangle2 = new Rectangle();
        System.out.println(rectangle2.width);
        System.out.println(rectangle2.height);
    }
}
```

```
10
5

5
5
```

### this()

현재 사각형 클래스에는 기본 생성자와 매개변수가 있는 생성자가 함께 작성되어 있다.

```java
public class Rectangle {

    // 인스턴스 변수
    public int width;
    public int height;

    // 기본 생성자
    public Rectangle() {
        this.width = 5;
        this.height = 5;
    }

    // 매개변수가 있는 생성자
    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }
}
```

두 생성자 모두 내부에서 인스턴스 변수를 초기화하고 있는데, 이러한 중복을 `this()`를 이용해 제거할 수 있다.

```java
public class Rectangle {

    // 인스턴스 변수
    public int width;
    public int height;

    // 기본 생성자
    public Rectangle() {
        this(5, 5);
    }

    // 매개변수가 있는 생성자
    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }
}
```

- `this()`는 생성자 내에서 다른 생성자를 호출할 때 사용할 수 있다.
- 단, 이때는 호출하고자 하는 생성자의 매개변수에 맞게 인자를 넘겨주어야 한다.
- 중복 제거 뿐만 아니라, 다른 생성자를 재사용하고 있으므로 이후 유지보수 할 때에도 많은 도움이 된다.

`this()`를 사용할 때는 반드시 **생성자 내에서 가장 첫 줄에 호출**되어야 한다. 그렇지 않으면 에러가 발생한다.
왜냐하면 `this()` 이전에 인스턴스 변수를 초기화하는 작업을 아무리 추가해도, 결국 `this()`에서 최종적으로 초기화가 될 것이기 때문에, `this()` 이전 작업이 무의미해지기 때문이다.

```java
public class Rectangle {

    // 인스턴스 변수
    public int width;
    public int height;

    // 기본 생성자
    public Rectangle() {
        this.width = 10; // 문법 오류!!!
        this(5, 5);
    }

    // 매개변수가 있는 생성자
    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }
}
```

```
java: call to this must be first statement in constructor
```

---

## 멤버 변수의 초기화

클래스와 객체의 속성(필드, 멤버 변수)을 초기화하는 방법은 크게 세 가지가 존재한다.

1. 명시적인 초기화
2. 생성자를 이용한 초기화
3. 초기화 블록을 이용한 초기화

이 중 생성자를 이용한 초기화는 앞서 알아보았기 때문에, 나머지 두 가지 초기화 방법에 대해서만 알아보자.

### 명시적인 초기화

클래스나 인스턴스 변수를 선언함과 동시에 값을 초기화 하는 것을 명시적인 초기화라고 한다.

```java
public class Rectangle {
    
    // 클래스 변수
    public static String color = "red";

    // 인스턴스 변수
    public int width = 10;
    public int height = 5;
}
```

```java
public class Main {

    public static void main(String[] args) {
        System.out.println(Rectangle.color); // 클래스 변수

        Rectangle rectangle = new Rectangle();
        System.out.println(rectangle.width); // 인스턴스 변수
        System.out.println(rectangle.height); // 인스턴스 변수
    }
}
```

```
red
10
5
```

- 초기 기본값을 부여하거나 복잡한 초기화 작업이 필요 없는 경우에 많이 사용하는 방법이다.
- 만약 값을 따로 초기화 하지 않으면, 자동적으로 자료형에 따른 기본값으로 초기화 된다.

### 초기화 블록

초기화 블록은 명시적인 초기화 만으로는 할 수 없는 복잡한 초기화 과정에 사용하기 위한 기능이다.

초기화 블록은 크게 `클래스 초기화 블록`과 `인스턴스 초기화 블록`으로 나뉜다.

- **클래스 초기화 블록**
    - 클래스 변수의 복잡한 초기화를 위해 사용한다.
    - 클래스가 메모리에 처음 로딩될 때 `단 한번만` 수행된다.

- **인스턴스 초기화 블록**
    - 인스턴스 변수의 복잡한 초기화를 위해 사용한다.
    - 새로운 인스턴스가 생성될 때마다 `매번` 수행된다.
    - 주로 생성자가 여러 개 존재하는 경우, 생성자들에 공통으로 들어가는 로직의 중복을 제거하기 위해 사용한다.

초기화 블록은 아래와 같은 문법을 통해 사용 가능하다.

```java
public class 클래스명 {

		...
		
		// 클래스 초기화 블록
		static {
		    클래스 변수 초기화 동작 1;
		    클래스 변수 초기화 동작 2;
		    ...
		}
		
		// 인스턴스 초기화 블록
		{
				인스턴스 변수 초기화 동작 1;
				인스턴스 변수 초기화 동작 2;
		}
}
```

- 초기화 블록 안에는 변수, 조건문, 반복문 등 여러 문법을 자유롭게 사용할 수 있다.

사각형 클래스에 초기화 블록을 사용하여 아래와 같이 작성해 볼 수 있다.

```java
public class Rectangle {

    // 클래스 변수
    public static String color;

    // 클래스 초기화 블록
    static {
        color = "red";
    }

    // 인스턴스 변수
    public int width;
    public int height;

    // 인스턴스 초기화 블록
    {
        this.width = 10;
        this.height = 5;
    }
}
```

- Rectangle 클래스가 로딩되면 `최초 한 번만` 클래스 초기화 블록을 통해 color 변수에 값이 할당된다.
- Rectangle 클래스의 인스턴스가 새로 생성될 때 마다, `매번` 인스턴스 초기화 블록을 통해 width와 height 변수에 값이 할당된다.

### 멤버 변수의 초기화  순서

클래스 변수와 인스턴스 변수의 초기화 순서는 다음과 같다.

- **클래스 변수의 초기화 순서**
    1. 자료형에 따른 기본값
    2. 명시적인 초기화
    3. 클래스 초기화 블록에 의한 초기화

- **인스턴스 변수의 초기화 순서**
    1. 자료형에 따른 기본값
    2. 명시적인 초기화
    3. 인스턴스 초기화 블록에 의한 초기화
    4. 생성자에 의한 초기화

따라서 동일한 멤버 변수에 대해 여러 초기화 단계에서 작업을 하는 경우, 초기화 순서에 주의해야 한다.


---


# 실습

- 이름, 나이를 가지고 있는 `Person` 클래스를 구현하시오.

---

- 견종, 이름을 가지고, “앉아”, “손”을 할 수 있는 `Dog` 클래스를 구현하시오.

---

- 다음을 바탕으로 `Triangle` 클래스를 구현하시오
    - 삼각형의 둘레 길이, 넓이를 계산할 수 있다.

---

- 다음을 구현하시오
    
    - 아래 내용을 바탕으로 `Car` 클래스를 구현하시오
        
        - 다음 속성들을 변수로 갖는다
            - 모델명
            - 속도
        - 다음 기능들을 메서드로 갖는다
            - 속도 증가 - 속도 10 증가
            - 속도 감소 - 속도 10 감소
            - 정보 조회 - 모델명과 현재 속도 조회
    - 구현한 `Car` 클래스를 이용하여 다음 작업을 수행하시오.
        
        - 모델명이 ”Avante”인 자동차 인스턴스를 생성하시오
        - 가속을 3번 수행하시오
        - 브레이크를 1번 수행하시오
        - 최종 자동차 정보를 출력하시오
    
    ---
    
    - 다음을 구현하시오
        - 아래 내용을 바탕으로 `MP3Player` 클래스를 구현하시오
            - 다음 속성들을 변수로 갖는다
                - 모델명
                - 볼륨
                - 전원이 켜져있는지 여부
            - 다음 기능들을 메서드로 갖는다
                - 전원 켜기 - 전원을 키고, 볼륨을 40으로 설정
                - 전원 끄기 - 전원을 끄고, 볼륨을 0으로 설정
                - 볼륨 증가 - 볼륨 20 증가 (최대 100)
                - 볼륨 감소 - 볼륨 20 감소 (최소 0)
                - 정보 조회
        - 구현한 `MP3Player` 클래스를 이용하여 다음 작업을 수행하시오.
            - model이 "iPod"인 MP3 플레이어 인스턴스를 생성하시오
            - 볼륨을 3번 올리시오
            - 볼륨을 1번 내리시오
            - 최종 MP3 플레이어 정보를 출력하시오

---

- 두 정수를 활용하여 이항연산을 할 수 있는 계산기 클래스를 구현하시오.
    - 단, 두 정수는 계산기가 생성될 때 입력된다