
# 컴포지션

## 컴포지션(Composition)이란?

### 개념

컴포지션(Composition)이란, 하나의 클래스의 멤버 변수로 다른 클래스 타입의 참조형 변수를 가지는 것을 말한다. 즉, `하나의 타입 안에 다른 타입의 변수를 포함`시키는 것을 말한다. 따라서 컴포지션은 `포함, 구성, 합성`이라고도 한다.

컴포지션은 상속처럼 코드를 재사용하고 더 넓은 기능으로 확장하기 위해 사용한다.

상속과 정확히 어떤 점이 다른지 아래의 예시를 살펴보면서 알아보자.

### 상속과의 차이점

시와 도로 정보를 담고있는 주소 클래스를 아래와 같이 선언했다고 가정해보자.

```java
public class Address {

    private String city;
    private String street;

    public Address(String city, String street) {
        this.city = city;
        this.street = street;
    }

    public String getCity() {
        return city;
    }

    public String getStreet() {
        return street;
    }
}
```

건물은 각자 자신만의 고유한 주소를 가져야한다. 이를 위해 Address 클래스를 재사용한다.

```java
public class Building extends Address {

    public Building(String city, String street) {
        super(city, street);
    }

    public void showAddress() {
        System.out.println("시 : " + getCity());
        System.out.println("도로 : " + getStreet());
    }
}
```

- Address 클래스를 `상속`하여 Building 클래스가 시와 도로 정보를 가지도록 만든다.
- 자식 클래스는 부모 클래스의 메서드를 사용할 수 있으므로, Building의 `showAddress()` 메서드에서 `getCity()`와 `getStreet()` 메서드를 사용해 시와 도로 정보를 출력한다.

이번에는 상속 대신 컴포지션을 통해 동일한 기능을 구현해보자.

```java
public class Building {

    private Address address; // composition

    public Building(Address address) {
        this.address = address;
    }

    public void showAddress() {
        System.out.println("시 : " + this.address.getCity());
        System.out.println("도로 : " + this.address.getStreet());
    }
}
```

- 더이상 상속을 받지 않기 때문에 extends 키워드는 제거된다.
- Building 클래스는 Address 클래스 타입의 변수 address를 인스턴스 변수로 `포함`한다.
- 따라서, 시와 도로 정보를 출력하려면 Address 클래스의 메서드를 호출해 그 값을 꺼내야한다.

상속과 컴포지션에 따른 관계도를 나타내면 아래와 같다.

![[Pasted image 20250924162203.png]]

상속은 `계층` 관계를 형성하는 반면, 컴포지션은 `포함` 관계를 형성한다.

이 중, 주소와 건물의 관계는 어느 것이 더 어울릴까? → 당연히 포함 관계가 어울린다.

**건물은 주소의 하위 개념이 아니라, 주소를 가지기 때문이다. (건물은 주소를 자신의 정보로 포함한다.)**

따라서, 컴포지션을 통해 이 둘의 관계를 표현하는 것이 자연스럽다.

**상속은 is-a 관계에서 주로 사용한다.**

![[Pasted image 20250924162219.png]]

- `is-a` 관계란 `~은 ~이다.` 로 표현될 수 있는 관계를 말한다.
- 예를 들어, `“삼각형은 도형이다.”, “사각형은 도형이다.”`와 같은 관계를 말한다.

**컴포지션은 has-a 관계에서 주로 사용한다.**

![[Pasted image 20250924162225.png]]

- `has-a` 관계란 `~은 ~를 가진다.` 로 표현될 수 있는 관계를 말한다.
- 예를 들어, `“건물은 주소를 가진다.”, “자동차는 엔진을 가진다.”`와 같은 관계를 말한다.

---

## 상속의 한계

컴포지션을 사용하는 이유가 단순히 두 대상이 `has-a` 관계를 가지기 때문만은 아니다.

상속은 객체지향적인 관점에서 여러 한계점들을 가지고 있다. 컴포지션을 통해 이러한 한계들을 극복할 수 있다.

아래에서 조금 더 자세히 살펴보자.

### [한계 1] 상속은 결합도를 높인다.

결합도란, `하나의 클래스가 다른 클래스에 대해 얼마나 알고 있는가`를 말한다.

객체지향 프로그래밍에서는 클래스 간의 `결합도는 낮게 유지하는 것을 권장`한다. 결합도가 높으면, 그만큼 한 쪽 클래스의 내용을 변경할 때마다, 다른 쪽 클래스의 내용도 변경해야할 가능성이 높아지기 때문이다. 이는 유지보수성을 떨어뜨린다.

Address와 Building 클래스가 상속 관계일 때, 어떻게 결합도가 높아지는지 알아보자.

```java
public class Address {

    private String city;
    private String street;
    
    public Address(String city, String street) {
        this.city = city;
        this.street = street;
    }
}
```

```java
public class Building extends Address {

    public Building(String city, String street) {
        super(city, street);
    }
}
```

만약, Address에 우편 번호에 해당하는 postCode를 추가하면 어떻게 될까?

```java
public class Address {

    private String city;
    private String street;
    private String postCode; // 새로 추가

    public Address(String city, String street, String postCode) {
        this.city = city;
        this.street = street;
        this.postCode = postCode;
    }

    public String getCity() {
        return city;
    }

    public String getStreet() {
        return street;
    }

    public String getPostCode() {
        return postCode;
    }
}
```

- 인스턴스 변수 postCode가 추가되면서 Address 클래스의 내용이 변경되었다.

Building 클래스는 이 때 컴파일 에러가 발생한다.

![[Pasted image 20250924162317.png]]

부모 클래스의 생성자에 3개의 인자가 들어가야 하는데, 2개의 인자만 들어가고 있기 때문이다.

따라서, Building 클래스에도 postCode에 대한 정보를 추가해야 한다.

```java
public class Building extends Address {

    public Building(String city, String street, String postCode) {
        super(city, street, postCode);
    }
}
```

결론적으로, Address에서 발생한 변경은 다른 클래스인 Building의 변경을 발생시킨다.

이는 Building이 Address의 내부 정보(인스턴스 변수)를 알고 있기 때문에 발생하였다.

내부 정보를 알고 있다는 것은 곧 `결합도가 높다`는 것을 의미한다. 이처럼 상속은 결합도를 높인다.

Building이 Address를 컴포지션으로 가지고 있었다면 상황은 달라진다.

```java
public class Building {

    private Address address;

    public Building(Address address) {
        this.address = address;
    }
}
```

Building은 Address의 인스턴스 자체를 가지고 있기 때문에, Address 클래스의 내부가 어떻게 변경되든 Building 클래스에 영향을 끼치지 않는다. 따라서, Building과 Address의 결합도는 낮게 유지된다.

### [한계 2] Java는 다중 상속이 불가능하다.

Java는 여러 클래스를 한 번에 다중으로 상속하는 것이 불가능하다.

다시 Address와 Building 클래스가 상속 관계일 때로 돌아가보자.

```java
public class Address {

    private String city;
    private String street;
    
    public Address(String city, String street) {
        this.city = city;
        this.street = street;
    }
}
```

```java
public class Building extends Address {

    public Building(String city, String street) {
        super(city, street);
    }
}
```

건물이 주소 뿐만 아니라 `주인`에 대한 정보도 가지고 있어야 한다면, 상속을 통해 이를 어떻게 구현할 수 있을까?

```java
public class Owner {

    private String name;
    private int age;

    public Owner(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

아래처럼 extends 뒤에 여러 클래스를 나열하여 다중으로 상속 받으면 가능할 것 같지만, 이는 `불가능`하다.

```java
public class Building extends Address, Owner {

    public Building(String city, String street) {
        super(city, street);
    }
}
```

![[Pasted image 20250924162544.png]]

- Java는 원칙적으로 다중 상속이 불가능하기 때문에 컴파일 에러가 발생한다.

물론 이를 상속을 이용해서 억지로 가능하게 만들 수는 있다.

![[Pasted image 20250924162549.png]]

위와 같은 방식으로 연쇄적인 상속을 거치면 Building 클래스는 Address와 Owner의 정보를 모두 가질 수 있다.

원하는 목적을 달성한 것 같지만, 사실 이는 앞서 언급한 `결합도` 문제에 치명적이다.

1. Address를 수정하면 Owner를 수정해야 한다.
2. Owner를 수정하면 Building을 수정해야 한다.
3. 따라서, Address를 수정하면 Owner와 Building 모두 수정해야 한다. (세 클래스는 결합도가 높다.)

이는 현실적으로 굉장히 복잡한 코드를 작성하게 만들고, 유지보수도 훨씬 어렵다.

컴포지션을 통해 Building이 Address와 Owner를 가지도록 만들어야 한다.

```java
public class Building {

    private Address address;
    private Owner owner;

    public Building(Address address, Owner owner) {
        this.address = address;
        this.owner = owner;
    }
}

```

Building이 Address와 Owner의 인스턴스 자체를 가지고 있기 때문에, 이들 중 어느 곳에서 내부 변경이 발생하더라도 Building 클래스에는 영향을 끼치지 못한다. 따라서, 세 클래스의 결합도가 낮게 유지된다.

추가적으로 Building이 마치 Address와 Owner를 다중 상속한 것처럼, 이들의 정보를 모두 가질 수 있게 된다.

```java
Address address = new Address();
Owner owner = new Owner();

Building building = new Building(address, owner);

building.address.(address에 있는 변수 및 메서드);
building.owner.(owner에 있는 변수 및 메서드)

building.method(); // 임의의 메서드 내부에서 address, owner 자유롭게 사용 가능
```


---

# 실습

- 다음을 구현하시오
    
    - 색상, 쓰기 기능을 갖는 Pencil 클래스를 구현하시오
    - 이름, Pencil을 갖는 Person 클래스를 구현하시오
        - write() 메소드를 통해 연필로 쓰기 기능 구현
- 다음을 구현하시오
    
    - 마력을 갖는 Engine 클래스를 구현하시오
    - 모델명, Engine, 가속 기능을 갖는 Car 클래스를 구현하시오
        - Engine의 마력에 따라 속도가 크게 빨라지는 기능 구현
- 다음을 구현하시오
    
    - 공격력, 내구력을 갖는 Weapon 클래스를 구현하시오
        - 특별 공격 기능을 갖는 Gun, Sword 클래스를 구현하시오.
    - 체력, 공격 기능을 갖는 Character 클래스를 구현하시오
        - 무기가 없으면 기본공격, 무기가 있으면 무기의 공격력만큼 추가 공격을 하는 기능 구현
        - 무기를 사용한 특별 공격 구현