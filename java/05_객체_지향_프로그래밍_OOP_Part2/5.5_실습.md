# 5.5. 실습: OOP Part 2 종합

> 상속, 다형성, 추상 클래스, 인터페이스, 컴포지션을 활용한 종합 실습 문제입니다.

## 실습 가이드

**이 실습은 강사가 수업을 진행하면서 활용할 수 있도록 구성되었습니다.**

- 각 문제는 난이도별로 구성
- 학습자의 수준에 따라 선택적으로 진행 가능
- 코드 리뷰 및 토론 주제 포함

---

## 난이도 1: 기본 (상속 & 다형성)

### 실습 1-1: 동물 시스템

**학습 목표:**
- 추상 클래스 작성 및 상속
- 메서드 오버라이딩
- 다형성 활용

**요구사항:**

1. `Animal` 추상 클래스 작성
   - 필드: `name` (이름), `age` (나이)
   - 생성자: name, age 초기화
   - 일반 메서드: `showInfo()` - 이름과 나이 출력
   - 추상 메서드: `makeSound()` - 울음소리

2. `Dog`, `Cat`, `Cow` 클래스 작성
   - Animal 상속
   - `makeSound()` 오버라이딩
   - Dog: 품종(breed) 필드 추가
   - Cat: `purr()` 메서드 추가 (골골대기)

3. Main 클래스에서 다형성 활용
   - Animal 배열에 여러 동물 저장
   - 반복문으로 모든 동물의 정보 및 울음소리 출력

**테스트 코드:**
```java
public class Main {
    public static void main(String[] args) {
        Animal[] animals = {
            new Dog("백구", 3, "진돗개"),
            new Cat("나비", 2),
            new Cow("얼룩이", 5)
        };

        for (Animal animal : animals) {
            animal.showInfo();
            animal.makeSound();
            System.out.println();
        }

        // instanceof 활용
        for (Animal animal : animals) {
            if (animal instanceof Cat) {
                Cat cat = (Cat) animal;
                cat.purr();
            }
        }
    }
}
```

**예상 출력:**
```
이름: 백구, 나이: 3세 (품종: 진돗개)
멍멍!

이름: 나비, 나이: 2세
야옹~

이름: 얼룩이, 나이: 5세
음메~

나비가 골골거립니다.
```

**강의 포인트:**
- 추상 클래스는 왜 인스턴스를 만들 수 없는지 설명
- 다형성의 장점: 배열로 여러 타입을 하나로 관리
- instanceof를 사용한 타입 체크의 필요성

---

### 실습 1-2: 차량 시스템

**학습 목표:**
- 상속 계층 구조 설계
- super() 활용
- 메서드 오버라이딩

**요구사항:**

1. `Vehicle` 클래스 작성
   - 필드: `model` (모델명), `speed` (속도), `maxFuel` (최대 연료량), `fuel` (현재 연료량)
   - 생성자: model, maxFuel 초기화 (speed는 0, fuel은 maxFuel로 초기화)
   - 메서드:
     - `accelerate()`: 속도 +10, 연료 -5
     - `brake()`: 속도 -10
     - `showStatus()`: 모델명, 속도, 연료량 출력

2. `Bus` 클래스 작성
   - Vehicle 상속
   - 필드: `passengers` (승객 수)
   - 생성자: maxFuel은 300으로 고정
   - 메서드:
     - `boardPassenger(int count)`: 승객 탑승
     - `getOffPassenger(int count)`: 승객 하차

3. `Truck` 클래스 작성
   - Vehicle 상속
   - 필드: `cargo` (짐 무게)
   - 생성자: maxFuel은 250으로 고정
   - 메서드:
     - `loadCargo(int weight)`: 짐 싣기
     - `unloadCargo(int weight)`: 짐 내리기

**테스트 코드:**
```java
public class Main {
    public static void main(String[] args) {
        Bus bus = new Bus("시내버스");
        bus.boardPassenger(10);
        bus.accelerate();
        bus.accelerate();
        bus.showStatus();

        System.out.println();

        Truck truck = new Truck("화물차");
        truck.loadCargo(500);
        truck.accelerate();
        truck.showStatus();
    }
}
```

**강의 포인트:**
- super() 호출의 중요성
- 자식 클래스에서 부모 필드 활용
- 공통 기능은 부모에, 특수 기능은 자식에 배치하는 설계

---

## 난이도 2: 중급 (인터페이스 & 다중 구현)

### 실습 2-1: 능력 시스템

**학습 목표:**
- 인터페이스 작성 및 구현
- 다중 구현 활용
- 추상 클래스 + 인터페이스 조합

**요구사항:**

1. `Flyable` 인터페이스
   - `fly()`: 날기

2. `Swimmable` 인터페이스
   - `swim()`: 수영하기

3. `Animal` 추상 클래스
   - 필드: `name`
   - 추상 메서드: `makeSound()`

4. 구체 클래스 작성
   - `Duck`: Animal 상속, Flyable + Swimmable 구현
   - `Fish`: Animal 상속, Swimmable 구현
   - `Eagle`: Animal 상속, Flyable 구현

5. `AnimalTrainer` 클래스
   - `trainFlying(Flyable animal)`: 날기 훈련
   - `trainSwimming(Swimmable animal)`: 수영 훈련

**테스트 코드:**
```java
public class Main {
    public static void main(String[] args) {
        Duck duck = new Duck("오리");
        Fish fish = new Fish("잉어");
        Eagle eagle = new Eagle("독수리");

        AnimalTrainer trainer = new AnimalTrainer();

        trainer.trainFlying(duck);
        trainer.trainSwimming(duck);
        trainer.trainSwimming(fish);
        trainer.trainFlying(eagle);
    }
}
```

**예상 출력:**
```
오리의 날기 훈련을 시작합니다.
오리가 날아갑니다!

오리의 수영 훈련을 시작합니다.
오리가 헤엄칩니다!

잉어의 수영 훈련을 시작합니다.
잉어가 헤엄칩니다!

독수리의 날기 훈련을 시작합니다.
독수리가 날아갑니다!
```

**강의 포인트:**
- 인터페이스는 "능력"을 나타냄
- 다중 구현으로 여러 능력 조합
- 인터페이스 타입 매개변수로 유연한 설계

---

### 실습 2-2: 도서관 시스템

**학습 목표:**
- 추상 클래스와 인터페이스 조합
- 다형성을 활용한 실제 시스템 설계

**요구사항:**

1. `Borrowable` 인터페이스
   - `borrow()`: 대출
   - `returnItem()`: 반납
   - `isAvailable()`: 대출 가능 여부

2. `Downloadable` 인터페이스
   - `download()`: 다운로드

3. `LibraryItem` 추상 클래스
   - 필드: `title` (제목), `id` (ID), `available` (대출 가능 여부)
   - 생성자: title, id 초기화 (available은 true)
   - 추상 메서드: `String getItemType()`
   - 일반 메서드: getter들

4. 구체 클래스 작성
   - `Book`: LibraryItem 상속, Borrowable 구현
     - 추가 필드: `location` (물리적 위치)
   - `DVD`: LibraryItem 상속, Borrowable 구현
     - 추가 필드: `location` (물리적 위치)
   - `EBook`: LibraryItem 상속, Borrowable + Downloadable 구현
     - 추가 필드: `fileSize` (파일 크기 MB)

5. `Library` 클래스
   - 필드: `LibraryItem[]` items (도서관 소장 목록)
   - 메서드:
     - `addItem(LibraryItem item)`: 항목 추가
     - `borrowItem(String id)`: ID로 대출
     - `returnItem(String id)`: ID로 반납
     - `showAllItems()`: 모든 항목 정보 출력

**테스트 코드:**
```java
public class Main {
    public static void main(String[] args) {
        Library library = new Library(10);

        Book book = new Book("자바의 정석", "B001", "A-101");
        DVD dvd = new DVD("인셉션", "D001", "C-205");
        EBook ebook = new EBook("클린 코드", "E001", 15);

        library.addItem(book);
        library.addItem(dvd);
        library.addItem(ebook);

        library.showAllItems();

        System.out.println("\n=== 대출 ===");
        library.borrowItem("B001");
        library.borrowItem("E001");

        System.out.println("\n=== 전자책 다운로드 ===");
        ebook.download();

        System.out.println("\n=== 반납 ===");
        library.returnItem("B001");

        library.showAllItems();
    }
}
```

**강의 포인트:**
- 실제 시스템을 OOP로 모델링하는 방법
- 인터페이스로 기능 분리
- 배열을 사용한 간단한 데이터 관리

---

## 난이도 3: 고급 (컴포지션 & 종합)

### 실습 3-1: RPG 게임 캐릭터 시스템

**학습 목표:**
- 컴포지션 활용
- 상속, 인터페이스, 컴포지션 종합 활용
- 런타임 동작 변경

**요구사항:**

1. `Weapon` 인터페이스
   - `attack()`: 공격
   - `int getDamage()`: 공격력 반환
   - `String getName()`: 무기 이름

2. 무기 구현 클래스
   - `Sword`: 데미지 20, "칼로 베기!"
   - `Gun`: 데미지 30, "총 발사!"
   - `MagicWand`: 데미지 25, "마법 발사!"

3. `Skill` 인터페이스
   - `use()`: 스킬 사용
   - `int getManaCost()`: 마나 소모량

4. 스킬 구현 클래스
   - `FireBall`: 마나 20, "화염구 발사!"
   - `Heal`: 마나 15, "체력 회복!"

5. `Character` 추상 클래스
   - 필드: `name`, `health`, `level`, `weapon` (Weapon)
   - 생성자: name, 초기 체력 초기화 (level은 1)
   - 메서드:
     - `equipWeapon(Weapon weapon)`: 무기 장착
     - `attack()`: 무기로 공격 (무기 없으면 맨손 공격)
     - `takeDamage(int damage)`: 데미지 받기
     - `isAlive()`: 생존 여부
     - 추상 메서드: `levelUp()` - 레벨업 시 스탯 증가

6. 캐릭터 구현 클래스
   - `Warrior`: 초기 체력 120, 레벨업 시 체력 +30
     - 추가 필드: `rage` (분노 게이지, 최대 100)
   - `Mage`: 초기 체력 70, 레벨업 시 체력 +15
     - 추가 필드: `mana` (마나, 최대 100)
     - 추가 메서드: `useSkill(Skill skill)` - 스킬 사용

**테스트 코드:**
```java
public class Main {
    public static void main(String[] args) {
        Warrior warrior = new Warrior("전사");
        Mage mage = new Mage("마법사");

        System.out.println("=== 무기 없이 전투 ===");
        warrior.attack();
        mage.attack();

        System.out.println("\n=== 무기 장착 ===");
        warrior.equipWeapon(new Sword());
        mage.equipWeapon(new MagicWand());

        warrior.attack();
        mage.attack();

        System.out.println("\n=== 무기 교체 ===");
        warrior.equipWeapon(new Gun());
        warrior.attack();

        System.out.println("\n=== 마법사 스킬 사용 ===");
        mage.useSkill(new FireBall());
        mage.useSkill(new Heal());

        System.out.println("\n=== 레벨업 ===");
        warrior.levelUp();
        mage.levelUp();
        System.out.println("전사 체력: " + warrior.getHealth());
        System.out.println("마법사 체력: " + mage.getHealth());
    }
}
```

**강의 포인트:**
- 무기를 컴포지션으로 설계하여 런타임에 교체 가능
- 상속(is-a)과 컴포지션(has-a)의 조합
- 인터페이스로 무기와 스킬을 추상화

---

### 실습 3-2: 스마트홈 시스템

**학습 목표:**
- 복잡한 시스템을 OOP로 설계
- default 메서드 활용
- 컴포지션으로 시스템 통합

**요구사항:**

1. `Controllable` 인터페이스
   - `turnOn()`: 켜기
   - `turnOff()`: 끄기
   - `isOn()`: 켜짐 여부
   - default `toggle()`: 토글 (켜짐 ↔ 꺼짐)

2. `Dimmable` 인터페이스
   - `setBrightness(int level)`: 밝기 설정 (0~100)
   - `int getBrightness()`: 밝기 반환

3. `Adjustable` 인터페이스
   - `setTemperature(int temp)`: 온도 설정
   - `int getTemperature()`: 온도 반환

4. 가전제품 클래스
   - `Light`: Controllable + Dimmable 구현
   - `AirConditioner`: Controllable + Adjustable 구현
   - `TV`: Controllable 구현
     - 추가: `setChannel(int channel)`, `setVolume(int volume)`

5. `SmartHome` 클래스
   - 필드: `Light[] lights`, `AirConditioner[] acs`, `TV[] tvs`
   - 메서드:
     - `addDevice(...)`: 기기 추가
     - `turnOnAll()`: 모든 기기 켜기
     - `turnOffAll()`: 모든 기기 끄기
     - `showStatus()`: 모든 기기 상태 출력

**테스트 코드:**
```java
public class Main {
    public static void main(String[] args) {
        SmartHome home = new SmartHome();

        Light livingRoomLight = new Light("거실 조명");
        Light bedRoomLight = new Light("침실 조명");
        AirConditioner ac = new AirConditioner("거실 에어컨");
        TV tv = new TV("거실 TV");

        home.addLight(livingRoomLight);
        home.addLight(bedRoomLight);
        home.addAirConditioner(ac);
        home.addTV(tv);

        System.out.println("=== 모든 기기 켜기 ===");
        home.turnOnAll();

        System.out.println("\n=== 조명 밝기 조절 ===");
        livingRoomLight.setBrightness(70);
        bedRoomLight.setBrightness(30);

        System.out.println("\n=== 에어컨 온도 설정 ===");
        ac.setTemperature(24);

        System.out.println("\n=== 상태 확인 ===");
        home.showStatus();

        System.out.println("\n=== 모든 기기 끄기 ===");
        home.turnOffAll();

        home.showStatus();
    }
}
```

**강의 포인트:**
- default 메서드로 공통 기능 제공
- 다중 인터페이스로 기능 조합
- 실제 IoT 시스템을 간단하게 모델링

---

## 종합 프로젝트: 전투 시뮬레이션 게임

**난이도: 최고급**

**학습 목표:**
- OOP의 모든 개념 종합 활용
- 복잡한 시스템 설계 능력 배양

**요구사항:**

1. 추상 클래스 `Unit`
   - 필드: name, health, maxHealth, attackPower, defense
   - 메서드: `attack(Unit target)`, `takeDamage(int damage)`, `isAlive()`

2. 인터페이스 `Healable`
   - `heal(int amount)`: 체력 회복

3. 인터페이스 `BuffableUnit`
   - `applyBuff(Buff buff)`: 버프 적용
   - `removeBuff(Buff buff)`: 버프 제거

4. `Buff` 클래스 (컴포지션용)
   - 필드: name, attackBonus, defenseBonus, duration

5. 구체 유닛 클래스
   - `Warrior`: Unit 상속, BuffableUnit 구현
   - `Mage`: Unit 상속, Healable + BuffableUnit 구현
   - `Healer`: Unit 상속, Healable 구현

6. `Battle` 클래스
   - 필드: `List<Unit> team1`, `List<Unit> team2`
   - 메서드: `simulate()` - 전투 시뮬레이션

**학생 과제로 제시 가능**

---

## 디버깅 & 코드 리뷰 연습

### 문제가 있는 코드 찾기

다음 코드의 문제점을 찾고 수정하세요.

```java
// 문제 1: 추상 클래스 사용
public abstract class Animal {
    public abstract void makeSound();
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Animal();  // ❌ 무엇이 문제인가?
        animal.makeSound();
    }
}
```

```java
// 문제 2: 인터페이스 구현
public interface Drawable {
    void draw();
}

public class Circle implements Drawable {
    private void draw() {  // ❌ 무엇이 문제인가?
        System.out.println("원을 그립니다.");
    }
}
```

```java
// 문제 3: 다운캐스팅
public class Main {
    public static void main(String[] args) {
        Animal animal = new Animal();
        Dog dog = (Dog) animal;  // ❌ 무엇이 문제인가?
        dog.bark();
    }
}
```

**강의 포인트:**
- 각 문제를 학생들과 함께 분석
- 올바른 수정 방법 토론
- 실제 프로젝트에서 자주 발생하는 실수

---

## 요약 및 복습

**5장에서 학습한 핵심 개념:**

1. **상속 (Inheritance)**
   - extends, super(), super
   - 메서드 오버라이딩
   - Object 클래스

2. **다형성 (Polymorphism)**
   - 업캐스팅, 다운캐스팅
   - instanceof
   - 다형성의 장점

3. **추상 클래스 (Abstract Class)**
   - abstract 키워드
   - 추상 메서드
   - 추상화의 의미

4. **인터페이스 (Interface)**
   - implements
   - 다중 구현
   - default, static, private 메서드

5. **컴포지션 (Composition)**
   - is-a vs has-a
   - 상속의 한계
   - 낮은 결합도

**다음 단계:**
- 6장: 객체지향 설계 원칙 (SOLID)
- 실제 프로젝트에 OOP 적용하기
