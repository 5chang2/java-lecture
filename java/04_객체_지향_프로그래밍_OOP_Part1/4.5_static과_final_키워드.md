# 4.5. static과 final 키워드

> static과 final 키워드의 의미를 이해하고, 적절하게 사용할 수 있다.

## static 키워드

**static**은 "정적인"이라는 뜻으로, **클래스에 속하는(클래스 레벨)** 멤버를 정의할 때 사용합니다. static 멤버는 객체 생성 없이 클래스 이름으로 직접 접근할 수 있습니다.

**JavaScript 비교**: JavaScript의 static 메서드/속성과 유사합니다.

```javascript
// JavaScript - static
class MathUtil {
    static PI = 3.14159;

    static add(a, b) {
        return a + b;
    }
}

console.log(MathUtil.PI);        // 3.14159
console.log(MathUtil.add(1, 2)); // 3
// 객체 생성 없이 바로 사용!
```

---

## static 변수 (클래스 변수)

### 개념

**static 변수**는 모든 객체가 **공유하는** 변수입니다. 클래스 당 하나만 존재합니다.

```java
public class Counter {
    static int count = 0;  // static 변수 (클래스 변수)
    int instanceCount = 0;  // 인스턴스 변수

    public Counter() {
        count++;          // 모든 객체가 공유
        instanceCount++;  // 각 객체마다 별도
    }
}

public class Main {
    public static void main(String[] args) {
        Counter c1 = new Counter();
        Counter c2 = new Counter();
        Counter c3 = new Counter();

        System.out.println("총 생성된 객체: " + Counter.count);  // 3
        System.out.println("c1의 instanceCount: " + c1.instanceCount);  // 1
        System.out.println("c2의 instanceCount: " + c2.instanceCount);  // 1
        System.out.println("c3의 instanceCount: " + c3.instanceCount);  // 1
    }
}
```

### 메모리 구조

```
[클래스 영역 - Method Area]
Counter.count = 3  // static 변수 (공유)

[힙 영역 - Heap]
c1 객체: instanceCount = 1
c2 객체: instanceCount = 1
c3 객체: instanceCount = 1
```

### 접근 방법

```java
public class Example {
    static int staticVar = 10;
    int instanceVar = 20;

    public static void main(String[] args) {
        // static 변수 접근 (클래스명.변수명 - 권장)
        System.out.println(Example.staticVar);  // 10

        // 객체를 통해서도 접근 가능 (비권장)
        Example obj = new Example();
        System.out.println(obj.staticVar);  // 10 (경고 발생)

        // 인스턴스 변수는 객체를 통해서만 접근
        // System.out.println(Example.instanceVar);  // 에러!
        System.out.println(obj.instanceVar);  // 20
    }
}
```

**권장**: static 변수는 `클래스명.변수명`으로 접근하세요!

### 언제 사용하나?

1. **모든 객체가 공유해야 하는 값**

```java
public class Student {
    static String school = "새싹고등학교";  // 모든 학생이 같은 학교
    String name;  // 각 학생마다 다른 이름

    public Student(String name) {
        this.name = name;
    }
}
```

2. **객체 생성 횟수 추적**

```java
public class User {
    static int userCount = 0;  // 생성된 사용자 수

    public User() {
        userCount++;
    }

    public static int getUserCount() {
        return userCount;
    }
}
```

3. **상수 정의** (static final과 함께)

```java
public class Constants {
    static final double PI = 3.14159;
    static final int MAX_SIZE = 100;
}
```

---

## static 메서드 (클래스 메서드)

### 개념

**static 메서드**는 객체 생성 없이 클래스 이름으로 직접 호출할 수 있는 메서드입니다.

```java
public class MathUtil {
    // static 메서드
    public static int add(int a, int b) {
        return a + b;
    }

    public static int multiply(int a, int b) {
        return a * b;
    }
}

public class Main {
    public static void main(String[] args) {
        // 객체 생성 없이 바로 호출
        int sum = MathUtil.add(10, 20);
        int product = MathUtil.multiply(5, 4);

        System.out.println("합: " + sum);        // 30
        System.out.println("곱: " + product);    // 20
    }
}
```

### 제약 사항

static 메서드는 **인스턴스 멤버에 접근할 수 없습니다**.

```java
public class Example {
    int instanceVar = 10;    // 인스턴스 변수
    static int staticVar = 20;  // static 변수

    // static 메서드
    public static void staticMethod() {
        System.out.println(staticVar);  // ✅ static 변수는 접근 가능

        // System.out.println(instanceVar);  // ❌ 에러! 인스턴스 변수 접근 불가
        // instanceMethod();  // ❌ 에러! 인스턴스 메서드 호출 불가
    }

    // 인스턴스 메서드
    public void instanceMethod() {
        System.out.println(instanceVar);  // ✅ 인스턴스 변수 접근 가능
        System.out.println(staticVar);    // ✅ static 변수도 접근 가능
        staticMethod();  // ✅ static 메서드도 호출 가능
    }
}
```

**이유**: static 메서드는 객체가 생성되기 전에도 호출될 수 있는데, 인스턴스 멤버는 객체가 있어야 존재하기 때문입니다.

### this 키워드 사용 불가

```java
public class Example {
    int value = 10;

    public static void staticMethod() {
        // System.out.println(this.value);  // ❌ 에러! static 메서드에서 this 사용 불가
    }

    public void instanceMethod() {
        System.out.println(this.value);  // ✅ 인스턴스 메서드에서는 this 사용 가능
    }
}
```

### 언제 사용하나?

1. **유틸리티 메서드** (인스턴스 상태와 무관한 기능)

```java
public class StringUtil {
    public static boolean isEmpty(String str) {
        return str == null || str.trim().isEmpty();
    }

    public static String reverse(String str) {
        return new StringBuilder(str).reverse().toString();
    }
}
```

2. **팩토리 메서드** (객체 생성 로직)

```java
public class User {
    private String name;
    private int age;

    private User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // static 팩토리 메서드
    public static User createUser(String name, int age) {
        return new User(name, age);
    }

    public static User createGuest() {
        return new User("Guest", 0);
    }
}
```

3. **main 메서드**

```java
public class Main {
    // main 메서드는 반드시 static!
    public static void main(String[] args) {
        // JVM이 객체 생성 없이 직접 호출
    }
}
```

**JavaScript 비교**:

```javascript
// JavaScript - static 메서드
class MathUtil {
    static add(a, b) {
        return a + b;
    }
}

console.log(MathUtil.add(1, 2));  // 3
```

---

## static 블록 (정적 초기화 블록)

**static 블록**은 클래스가 로딩될 때 **한 번만 실행**되는 코드 블록입니다.

```java
public class Database {
    static String url;
    static String username;

    // static 초기화 블록
    static {
        System.out.println("Database 클래스 로딩 중...");
        url = "jdbc:mysql://localhost:3306/mydb";
        username = "admin";
    }

    public static void connect() {
        System.out.println("접속: " + url + " as " + username);
    }
}

public class Main {
    public static void main(String[] args) {
        Database.connect();  // "Database 클래스 로딩 중..." 출력 후 접속
    }
}
```

**실행 결과**:
```
Database 클래스 로딩 중...
접속: jdbc:mysql://localhost:3306/mydb as admin
```

**사용 시기**:
- 복잡한 static 변수 초기화
- 설정 파일 읽기
- 데이터베이스 드라이버 로딩

---

## final 키워드

**final**은 "최종적인", "변경 불가능한"이라는 뜻으로, 변수, 메서드, 클래스에 사용됩니다.

**JavaScript 비교**: JavaScript의 `const`와 유사하지만, final의 범위가 더 넓습니다.

```javascript
// JavaScript - const
const PI = 3.14159;
// PI = 3.14;  // 에러! 재할당 불가

const user = { name: "홍길동" };
user.name = "김철수";  // ✅ 객체 내부 변경은 가능
```

---

## final 변수 (상수)

### 개념

**final 변수**는 **한 번만 할당**할 수 있으며, 이후 변경할 수 없습니다.

```java
public class Example {
    final int MAX_SIZE = 100;  // final 변수

    public void test() {
        System.out.println(MAX_SIZE);  // 100
        // MAX_SIZE = 200;  // 에러! final 변수는 재할당 불가
    }
}
```

### 상수 선언 (static final)

**상수**는 `static final`을 함께 사용하여 선언합니다.

```java
public class Constants {
    // 상수 명명 규칙: 대문자 + 언더스코어
    public static final double PI = 3.14159;
    public static final int MAX_SIZE = 100;
    public static final String DEFAULT_NAME = "Unknown";
}

public class Main {
    public static void main(String[] args) {
        System.out.println(Constants.PI);          // 3.14159
        System.out.println(Constants.MAX_SIZE);    // 100

        // Constants.PI = 3.14;  // 에러! 상수는 변경 불가
    }
}
```

**명명 규칙**: 상수는 모두 **대문자**로 작성하고, 단어 사이는 **언더스코어(_)**로 구분합니다.

### final 인스턴스 변수

final 인스턴스 변수는 **생성자에서 초기화**할 수 있습니다.

```java
public class Person {
    final String id;  // 생성 후 변경 불가
    String name;      // 변경 가능

    public Person(String id, String name) {
        this.id = id;    // 생성자에서 한 번만 할당
        this.name = name;
    }

    public void changeName(String newName) {
        this.name = newName;  // ✅ 변경 가능
        // this.id = "new_id";  // ❌ 에러! final 변수는 변경 불가
    }
}

public class Main {
    public static void main(String[] args) {
        Person person = new Person("P001", "홍길동");
        person.changeName("김철수");  // ✅ name은 변경 가능
        System.out.println(person.id);  // P001 (변경 불가)
    }
}
```

### final과 참조형 변수

**주의**: final은 **재할당**만 막습니다. 참조형의 경우 객체 내부는 변경 가능합니다.

```java
public class Example {
    public static void main(String[] args) {
        final int[] numbers = {1, 2, 3};

        numbers[0] = 10;  // ✅ 배열 내부 변경 가능
        System.out.println(numbers[0]);  // 10

        // numbers = new int[]{4, 5, 6};  // ❌ 에러! 재할당 불가

        final StringBuilder sb = new StringBuilder("Hello");
        sb.append(" World");  // ✅ 객체 내부 변경 가능
        System.out.println(sb);  // Hello World

        // sb = new StringBuilder("Hi");  // ❌ 에러! 재할당 불가
    }
}
```

**JavaScript 비교**:

```javascript
// JavaScript - const와 동일한 동작
const numbers = [1, 2, 3];
numbers[0] = 10;  // ✅ 배열 내부 변경 가능
// numbers = [4, 5, 6];  // ❌ 에러! 재할당 불가
```

---

## final 메서드

**final 메서드**는 **오버라이딩(재정의)할 수 없는** 메서드입니다.

```java
public class Parent {
    // final 메서드
    public final void show() {
        System.out.println("Parent의 show()");
    }

    public void display() {
        System.out.println("Parent의 display()");
    }
}

public class Child extends Parent {
    // public void show() {  // 에러! final 메서드는 오버라이딩 불가
    //     System.out.println("Child의 show()");
    // }

    @Override
    public void display() {  // ✅ final이 아닌 메서드는 오버라이딩 가능
        System.out.println("Child의 display()");
    }
}
```

**사용 시기**:
- 메서드의 동작을 변경하면 안 되는 경우
- 보안상 중요한 메서드
- 성능 최적화 (컴파일러가 인라인 처리 가능)

---

## final 클래스

**final 클래스**는 **상속할 수 없는** 클래스입니다.

```java
// final 클래스
public final class Util {
    public static void printMessage(String msg) {
        System.out.println(msg);
    }
}

// public class MyUtil extends Util {  // 에러! final 클래스는 상속 불가
// }
```

**대표적인 final 클래스**:
- `String`
- `Integer`, `Double` 등 Wrapper 클래스
- `Math`

```java
// public class MyString extends String {  // 에러! String은 final 클래스
// }
```

**사용 시기**:
- 상속을 통한 확장을 막고 싶을 때
- 불변 클래스 (Immutable Class) 설계
- 보안상 중요한 클래스

---

## static final 상수

**static final**을 함께 사용하면 **변하지 않는 클래스 레벨 상수**를 정의할 수 있습니다.

```java
public class GameConfig {
    // 상수 정의 (static final)
    public static final int MAX_PLAYER = 4;
    public static final int MIN_PLAYER = 2;
    public static final String GAME_TITLE = "My Game";
    public static final double VERSION = 1.5;
}

public class Main {
    public static void main(String[] args) {
        System.out.println("게임 제목: " + GameConfig.GAME_TITLE);
        System.out.println("최대 인원: " + GameConfig.MAX_PLAYER);

        // GameConfig.MAX_PLAYER = 10;  // 에러! 상수는 변경 불가
    }
}
```

**장점**:
- 매직 넘버(Magic Number) 제거
- 유지보수 용이
- 의미 전달 명확

```java
// 나쁜 예 (매직 넘버)
if (players.size() > 4) {
    System.out.println("인원 초과");
}

// 좋은 예 (상수 사용)
if (players.size() > GameConfig.MAX_PLAYER) {
    System.out.println("인원 초과");
}
```

---

## 실전 예제

### 예제 1: 설정 클래스

```java
public class AppConfig {
    // 상수 정의
    public static final String APP_NAME = "MyApp";
    public static final String VERSION = "1.0.0";
    public static final int MAX_CONNECTIONS = 100;
    public static final int TIMEOUT_SECONDS = 30;

    // 인스턴스 생성 방지 (유틸리티 클래스)
    private AppConfig() {
        throw new UnsupportedOperationException("Utility class");
    }

    public static void printConfig() {
        System.out.println("=== 앱 설정 ===");
        System.out.println("이름: " + APP_NAME);
        System.out.println("버전: " + VERSION);
        System.out.println("최대 연결: " + MAX_CONNECTIONS);
        System.out.println("타임아웃: " + TIMEOUT_SECONDS + "초");
    }
}
```

### 예제 2: 싱글톤 패턴

```java
public class DatabaseConnection {
    // static final 인스턴스 (싱글톤)
    private static final DatabaseConnection INSTANCE = new DatabaseConnection();

    private DatabaseConnection() {
        // private 생성자로 외부 생성 방지
        System.out.println("Database 연결 생성");
    }

    public static DatabaseConnection getInstance() {
        return INSTANCE;
    }

    public void query(String sql) {
        System.out.println("쿼리 실행: " + sql);
    }
}

public class Main {
    public static void main(String[] args) {
        DatabaseConnection db1 = DatabaseConnection.getInstance();
        DatabaseConnection db2 = DatabaseConnection.getInstance();

        System.out.println(db1 == db2);  // true (같은 인스턴스)

        db1.query("SELECT * FROM users");
    }
}
```

### 예제 3: 수학 유틸리티

```java
public class MathUtil {
    // 상수
    public static final double PI = 3.14159265359;
    public static final double E = 2.71828182846;

    // 인스턴스 생성 방지
    private MathUtil() {
    }

    // static 메서드
    public static double circleArea(double radius) {
        return PI * radius * radius;
    }

    public static double circleCircumference(double radius) {
        return 2 * PI * radius;
    }

    public static int factorial(int n) {
        if (n <= 1) return 1;
        return n * factorial(n - 1);
    }
}

public class Main {
    public static void main(String[] args) {
        System.out.println("원주율: " + MathUtil.PI);
        System.out.println("반지름 5인 원의 넓이: " + MathUtil.circleArea(5));
        System.out.println("5! = " + MathUtil.factorial(5));
    }
}
```

---

## 실습 문제

### 문제 1: 카운터 클래스

static 변수를 사용하여 생성된 객체의 개수를 추적하는 `Counter` 클래스를 작성하세요.

**요구사항**:
- 생성자에서 카운터 증가
- `getCount()` static 메서드로 총 개수 반환
- `reset()` static 메서드로 카운터 초기화

### 문제 2: 상수 관리 클래스

게임의 설정 값을 관리하는 `GameSettings` 클래스를 작성하세요.

**상수** (모두 public static final):
- `SCREEN_WIDTH = 800`
- `SCREEN_HEIGHT = 600`
- `MAX_FPS = 60`
- `GAME_TITLE = "My Game"`

**static 메서드**:
- `printSettings()`: 모든 설정 출력

### 문제 3: 유틸리티 클래스

문자열 처리 유틸리티 클래스 `StringUtils`를 작성하세요.

**static 메서드**:
- `isEmpty(String str)`: 문자열이 비어있는지 확인
- `reverse(String str)`: 문자열 뒤집기
- `countWords(String str)`: 단어 개수 세기

---

## 요약

### static 키워드

- **의미**: 클래스에 속하는 멤버 (클래스 레벨)
- **static 변수**: 모든 객체가 공유하는 변수
- **static 메서드**: 객체 생성 없이 호출 가능한 메서드
- **제약**: 인스턴스 멤버에 접근 불가, this 사용 불가
- **사용 시기**:
  - 유틸리티 메서드
  - 공유 데이터
  - 상수 정의
  - main 메서드

### final 키워드

- **의미**: 변경 불가능한, 최종적인
- **final 변수**: 한 번만 할당 가능 (상수)
- **final 메서드**: 오버라이딩 불가
- **final 클래스**: 상속 불가
- **static final**: 클래스 레벨 상수
- **주의**: 참조형의 경우 객체 내부는 변경 가능

### 비교표

| 항목 | 인스턴스 멤버 | static 멤버 |
|:---|:---|:---|
| 소속 | 객체 | 클래스 |
| 메모리 | 객체마다 별도 | 클래스당 하나 |
| 생성 시점 | 객체 생성 시 | 클래스 로딩 시 |
| 접근 방법 | `객체.멤버` | `클래스.멤버` |
| this 사용 | ✅ | ❌ |

**JavaScript와의 차이점**:
- Java: static, final 키워드로 명시적 제어
- JavaScript: static은 ES6+, const는 재할당만 방지
