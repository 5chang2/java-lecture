# 6.2. SOLID 원칙 소개

> 객체지향 설계의 5가지 핵심 원칙인 SOLID를 이해하고, 실제 코드에 적용하는 방법을 학습합니다.

## 학습 목표
- SOLID 원칙의 의미와 중요성 이해
- 각 원칙을 실제 코드에 적용하는 방법 학습
- 원칙을 위반한 코드와 준수한 코드 비교
- JavaScript 개발 경험과 연계하여 이해

---

## 1. SOLID란?

### 개념

**SOLID**는 객체지향 프로그래밍의 **5가지 핵심 설계 원칙**을 나타내는 약어입니다.

**유래:**
- 로버트 C. 마틴(Robert C. Martin, Uncle Bob)이 정리
- 2000년대 초 소프트웨어 공학계에 널리 퍼짐

### 5가지 원칙

| 약어 | 원칙 | 핵심 개념 |
|------|------|----------|
| **S** | Single Responsibility Principle | 단일 책임 원칙 |
| **O** | Open-Closed Principle | 개방-폐쇄 원칙 |
| **L** | Liskov Substitution Principle | 리스코프 치환 원칙 |
| **I** | Interface Segregation Principle | 인터페이스 분리 원칙 |
| **D** | Dependency Inversion Principle | 의존성 역전 원칙 |

### 왜 중요한가?

**좋은 코드의 특징:**
- ✅ 이해하기 쉬움
- ✅ 수정하기 쉬움
- ✅ 확장하기 쉬움
- ✅ 테스트하기 쉬움
- ✅ 재사용하기 쉬움

**SOLID 원칙은 이러한 특징을 달성하기 위한 가이드입니다.**

---

## 2. SRP: 단일 책임 원칙

### Single Responsibility Principle

**정의:**
> 한 클래스는 하나의 책임만 가져야 한다.

**핵심:**
- 클래스를 수정할 이유는 단 하나여야 함
- 한 가지 일만 잘하도록 설계

### 위반 예시

```java
// ❌ SRP 위반: 여러 책임을 가진 클래스
public class User {
    private String name;
    private String email;

    public User(String name, String email) {
        this.name = name;
        this.email = email;
    }

    // 책임 1: 사용자 정보 관리
    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }

    // 책임 2: 이메일 검증 (다른 책임!)
    public boolean isValidEmail() {
        return email.contains("@") && email.contains(".");
    }

    // 책임 3: 데이터베이스 저장 (또 다른 책임!)
    public void saveToDatabase() {
        System.out.println("DB에 저장: " + name + ", " + email);
    }

    // 책임 4: 이메일 발송 (또 다른 책임!)
    public void sendWelcomeEmail() {
        System.out.println(email + "로 환영 메일 발송");
    }
}
```

**문제점:**
- 이메일 검증 로직 변경 시 User 클래스 수정
- DB 저장 방식 변경 시 User 클래스 수정
- 이메일 발송 방식 변경 시 User 클래스 수정
- 여러 이유로 클래스가 변경됨 (높은 결합도)

### 준수 예시

```java
// ✅ SRP 준수: 각 클래스는 하나의 책임만
public class User {
    private String name;
    private String email;

    public User(String name, String email) {
        this.name = name;
        this.email = email;
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }
}

// 이메일 검증만 담당
public class EmailValidator {
    public boolean isValid(String email) {
        return email != null && email.contains("@") && email.contains(".");
    }
}

// DB 저장만 담당
public class UserRepository {
    public void save(User user) {
        System.out.println("DB에 저장: " + user.getName() + ", " + user.getEmail());
    }
}

// 이메일 발송만 담당
public class EmailService {
    public void sendWelcomeEmail(User user) {
        System.out.println(user.getEmail() + "로 환영 메일 발송");
    }
}
```

**사용:**

```java
public class Main {
    public static void main(String[] args) {
        User user = new User("홍길동", "hong@example.com");

        EmailValidator validator = new EmailValidator();
        if (validator.isValid(user.getEmail())) {
            UserRepository repository = new UserRepository();
            repository.save(user);

            EmailService emailService = new EmailService();
            emailService.sendWelcomeEmail(user);
        }
    }
}
```

### JavaScript와의 비교

```javascript
// JavaScript - SRP 준수
class User {
    constructor(name, email) {
        this.name = name;
        this.email = email;
    }
}

class EmailValidator {
    isValid(email) {
        return email?.includes("@") && email?.includes(".");
    }
}

class UserRepository {
    save(user) {
        console.log(`DB에 저장: ${user.name}, ${user.email}`);
    }
}
```

---

## 3. OCP: 개방-폐쇄 원칙

### Open-Closed Principle

**정의:**
> 소프트웨어 엔터티는 확장에는 열려 있고, 수정에는 닫혀 있어야 한다.

**핵심:**
- 새로운 기능 추가 시 기존 코드 수정 불필요
- 추상화와 다형성 활용

### 위반 예시

```java
// ❌ OCP 위반: 새로운 도형 추가 시 기존 코드 수정 필요
public class AreaCalculator {
    public double calculateArea(Object shape) {
        if (shape instanceof Circle) {
            Circle circle = (Circle) shape;
            return Math.PI * circle.radius * circle.radius;
        } else if (shape instanceof Rectangle) {
            Rectangle rectangle = (Rectangle) shape;
            return rectangle.width * rectangle.height;
        }
        // 새로운 도형 추가 시 이 메서드를 수정해야 함!
        return 0;
    }
}

class Circle {
    double radius;
    Circle(double radius) { this.radius = radius; }
}

class Rectangle {
    double width, height;
    Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }
}
```

**문제점:**
- Triangle 추가 시 `calculateArea()` 메서드 수정 필요
- 새로운 도형마다 if-else 추가 (수정에 열려있음)

### 준수 예시

```java
// ✅ OCP 준수: 추상화를 통한 확장
public interface Shape {
    double calculateArea();
}

public class Circle implements Shape {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

public class Rectangle implements Shape {
    private double width;
    private double height;

    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }

    @Override
    public double calculateArea() {
        return width * height;
    }
}

// 새로운 도형 추가 - 기존 코드 수정 없음!
public class Triangle implements Shape {
    private double base;
    private double height;

    public Triangle(double base, double height) {
        this.base = base;
        this.height = height;
    }

    @Override
    public double calculateArea() {
        return (base * height) / 2;
    }
}

// AreaCalculator는 수정 불필요 (폐쇄)
public class AreaCalculator {
    public double calculateTotalArea(Shape[] shapes) {
        double total = 0;
        for (Shape shape : shapes) {
            total += shape.calculateArea();
        }
        return total;
    }
}
```

**사용:**

```java
public class Main {
    public static void main(String[] args) {
        Shape[] shapes = {
            new Circle(5),
            new Rectangle(10, 20),
            new Triangle(10, 15)  // 새로운 도형 추가!
        };

        AreaCalculator calculator = new AreaCalculator();
        System.out.println("총 면적: " + calculator.calculateTotalArea(shapes));
    }
}
```

---

## 4. LSP: 리스코프 치환 원칙

### Liskov Substitution Principle

**정의:**
> 자식 클래스는 부모 클래스를 대체할 수 있어야 한다.

**핵심:**
- 부모 타입을 사용하는 코드는 자식 타입으로 교체해도 정상 동작해야 함
- 상속 시 부모의 계약(contract)을 반드시 지켜야 함

### 위반 예시

```java
// ❌ LSP 위반: 부모의 행동을 자식이 깨뜨림
public class Bird {
    public void fly() {
        System.out.println("날아갑니다!");
    }
}

public class Penguin extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("펭귄은 날 수 없습니다!");
    }
}
```

**사용 시 문제:**

```java
public class Main {
    public static void makeBirdFly(Bird bird) {
        bird.fly();  // 모든 Bird는 날 수 있다고 가정
    }

    public static void main(String[] args) {
        Bird sparrow = new Bird();
        makeBirdFly(sparrow);  // ✅ 정상 동작

        Bird penguin = new Penguin();
        makeBirdFly(penguin);  // ❌ 예외 발생!
    }
}
```

### 준수 예시

```java
// ✅ LSP 준수: 추상화 계층 재설계
public abstract class Bird {
    public abstract void move();
}

public class FlyingBird extends Bird {
    @Override
    public void move() {
        fly();
    }

    public void fly() {
        System.out.println("날아갑니다!");
    }
}

public class Penguin extends Bird {
    @Override
    public void move() {
        swim();
    }

    public void swim() {
        System.out.println("헤엄칩니다!");
    }
}
```

**사용:**

```java
public class Main {
    public static void makeBirdMove(Bird bird) {
        bird.move();  // 모든 Bird는 이동할 수 있음
    }

    public static void main(String[] args) {
        Bird sparrow = new FlyingBird();
        makeBirdMove(sparrow);  // ✅ 날아갑니다!

        Bird penguin = new Penguin();
        makeBirdMove(penguin);  // ✅ 헤엄칩니다!
    }
}
```

---

## 5. ISP: 인터페이스 분리 원칙

### Interface Segregation Principle

**정의:**
> 클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 한다.

**핵심:**
- 큰 인터페이스를 작은 인터페이스로 분리
- 필요한 메서드만 구현

### 위반 예시

```java
// ❌ ISP 위반: 너무 큰 인터페이스
public interface Machine {
    void print();
    void scan();
    void fax();
}

// 단순 프린터는 scan, fax 불필요
public class SimplePrinter implements Machine {
    @Override
    public void print() {
        System.out.println("출력합니다.");
    }

    @Override
    public void scan() {
        throw new UnsupportedOperationException("스캔 기능 없음");
    }

    @Override
    public void fax() {
        throw new UnsupportedOperationException("팩스 기능 없음");
    }
}
```

**문제점:**
- SimplePrinter는 scan, fax를 사용하지 않지만 구현해야 함
- 불필요한 의존성 발생

### 준수 예시

```java
// ✅ ISP 준수: 인터페이스 분리
public interface Printer {
    void print();
}

public interface Scanner {
    void scan();
}

public interface Fax {
    void fax();
}

// 단순 프린터는 필요한 것만 구현
public class SimplePrinter implements Printer {
    @Override
    public void print() {
        System.out.println("출력합니다.");
    }
}

// 복합기는 모든 기능 구현
public class MultiFunctionPrinter implements Printer, Scanner, Fax {
    @Override
    public void print() {
        System.out.println("출력합니다.");
    }

    @Override
    public void scan() {
        System.out.println("스캔합니다.");
    }

    @Override
    public void fax() {
        System.out.println("팩스 전송합니다.");
    }
}
```

---

## 6. DIP: 의존성 역전 원칙

### Dependency Inversion Principle

**정의:**
> 고수준 모듈은 저수준 모듈에 의존하지 않아야 한다. 둘 다 추상화에 의존해야 한다.

**핵심:**
- 구체적인 클래스가 아닌 인터페이스에 의존
- 유연하고 테스트 가능한 코드

### 위반 예시

```java
// ❌ DIP 위반: 구체 클래스에 직접 의존
public class MySQLDatabase {
    public void save(String data) {
        System.out.println("MySQL에 저장: " + data);
    }
}

public class UserService {
    private MySQLDatabase database;  // 구체 클래스에 의존!

    public UserService() {
        this.database = new MySQLDatabase();
    }

    public void saveUser(String userData) {
        database.save(userData);
    }
}
```

**문제점:**
- PostgreSQL로 변경하려면 UserService 수정 필요
- 테스트 시 실제 DB 필요 (단위 테스트 어려움)

### 준수 예시

```java
// ✅ DIP 준수: 추상화에 의존
public interface Database {
    void save(String data);
}

public class MySQLDatabase implements Database {
    @Override
    public void save(String data) {
        System.out.println("MySQL에 저장: " + data);
    }
}

public class PostgreSQLDatabase implements Database {
    @Override
    public void save(String data) {
        System.out.println("PostgreSQL에 저장: " + data);
    }
}

public class UserService {
    private Database database;  // 인터페이스에 의존!

    // 의존성 주입 (Dependency Injection)
    public UserService(Database database) {
        this.database = database;
    }

    public void saveUser(String userData) {
        database.save(userData);
    }
}
```

**사용:**

```java
public class Main {
    public static void main(String[] args) {
        // MySQL 사용
        Database mysqlDB = new MySQLDatabase();
        UserService service1 = new UserService(mysqlDB);
        service1.saveUser("User1");

        // PostgreSQL로 쉽게 교체
        Database postgresDB = new PostgreSQLDatabase();
        UserService service2 = new UserService(postgresDB);
        service2.saveUser("User2");
    }
}
```

---

## 7. SOLID 원칙 종합 정리

### 원칙별 핵심 요약

| 원칙 | 질문 | 해결책 |
|------|------|--------|
| **SRP** | 클래스가 여러 일을 하나요? | 책임을 분리하세요 |
| **OCP** | 새 기능 추가 시 기존 코드 수정하나요? | 추상화를 사용하세요 |
| **LSP** | 자식이 부모를 대체할 수 없나요? | 상속 구조를 재설계하세요 |
| **ISP** | 사용하지 않는 메서드를 구현하나요? | 인터페이스를 분리하세요 |
| **DIP** | 구체 클래스에 직접 의존하나요? | 인터페이스에 의존하세요 |

### 실무 적용 가이드

**우선순위:**
1. **SRP**: 가장 기본, 항상 지키려 노력
2. **DIP**: 유연한 설계의 핵심
3. **OCP**: 확장 가능한 코드
4. **ISP**: 명확한 인터페이스
5. **LSP**: 올바른 상속

**주의:**
- SOLID는 가이드이지 절대 법칙이 아님
- 과도한 추상화는 오히려 복잡도 증가
- 상황에 맞게 적절히 적용

---

## 8. 실습 문제

### 문제 1: SOLID 위반 찾기

다음 코드에서 어떤 SOLID 원칙을 위반했는지 찾고 개선하세요.

```java
public class OrderProcessor {
    public void processOrder(Order order) {
        // 주문 검증
        if (order.getItems().isEmpty()) {
            throw new IllegalArgumentException("주문 항목이 없습니다.");
        }

        // 재고 확인
        for (Item item : order.getItems()) {
            if (item.getStock() < item.getQuantity()) {
                throw new IllegalStateException("재고 부족");
            }
        }

        // DB 저장
        System.out.println("DB에 주문 저장");

        // 이메일 발송
        System.out.println("주문 확인 이메일 발송");

        // 결제 처리
        System.out.println("결제 처리");
    }
}
```

**질문:**
1. 어떤 SOLID 원칙을 위반했나요?
2. 어떻게 개선할 수 있나요?

### 문제 2: SOLID 준수 설계

**요구사항:**

알림 시스템을 설계하세요.
- 이메일, SMS, 푸시 알림 지원
- 새로운 알림 방식 추가 가능
- 각 알림 방식을 독립적으로 테스트 가능

**SOLID 원칙을 모두 고려하여 설계하세요.**

---

## 요약

### SOLID 원칙

| 원칙 | 영어 | 핵심 |
|------|------|------|
| **S** | Single Responsibility | 하나의 책임 |
| **O** | Open-Closed | 확장엔 열림, 수정엔 닫힘 |
| **L** | Liskov Substitution | 자식은 부모 대체 가능 |
| **I** | Interface Segregation | 인터페이스 분리 |
| **D** | Dependency Inversion | 추상화에 의존 |

### 좋은 설계의 특징

SOLID 원칙을 따르면:
- ✅ **유지보수** 쉬움
- ✅ **테스트** 쉬움
- ✅ **확장** 쉬움
- ✅ **이해** 쉬움
- ✅ **재사용** 쉬움

### 다음 단계

- 7장: Java 고급 문법 및 API (제네릭, 컬렉션)
- 실제 프로젝트에서 SOLID 원칙 적용하기
- 디자인 패턴 학습 (SOLID의 구체적 구현)
