# 5.2. 다형성과 메서드 오버라이딩

> 다형성의 개념을 이해하고, 메서드 오버라이딩과 Object 클래스의 주요 메서드를 활용하는 방법을 학습합니다.

## 학습 목표
- 다형성의 개념과 장점 이해
- 업캐스팅과 다운캐스팅 구분
- Object 클래스의 주요 메서드 오버라이딩
- instanceof 연산자 활용법 학습

---

## 1. 다형성(Polymorphism)이란?

### 개념

**다형성(Polymorphism)**이란, **상위 타입의 참조 변수로 하위 타입의 객체를 참조**할 수 있도록 하는 특성입니다.

**어원:**
- Poly (여러) + Morph (형태) = "여러 가지 형태를 가지는 성질"

### 기본 예시

```java
class Shape {
    public int calculateArea() {
        return 0;
    }
}

class Triangle extends Shape {
    private int width;
    private int height;

    public Triangle(int width, int height) {
        this.width = width;
        this.height = height;
    }

    @Override
    public int calculateArea() {
        return (this.width * this.height) / 2;
    }
}

class Rectangle extends Shape {
    private int width;
    private int height;

    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }

    @Override
    public int calculateArea() {
        return this.width * this.height;
    }
}
```

**다형성 적용:**

```java
// 하위 타입 변수에 할당 (일반적인 방법)
Triangle triangle = new Triangle(10, 5);
Rectangle rectangle = new Rectangle(15, 30);

// 상위 타입 변수에 할당 (다형성)
Shape shape1 = new Triangle(10, 5);
Shape shape2 = new Rectangle(15, 30);

// 모두 같은 메서드 호출
System.out.println(shape1.calculateArea());  // 25
System.out.println(shape2.calculateArea());  // 450
```

**핵심:**
- `Shape` 타입 하나로 `Triangle`, `Rectangle` 등 여러 타입을 참조
- 실제 실행되는 메서드는 **객체의 실제 타입**에 따라 결정

### JavaScript와의 비교

```javascript
// JavaScript - 덕 타이핑(Duck Typing)
class Shape {
    calculateArea() {
        return 0;
    }
}

class Triangle extends Shape {
    constructor(width, height) {
        super();
        this.width = width;
        this.height = height;
    }

    calculateArea() {
        return (this.width * this.height) / 2;
    }
}

// JavaScript는 타입을 명시하지 않음
let shape = new Triangle(10, 5);
console.log(shape.calculateArea());  // 25
```

**차이점:**
- Java: 컴파일 타임에 타입 체크, 명시적 타입 선언 필요
- JavaScript: 런타임에 타입 체크, 암묵적 타입 변환

---

## 2. 다형성의 장점

### 1. 코드의 유연성

다양한 객체를 하나의 타입으로 처리 가능합니다.

**다형성 미사용:**

```java
public class Main {
    public static void main(String[] args) {
        Triangle triangle = new Triangle(10, 5);
        printTriangleArea(triangle);

        Rectangle rectangle = new Rectangle(15, 30);
        printRectangleArea(rectangle);
    }

    // 삼각형 전용 메서드
    private static void printTriangleArea(Triangle triangle) {
        int area = triangle.calculateArea();
        System.out.println("삼각형의 면적: " + area);
    }

    // 사각형 전용 메서드
    private static void printRectangleArea(Rectangle rectangle) {
        int area = rectangle.calculateArea();
        System.out.println("사각형의 면적: " + area);
    }
}
```

**문제점:**
- 도형이 추가될 때마다 새로운 메서드 필요
- 코드 중복 발생

**다형성 사용:**

```java
public class Main {
    public static void main(String[] args) {
        Shape shape1 = new Triangle(10, 5);
        Shape shape2 = new Rectangle(15, 30);

        printShapeArea(shape1);
        printShapeArea(shape2);
    }

    // 하나의 메서드로 통합
    private static void printShapeArea(Shape shape) {
        int area = shape.calculateArea();

        if (shape instanceof Triangle) {
            System.out.println("삼각형의 면적: " + area);
        } else if (shape instanceof Rectangle) {
            System.out.println("사각형의 면적: " + area);
        }
    }
}
```

**개선점:**
- 하나의 메서드로 여러 타입 처리
- 코드 중복 제거

### 2. 확장성

새로운 타입 추가 시 기존 코드 수정 최소화

```java
class Circle extends Shape {
    private int radius;

    public Circle(int radius) {
        this.radius = radius;
    }

    @Override
    public int calculateArea() {
        return (int) (Math.PI * radius * radius);
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Shape shape3 = new Circle(5);
        printShapeArea(shape3);  // 기존 메서드 그대로 사용!
    }

    private static void printShapeArea(Shape shape) {
        int area = shape.calculateArea();

        if (shape instanceof Triangle) {
            System.out.println("삼각형의 면적: " + area);
        } else if (shape instanceof Rectangle) {
            System.out.println("사각형의 면적: " + area);
        } else if (shape instanceof Circle) {  // else if만 추가
            System.out.println("원의 면적: " + area);
        }
    }
}
```

### 3. 재사용성

배열이나 컬렉션으로 여러 타입을 한번에 관리

```java
public class Main {
    public static void main(String[] args) {
        // 다형성으로 다양한 도형을 하나의 배열에 저장
        Shape[] shapes = {
            new Triangle(10, 5),
            new Rectangle(15, 30),
            new Circle(7)
        };

        // 반복문으로 일괄 처리
        for (Shape shape : shapes) {
            System.out.println("면적: " + shape.calculateArea());
        }
    }
}
```

**실행 결과:**
```
면적: 25
면적: 450
면적: 153
```

---

## 3. 업캐스팅(Upcasting)

### 개념

**업캐스팅**은 하위 타입의 객체를 상위 타입으로 참조하는 것입니다.

```java
// 자동 형변환 (암묵적)
Shape shape = new Triangle(10, 5);
```

**특징:**
- 형변환 생략 가능 (자동)
- 안전한 형변환 (컴파일러가 보장)
- 하위 타입의 고유 멤버는 접근 불가

### 예시

```java
class Animal {
    public void eat() {
        System.out.println("동물이 먹습니다.");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("멍멍!");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();   // ✅ Animal의 메서드 사용 가능
        dog.bark();  // ✅ Dog의 메서드 사용 가능

        // 업캐스팅
        Animal animal = dog;  // 자동 형변환
        animal.eat();   // ✅ Animal의 메서드 사용 가능
        // animal.bark();  // ❌ 컴파일 에러! Dog의 메서드는 접근 불가
    }
}
```

**핵심:**
- 참조 변수 타입이 `Animal`이므로 `Animal`에 정의된 멤버만 접근 가능
- 실제 객체는 `Dog`이므로 오버라이딩된 메서드는 `Dog` 버전 실행

---

## 4. 다운캐스팅(Downcasting)

### 개념

**다운캐스팅**은 상위 타입으로 참조된 객체를 다시 하위 타입으로 변환하는 것입니다.

```java
// 명시적 형변환 필요
Animal animal = new Dog();  // 업캐스팅
Dog dog = (Dog) animal;     // 다운캐스팅
```

**특징:**
- 형변환 명시 필요 (수동)
- 잘못된 형변환 시 `ClassCastException` 발생 가능
- 하위 타입의 고유 멤버 접근 가능

### 예시

```java
public class Main {
    public static void main(String[] args) {
        Animal animal = new Dog();  // 업캐스팅

        // animal.bark();  // ❌ 컴파일 에러

        // 다운캐스팅
        Dog dog = (Dog) animal;
        dog.bark();  // ✅ 가능
    }
}
```

### 잘못된 다운캐스팅

```java
public class Main {
    public static void main(String[] args) {
        Animal animal = new Animal();

        // ❌ 런타임 에러! ClassCastException 발생
        Dog dog = (Dog) animal;
    }
}
```

**에러 메시지:**
```
Exception in thread "main" java.lang.ClassCastException:
Animal cannot be cast to Dog
```

**원인:**
- `animal` 객체는 실제로 `Animal` 타입
- `Dog`로 형변환 불가능

---

## 5. instanceof 연산자

### 개념

`instanceof` 연산자는 객체가 특정 타입인지 확인합니다.

**문법:**
```java
객체 instanceof 타입
```

**반환값:**
- `true`: 해당 타입이거나 하위 타입
- `false`: 해당 타입이 아님

### 안전한 다운캐스팅

```java
public class Main {
    public static void main(String[] args) {
        Animal animal = new Dog();

        // 다운캐스팅 전에 타입 확인
        if (animal instanceof Dog) {
            Dog dog = (Dog) animal;
            dog.bark();  // 안전하게 실행
        }
    }
}
```

### 상속 계층 확인

```java
class Animal { } 
class Dog extends Animal { } 
class Poodle extends Dog { } 
```

```java
public class Main {
    public static void main(String[] args) {
        Animal animal = new Poodle();

        System.out.println(animal instanceof Animal);  // true
        System.out.println(animal instanceof Dog);     // true
        System.out.println(animal instanceof Poodle);  // true

        Animal animal2 = new Dog();
        System.out.println(animal2 instanceof Poodle); // false
    }
}
```

**핵심:**
- 상속 계층을 따라 상위 타입도 `true` 반환
- 실제 객체 타입보다 하위 타입은 `false`

### JavaScript와의 비교

```javascript
// JavaScript - instanceof
class Animal { } 
class Dog extends Animal { } 

let animal = new Dog();
console.log(animal instanceof Animal);  // true
console.log(animal instanceof Dog);     // true
```

**차이점:**
- Java: 컴파일 타임에도 타입 체크
- JavaScript: 런타임에만 체크

---

## 6. Object 클래스의 주요 메서드

### toString() 오버라이딩

**기본 동작:**

```java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Person person = new Person("홍길동", 30);
        System.out.println(person);
    }
}
```

**출력:**
```
Person@2ff4acd0
```

**오버라이딩:**

```java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "}";
    }
}
```

**출력:**
```
Person{name='홍길동', age=30}
```

**IDE 자동 생성:**
- IntelliJ: Alt + Insert → toString()
- Eclipse: Source → Generate toString()

### equals() 오버라이딩

**기본 동작 (주소 비교):**

```java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Person p1 = new Person("홍길동", 30);
        Person p2 = new Person("홍길동", 30);

        System.out.println(p1 == p2);         // false (주소 비교)
        System.out.println(p1.equals(p2));    // false (기본 equals는 == 사용)
    }
}
```

**오버라이딩 (값 비교):**

```java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object obj) {
        // 1. 동일 객체 확인
        if (this == obj) {
            return true;
        }

        // 2. null 확인
        if (obj == null) {
            return false;
        }

        // 3. 타입 확인
        if (getClass() != obj.getClass()) {
            return false;
        }

        // 4. 형변환 후 필드 비교
        Person other = (Person) obj;
        return this.age == other.age &&
               this.name.equals(other.name);
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Person p1 = new Person("홍길동", 30);
        Person p2 = new Person("홍길동", 30);

        System.out.println(p1.equals(p2));  // true
    }
}
```

**JavaScript 비교:**

```javascript
// JavaScript는 equals 메서드 없음
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    // 직접 비교 메서드 만들어야 함
    equals(other) {
        return this.name === other.name && this.age === other.age;
    }
}
```

### hashCode() 오버라이딩

**중요 규칙:**
> equals()를 오버라이딩하면 **반드시** hashCode()도 함께 오버라이딩해야 합니다.

**이유:**
- HashMap, HashSet 등 해시 기반 컬렉션 사용 시 필수
- equals()가 true면 hashCode()도 같아야 함

```java
import java.util.Objects;

public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person other = (Person) obj;
        return this.age == other.age && this.name.equals(other.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```

**예시:**

```java
import java.util.HashSet;

public class Main {
    public static void main(String[] args) {
        HashSet<Person> set = new HashSet<>();

        Person p1 = new Person("홍길동", 30);
        Person p2 = new Person("홍길동", 30);

        set.add(p1);
        set.add(p2);

        // hashCode()를 오버라이딩하지 않으면: 2 (중복 허용)
        // hashCode()를 오버라이딩하면: 1 (중복 제거)
        System.out.println("Set 크기: " + set.size());
    }
}
```

---

## 7. 메서드 오버라이딩 심화

### 공변 반환 타입 (Covariant Return Type)

Java 5부터 오버라이딩 시 반환 타입을 **하위 타입**으로 변경 가능합니다.

```java
class Animal {
    public Animal getThis() {
        return this;
    }
}

class Dog extends Animal {
    @Override
    public Dog getThis() {  // Animal → Dog (하위 타입)
        return this;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        Dog result = dog.getThis();  // 형변환 불필요
    }
}
```

### @Override 어노테이션의 중요성

```java
class Parent {
    public void show() {
        System.out.println("Parent");
    }
}

class Child extends Parent {
    // 오타로 인한 오버로딩 (의도와 다름)
    public void Show() {  // 대문자 S
        System.out.println("Child");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Parent p = new Child();
        p.show();  // "Parent" 출력 (오버라이딩 안됨!)
    }
}
```

**@Override 사용 시:**

```java
class Child extends Parent {
    @Override
    public void Show() {  // 컴파일 에러 발생!
        System.out.println("Child");
    }
}
```

**에러 메시지:**
```
Method does not override method from its superclass
```

---

## 8. 실습 문제

### 문제 1: 동물 울음소리

다음 요구사항에 맞게 코드를 작성하세요.

**요구사항:**
- `Animal` 클래스: `makeSound()` 메서드
- `Dog`, `Cat`, `Cow` 클래스: `Animal` 상속 후 `makeSound()` 오버라이딩
- 배열을 사용해 모든 동물의 울음소리 출력

**테스트 코드:**
```java
public class Main {
    public static void main(String[] args) {
        Animal[] animals = {
            new Dog(),
            new Cat(),
            new Cow()
        };

        for (Animal animal : animals) {
            animal.makeSound();
        }
    }
}
```

**예상 출력:**
```
멍멍!
야옹~
음메~
```

<details>
<summary>해답</summary>

```java
class Animal {
    public void makeSound() {
        System.out.println("동물이 웁니다.");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("멍멍!");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("야옹~");
    }
}

class Cow extends Animal {
    @Override
    public void makeSound() {
        System.out.println("음메~");
    }
}
```
</details>

### 문제 2: 도형 면적 계산기

다형성을 활용하여 다양한 도형의 면적을 계산하는 프로그램을 작성하세요.

**요구사항:**
- `Shape` 클래스: `calculateArea()`, `toString()` 메서드
- `Circle`, `Rectangle`, `Triangle` 클래스: 각 도형의 면적 계산 구현
- `toString()`으로 "도형이름: 면적" 형식 출력

**테스트 코드:**
```java
public class Main {
    public static void main(String[] args) {
        Shape[] shapes = {
            new Circle(5),
            new Rectangle(10, 20),
            new Triangle(10, 15)
        };

        for (Shape shape : shapes) {
            System.out.println(shape);  // toString() 자동 호출
        }
    }
}
```

**예상 출력:**
```
원: 78.5
사각형: 200
삼각형: 75
```

<details>
<summary>해답</summary>

```java
class Shape {
    public double calculateArea() {
        return 0.0;
    }
}

class Circle extends Shape {
    private int radius;

    public Circle(int radius) {
        this.radius = radius;
    }

    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }

    @Override
    public String toString() {
        return String.format("원: %.1f", calculateArea());
    }
}

class Rectangle extends Shape {
    private int width;
    private int height;

    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }

    @Override
    public double calculateArea() {
        return width * height;
    }

    @Override
    public String toString() {
        return String.format("사각형: %.0f", calculateArea());
    }
}

class Triangle extends Shape {
    private int width;
    private int height;

    public Triangle(int width, int height) {
        this.width = width;
        this.height = height;
    }

    @Override
    public double calculateArea() {
        return (double) (width * height) / 2;
    }

    @Override
    public String toString() {
        return String.format("삼각형: %.0f", calculateArea());
    }
}
```
</details>

### 문제 3: Person equals/hashCode 구현

`Person` 클래스를 작성하고 다음을 구현하세요.

**요구사항:**
- 필드: name, age, email
- `equals()`: 모든 필드가 같으면 true
- `hashCode()`: Objects.hash() 사용
- `toString()`: "Person{name='홍길동', age=30, email='hong@example.com'}" 형식

**테스트 코드:**
```java
public class Main {
    public static void main(String[] args) {
        Person p1 = new Person("홍길동", 30, "hong@example.com");
        Person p2 = new Person("홍길동", 30, "hong@example.com");
        Person p3 = new Person("김철수", 25, "kim@example.com");

        System.out.println(p1.equals(p2));  // true
        System.out.println(p1.equals(p3));  // false
        System.out.println(p1);  // toString() 출력
    }
}
```

<details>
<summary>해답</summary>

```java
import java.util.Objects;

class Person {
    private String name;
    private int age;
    private String email;

    public Person(String name, int age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &&
                Objects.equals(name, person.name) &&
                Objects.equals(email, person.email);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age, email);
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + "'" +
                ", age=" + age +
                ", email='" + email + "'" +
                '}';
    }
}
```
</details>

### 문제 4: instanceof 활용

다음 조건에 맞는 `printAnimalInfo()` 메서드를 작성하세요.

**요구사항:**
- `Animal` 타입 매개변수 받기
- `instanceof`로 타입 확인 후 각 동물별 특수 기능 호출
  - Dog: `bark()` 호출
  - Cat: `meow()` 호출
  - Bird: `fly()` 호출

**클래스 구조:**
```java
class Animal {
    public void eat() {
        System.out.println("동물이 먹습니다.");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("멍멍!");
    }
}

class Cat extends Animal {
    public void meow() {
        System.out.println("야옹~");
    }
}

class Bird extends Animal {
    public void fly() {
        System.out.println("날아갑니다!");
    }
}
```

<details>
<summary>해답</summary>

```java
public static void printAnimalInfo(Animal animal) {
    animal.eat(); // 공통 기능

    if (animal instanceof Dog) {
        Dog dog = (Dog) animal;
        dog.bark();
    } else if (animal instanceof Cat) {
        Cat cat = (Cat) animal;
        cat.meow();
    } else if (animal instanceof Bird) {
        Bird bird = (Bird) animal;
        bird.fly();
    }
}

// 테스트 코드
public static void main(String[] args) {
    printAnimalInfo(new Dog());
    System.out.println("---");
    printAnimalInfo(new Cat());
    System.out.println("---");
    printAnimalInfo(new Bird());
}
```
</details>

---

## 요약

| 개념 | 설명 |
|------|------|
| **다형성** | 상위 타입으로 하위 타입 객체 참조 |
| **업캐스팅** | 하위 → 상위 타입 (자동 형변환) |
| **다운캐스팅** | 상위 → 하위 타입 (명시적 형변환) |
| **instanceof** | 객체의 타입 확인 연산자 |
| **toString()** | 객체를 문자열로 표현 |
| **equals()** | 객체의 값 비교 |
| **hashCode()** | 해시 기반 컬렉션에서 사용 |

**다형성의 장점:**
- ✅ 코드 유연성 증가
- ✅ 확장성 향상
- ✅ 재사용성 증가

**주의사항:**
- equals() 오버라이딩 시 반드시 hashCode()도 오버라이딩
- 다운캐스팅 전에 instanceof로 타입 확인
- @Override 어노테이션 항상 사용

**Java vs JavaScript:**
- Java: 정적 타입, 컴파일 타임 체크, 명시적 형변환
- JavaScript: 동적 타입, 런타임 체크, 암묵적 형변환

**다음 학습:**
- 5.3장에서 추상 클래스와 인터페이스를 통한 다형성 심화 학습

