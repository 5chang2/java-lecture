# 5.1. 상속과 super

> 상속의 개념을 이해하고, super 키워드를 활용하여 부모 클래스의 기능을 확장하는 방법을 학습합니다.

## 학습 목표
- 상속의 개념과 필요성 이해
- extends 키워드 사용법 익히기
- super()와 super 키워드의 차이점 이해
- 코드 재사용성을 높이는 상속 활용법 학습

---

## 1. 상속(Inheritance)이란?

### 개념

**상속(Inheritance)**이란, 기존 클래스(부모 클래스)의 멤버를 새로운 클래스(자식 클래스)가 **물려받아** 사용하는 기능입니다.

**용어 정리:**
- **부모 클래스(Parent Class)** = 상위 클래스(Super Class) = 기반 클래스(Base Class)
  - 자신의 멤버 변수와 메서드를 물려주는 클래스
- **자식 클래스(Child Class)** = 하위 클래스(Sub Class) = 파생 클래스(Derived Class)
  - 기존 클래스의 멤버를 물려받는 클래스

### 기본 문법

```java
public class Parent {
    // 부모 클래스
}

public class Child extends Parent {
    // 자식 클래스
}
```

**핵심 키워드: `extends`**
- "확장하다"라는 뜻
- 기존 클래스의 기능에 더해 **새로운 클래스에서 기능을 확장**한다는 의미

### JavaScript와의 비교

| 특징 | Java | JavaScript (ES6+) |
|------|------|-------------------|
| 상속 키워드 | `extends` | `extends` |
| 부모 생성자 호출 | `super()` (명시적) | `super()` (명시적) |
| 다중 상속 | ❌ 불가능 (단일 상속만) | ❌ 불가능 (단일 상속만) |
| 인터페이스 | ✅ 가능 (`implements`) | ❌ 없음 |
| 타입 체크 | ✅ 컴파일 타임 | ❌ 런타임 |

```javascript
// JavaScript - 상속 예시
class Parent {
    constructor(name) {
        this.name = name;
    }
}

class Child extends Parent {
    constructor(name, age) {
        super(name);  // 부모 생성자 호출
        this.age = age;
    }
}
```

**차이점:**
- JavaScript는 프로토타입 기반 상속을 `class` 문법으로 감싼 것
- Java는 진정한 클래스 기반 상속

---

## 2. 왜 상속을 사용하는가?

### 상속의 장점

상속은 **코드의 재사용성을 높이고 중복을 제거**할 수 있습니다.

### 상속을 사용하지 않은 경우

먼저, 사람을 의미하는 `Person` 클래스가 있습니다.

```java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return this.name;
    }

    public int getAge() {
        return this.age;
    }
}
```

이제 "학생"을 표현하는 `Student` 클래스가 필요하다고 가정해봅시다.

**학생의 요구사항:**
- 사람의 속성(이름, 나이) + 학생만의 속성(전공)
- 사람의 기능 + 학생만의 기능

**상속 없이 구현하면:**

```java
public class Student {
    // Person과 중복되는 필드
    private String name;
    private int age;

    // Student만의 필드
    private String major;

    public Student(String name, int age, String major) {
        this.name = name;
        this.age = age;
        this.major = major;
    }

    // Person과 중복되는 메서드
    public String getName() {
        return this.name;
    }

    public int getAge() {
        return this.age;
    }

    // Student만의 메서드
    public String getMajor() {
        return this.major;
    }
}
```

**문제점:**
- Person의 모든 코드를 Student에 **중복으로 작성**
- Person이 수정되면 Student도 함께 수정해야 함
- 유지보수성 저하

### 상속을 사용한 경우

```java
public class Student extends Person {
    // Student만의 필드만 추가
    private String major;

    public Student(String name, int age, String major) {
        super(name, age);  // 부모 클래스의 생성자 호출
        this.major = major;
    }

    // Student만의 메서드만 추가
    public String getMajor() {
        return this.major;
    }
}
```

**개선점:**
- Person의 필드와 메서드를 그대로 사용 가능
- Student는 **확장**에만 집중
- 코드 중복 제거
- Person 수정 시 Student는 자동으로 반영됨

**사용 예시:**

```java
public class Main {
    public static void main(String[] args) {
        Student student = new Student("김철수", 21, "컴퓨터공학");

        // 부모 클래스의 메서드 사용 가능
        System.out.println(student.getName());  // "김철수"
        System.out.println(student.getAge());   // 21

        // 자식 클래스의 메서드 사용
        System.out.println(student.getMajor()); // "컴퓨터공학"
    }
}
```

---

## 3. 상속의 규칙

### 규칙 1: 단일 상속만 가능

Java는 **오직 하나의 부모 클래스만 상속** 가능합니다.

```java
// ❌ 컴파일 에러!
public class Child extends Parent1, Parent2 {
    // 오류: Class cannot extend multiple classes
}
```

**왜 다중 상속을 금지할까?**
- **다이아몬드 문제** 방지
- 같은 이름의 메서드가 여러 부모에 있으면 어떤 것을 호출해야 할지 모호함

**해결책:**
- **인터페이스(Interface)** 사용 (5.3 장에서 학습)

### 규칙 2: 생성자와 초기화 블록은 상속되지 않음

상속되는 것:
- ✅ 멤버 변수(필드)
- ✅ 메서드

상속되지 않는 것:
- ❌ 생성자
- ❌ 초기화 블록

```java
public class Parent {
    private String name;

    // 생성자는 상속되지 않음
    public Parent(String name) {
        this.name = name;
    }
}

public class Child extends Parent {
    // 반드시 생성자에서 super()로 부모 생성자 호출 필요
    public Child(String name) {
        super(name);
    }
}
```

### 규칙 3: private 멤버는 상속되지만 접근 불가

```java
public class Parent {
    private String privateField;
    public String publicField;
}

public class Child extends Parent {
    public void test() {
        // System.out.println(privateField);  // ❌ 컴파일 에러
        System.out.println(publicField);      // ✅ 접근 가능
    }
}
```

**설명:**
- `private` 필드는 상속은 되지만 직접 접근은 불가능
- getter/setter를 통해서만 접근 가능

---

## 4. super() - 부모 클래스의 생성자 호출

### 개념

`super()`는 자식 클래스에서 **부모 클래스의 생성자를 호출**하는데 사용됩니다.

**비교:**
- `this()`: 같은 클래스의 다른 생성자 호출
- `super()`: 부모 클래스의 생성자 호출

### 왜 필요한가?

자식 클래스는 부모 클래스를 포함하므로:
1. **부모 클래스의 멤버 초기화가 우선**되어야 함
2. 자식 생성자의 **맨 첫 줄**에서 `super()` 호출 필요

```java
public class Child extends Parent {
    private String childField;

    public Child() {
        super();  // ⭐ 맨 첫 줄에서 반드시 호출
        this.childField = "초기화";
    }
}
```

### 특징 1: 생략하면 자동 삽입

부모 클래스에 **기본 생성자**가 있으면, `super()`를 생략 가능합니다.

```java
public class Parent {
    // 기본 생성자
    public Parent() {
        System.out.println("Parent 생성자");
    }
}
```

```java
public class Child extends Parent {
    public Child() {
        // super();  // ⭐ 컴파일러가 자동으로 삽입
        System.out.println("Child 생성자");
    }
}
```

**실행 결과:**
```
Parent 생성자
Child 생성자
```

**JavaScript 비교:**
```javascript
class Child extends Parent {
    constructor() {
        super();  // JavaScript는 명시적으로 작성해야 함
        console.log("Child 생성자");
    }
}
```

### 특징 2: 부모에 기본 생성자가 없으면 명시적 호출 필수

부모 클래스에 **매개변수가 있는 생성자만** 존재하는 경우:

```java
public class Parent {
    private String parentValue;

    // 기본 생성자 없음
    public Parent(String parentValue) {
        this.parentValue = parentValue;
    }
}
```

```java
public class Child extends Parent {
    private String childValue;

    public Child(String parentValue, String childValue) {
        super(parentValue);  // ⭐ 명시적으로 호출해야 함
        this.childValue = childValue;
    }

    // ❌ 기본 생성자 만들 수 없음
    // public Child() {
    //     // super();  // 에러! 부모에 기본 생성자 없음
    // }
}
```

**에러 메시지:**
```
There is no default constructor available in 'Parent'
```

### 실습: 생성자 호출 순서 이해하기

```java
public class GrandParent {
    public GrandParent() {
        System.out.println("1. GrandParent 생성자");
    }
}

public class Parent extends GrandParent {
    public Parent() {
        super();  // GrandParent() 호출
        System.out.println("2. Parent 생성자");
    }
}

public class Child extends Parent {
    public Child() {
        super();  // Parent() 호출
        System.out.println("3. Child 생성자");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Child child = new Child();
    }
}
```

**실행 결과:**
```
1. GrandParent 생성자
2. Parent 생성자
3. Child 생성자
```

**핵심:**
- 가장 상위 부모부터 차례대로 생성자 실행
- 부모가 먼저 초기화되어야 자식이 안전하게 사용 가능

---

## 5. super - 부모 클래스의 멤버 참조

### 개념

`super`는 부모 클래스의 멤버 변수나 메서드를 참조할 때 사용됩니다.

**비교:**
- `this`: 인스턴스 자신에 대한 참조 변수
- `super`: 부모 인스턴스에 대한 참조 변수

### 언제 사용하는가?

일반적으로 `this`로 부모 멤버에 접근 가능하지만, **부모와 자식의 멤버 이름이 같을 때** 구별이 필요합니다.

### 필드 참조

```java
public class Parent {
    public String value = "부모 값";
}

public class Child extends Parent {
    public String value = "자식 값";

    public void show() {
        System.out.println(super.value);  // "부모 값"
        System.out.println(this.value);   // "자식 값"
        System.out.println(value);        // "자식 값" (this 생략)
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        child.show();
    }
}
```

**실행 결과:**
```
부모 값
자식 값
자식 값
```

### 메서드 참조

부모 클래스의 메서드를 확장할 때 유용합니다.

```java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void introduce() {
        System.out.println("안녕하세요. " + this.name + "입니다.");
        System.out.println("나이는 " + this.age + "살 입니다.");
    }
}
```

```java
public class Student extends Person {
    private String major;

    public Student(String name, int age, String major) {
        super(name, age);
        this.major = major;
    }

    public void introduce() {
        super.introduce();  // 부모의 introduce() 호출
        System.out.println("전공은 " + this.major + "입니다.");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Student student = new Student("김철수", 21, "컴퓨터공학");
        student.introduce();
    }
}
```

**실행 결과:**
```
안녕하세요. 김철수입니다.
나이는 21살 입니다.
전공은 컴퓨터공학입니다.
```

**장점:**
- 부모의 기능을 **재사용**하면서 **확장** 가능
- 코드 중복 제거

---

## 6. 메서드 오버라이딩(Overriding) 기본

### 개념

**메서드 오버라이딩**이란, 부모 클래스로부터 상속받은 메서드를 자식 클래스에서 **재정의**하는 것입니다.

**주의: 오버로딩(Overloading)과 다릅니다!**
- **오버라이딩(Overriding)**: 부모 메서드를 **재정의**
- **오버로딩(Overloading)**: 같은 이름의 메서드를 **다른 매개변수**로 여러 개 정의 (2.4 장에서 학습)

### 오버라이딩 조건

오버라이딩이 성립하려면 다음 조건을 **모두** 만족해야 합니다:

| 조건 | 설명 |
|------|------|
| 1. 메서드 시그니처 동일 | 이름과 매개변수 정보가 같아야 함 |
| 2. 반환 타입 동일 | 반환 타입이 같아야 함 (Java 5부터 공변 반환 타입 허용) |
| 3. 접근 제어자 | 부모보다 좁은 범위로 변경 불가 |
| 4. static 메서드 | 재정의 불가 (별개의 메서드가 됨) |

```java
public class Parent {
    // protected 메서드
    protected void show() {
        System.out.println("Parent");
    }
}

public class Child extends Parent {
    // ✅ public으로 확장 가능
    @Override
    public void show() {
        System.out.println("Child");
    }

    // ❌ private으로 축소 불가
    // @Override
    // private void show() {
    //     System.out.println("Child");
    // }
}
```

### @Override 어노테이션

`@Override`는 메서드를 재정의한다는 **의도를 명시**합니다.

```java
@Override
public void introduce() {
    super.introduce();
    System.out.println("전공은 " + this.major + "입니다.");
}
```

**장점:**
- 오타로 인한 실수 방지 (오버라이딩이 아닌 새 메서드 생성 방지)
- 코드 가독성 향상
- 컴파일러가 오버라이딩 규칙 위반 검사

**붙이지 않아도 동작하지만, 반드시 사용하는 것을 권장합니다.**

### JavaScript와의 비교

```javascript
// JavaScript - 오버라이딩
class Parent {
    show() {
        console.log("Parent");
    }
}

class Child extends Parent {
    show() {  // 자동으로 오버라이딩
        console.log("Child");
    }
}
```

**차이점:**
- JavaScript는 `@Override` 같은 어노테이션 없음
- Java는 컴파일 타임에 오버라이딩 규칙 검사, JavaScript는 런타임

---

## 7. Object 클래스 - 모든 클래스의 조상

### 개념

**Object 클래스**는 모든 Java 클래스의 **최상위 부모 클래스**입니다.

```java
// 명시적으로 상속하지 않아도
public class MyClass {
    // ...
}

// 암묵적으로 Object를 상속
public class MyClass extends Object {
    // ...
}
```

**핵심:**
- 모든 클래스는 `Object`를 직접 또는 간접적으로 상속
- Object의 메서드를 자동으로 사용 가능

### 주요 메서드

| 메서드 | 설명 |
|--------|------|
| `String toString()` | 객체를 문자열로 반환 |
| `boolean equals(Object obj)` | 객체 동등성 비교 |
| `int hashCode()` | 객체의 해시 코드 반환 |

**다음 섹션(5.2)에서 자세히 학습합니다.**

---

## 8. 실습 문제

### 문제 1: Employee 상속 구조

`Employee` 클래스를 만들고, 이를 상속받는 `Manager` 클래스를 구현하세요.

**Employee 클래스:**
- 필드: 이름(name), 급여(salary)
- 생성자: 이름과 급여를 받아 초기화
- 메서드: `showInfo()` - "이름: 홍길동, 급여: 3000000원" 출력

**Manager 클래스:**
- Employee를 상속
- 추가 필드: 부서명(department)
- 생성자: 이름, 급여, 부서명을 받아 초기화
- 메서드: `showInfo()` 오버라이딩 - 부모의 정보 + "부서: 개발팀" 출력

**테스트 코드:**
```java
public class Main {
    public static void main(String[] args) {
        Employee emp = new Employee("홍길동", 3000000);
        emp.showInfo();
        // 출력: 이름: 홍길동, 급여: 3000000원

        System.out.println();

        Manager mgr = new Manager("김철수", 5000000, "개발팀");
        mgr.showInfo();
        // 출력: 이름: 김철수, 급여: 5000000원
        //       부서: 개발팀
    }
}
```

<details>
<summary>해답</summary>

**Employee.java**
```java
public class Employee {
    private String name;
    private int salary;

    public Employee(String name, int salary) {
        this.name = name;
        this.salary = salary;
    }

    public void showInfo() {
        System.out.println("이름: " + name + ", 급여: " + salary + "원");
    }
}
```

**Manager.java**
```java
public class Manager extends Employee {
    private String department;

    public Manager(String name, int salary, String department) {
        super(name, salary);
        this.department = department;
    }

    @Override
    public void showInfo() {
        super.showInfo();
        System.out.println("부서: " + department);
    }
}
```
</details>

### 문제 2: Vehicle 상속 구조

`Vehicle` 클래스를 만들고, 이를 상속받는 `Car`와 `Bicycle` 클래스를 구현하세요.

**Vehicle 클래스:**
- 필드: 속도(speed)
- 생성자: 기본 속도 0으로 초기화
- 메서드:
  - `accelerate(int amount)`: 속도 증가
  - `showSpeed()`: "현재 속도: 10km/h" 출력

**Car 클래스:**
- Vehicle을 상속
- 추가 필드: 연료량(fuel)
- 생성자: 연료량 100으로 초기화
- 메서드:
  - `accelerate(int amount)` 오버라이딩: 속도 증가 + 연료 감소 (속도 10 증가 시 연료 5 감소)
  - `showFuel()`: "남은 연료: 95L" 출력

**Bicycle 클래스:**
- Vehicle을 상속
- 추가 필드: 기어(gear)
- 생성자: 기어 1로 초기화
- 메서드:
  - `changeGear(int newGear)`: 기어 변경
  - `showGear()`: "현재 기어: 3단" 출력

<details>
<summary>해답</summary>

**Vehicle.java**
```java
public class Vehicle {
    protected int speed;

    public Vehicle() {
        this.speed = 0;
    }

    public void accelerate(int amount) {
        this.speed += amount;
    }

    public void showSpeed() {
        System.out.println("현재 속도: " + speed + "km/h");
    }
}
```

**Car.java**
```java
public class Car extends Vehicle {
    private int fuel;

    public Car() {
        super();
        this.fuel = 100;
    }

    @Override
    public void accelerate(int amount) {
        super.accelerate(amount);
        this.fuel -= amount / 2;
    }

    public void showFuel() {
        System.out.println("남은 연료: " + fuel + "L");
    }
}
```

**Bicycle.java**
```java
public class Bicycle extends Vehicle {
    private int gear;

    public Bicycle() {
        super();
        this.gear = 1;
    }

    public void changeGear(int newGear) {
        this.gear = newGear;
    }

    public void showGear() {
        System.out.println("현재 기어: " + gear + "단");
    }
}
```

**Main.java (테스트)**
```java
public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.accelerate(20);
        car.showSpeed(); // 현재 속도: 20km/h
        car.showFuel();  // 남은 연료: 90L

        System.out.println();

        Bicycle bike = new Bicycle();
        bike.accelerate(10);
        bike.changeGear(3);
        bike.showSpeed(); // 현재 속도: 10km/h
        bike.showGear();  // 현재 기어: 3단
    }
}
```
</details>

### 문제 3: 생성자 체인 이해하기

다음 코드의 실행 결과를 예측하고, 그 이유를 설명하세요.

```java
class A {
    public A() {
        System.out.println("A 생성자");
    }
}

class B extends A {
    public B() {
        System.out.println("B 생성자");
    }
}

class C extends B {
    public C() {
        System.out.println("C 생성자");
    }
}

public class Main {
    public static void main(String[] args) {
        C c = new C();
    }
}
```

**예상 출력:**
```
?
?
?
```

<details>
<summary>해답</summary>

**실행 결과:**
```
A 생성자
B 생성자
C 생성자
```

**이유:**
자식 클래스의 생성자는 항상 첫 줄에서 부모 클래스의 생성자(`super()`)를 호출합니다. 이 호출이 생략되면 컴파일러가 자동으로 추가합니다. 따라서 `new C()`를 호출하면 `C` 생성자 → `B` 생성자 → `A` 생성자 순으로 호출 스택이 쌓이고, 실행은 역순인 `A` → `B` → `C` 순서로 진행됩니다.
</details>

---

## 요약

| 개념 | 설명 |
|------|------|
| **상속** | 기존 클래스의 멤버를 새 클래스가 물려받는 기능 |
| **extends** | 상속을 위한 키워드 |
| **super()** | 부모 클래스의 생성자 호출 (생성자 첫 줄) |
| **super** | 부모 클래스의 멤버 참조 |
| **오버라이딩** | 부모 메서드를 자식에서 재정의 |
| **@Override** | 오버라이딩 의도를 명시하는 어노테이션 |
| **Object** | 모든 클래스의 최상위 부모 |

**상속의 장점:**
- ✅ 코드 재사용성 향상
- ✅ 중복 제거
- ✅ 유지보수 용이
- ✅ 확장성 증가

**Java vs JavaScript:**
- Java: 진정한 클래스 기반, 컴파일 타임 타입 체크
- JavaScript: 프로토타입 기반, 런타임 타입 체크

**다음 학습:**
- 5.2장에서 다형성과 메서드 오버라이딩을 심화 학습
- Object 클래스의 주요 메서드(toString, equals, hashCode) 학습
