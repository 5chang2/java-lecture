# 6.1. 객체지향의 4가지 특징 정리

> 지금까지 학습한 객체지향 개념을 4가지 특징으로 정리하고, 각 특징의 의미와 중요성을 이해합니다.

## 학습 목표
- 객체지향 프로그래밍의 4가지 특징 이해
- 캡슐화, 상속, 추상화, 다형성의 개념 정리
- 각 특징이 코드 품질에 미치는 영향 이해
- JavaScript와의 비교를 통한 개념 명확화

---

## 1. 객체지향 프로그래밍(OOP) 복습

### 지금까지 학습한 내용

**4장 - OOP Part 1:**
- 클래스와 객체
- 필드, 메서드, 생성자
- 패키지와 import
- 접근 제어자 (private, protected, public)
- static과 final

**5장 - OOP Part 2:**
- 상속과 super
- 다형성과 메서드 오버라이딩
- 추상 클래스와 인터페이스
- 컴포지션

### 왜 이 모든 것을 배웠을까?

**목표: 객체지향의 4가지 특징을 만족시켜 더 나은 코드를 작성하기 위함**

---

## 2. 객체지향의 4가지 특징 (OOP의 4대 원칙)

### 전체 개요

| 특징 | 영어 | 핵심 개념 | Java 구현 |
|------|------|----------|----------|
| 캡슐화 | Encapsulation | 정보 은닉과 보호 | 접근 제어자, getter/setter |
| 상속 | Inheritance | 코드 재사용 | extends |
| 추상화 | Abstraction | 핵심만 노출 | abstract class, interface |
| 다형성 | Polymorphism | 유연한 설계 | 메서드 오버라이딩, 인터페이스 |

**중요: 이 4가지는 서로 독립적이 아니라 상호 보완적입니다.**

---

## 3. 캡슐화 (Encapsulation)

### 개념

**캡슐화**는 객체의 내부 상태를 외부에서 **직접 접근하지 못하도록** 하여 **데이터를 보호**하는 특성입니다.

**비유:**
- 약을 캡슐에 넣어 보호하는 것처럼
- 자동차 엔진을 후드 안에 감추는 것처럼

### 왜 필요한가?

**문제 상황: 캡슐화 없이 설계**

```java
public class BankAccount {
    public int balance;  // ❌ 외부에서 직접 접근 가능
}
```

```java
public class Main {
    public static void main(String[] args) {
        BankAccount account = new BankAccount();
        account.balance = 1000000;

        // ❌ 잔액을 마음대로 변경 가능!
        account.balance = -5000000;  // 음수 잔액?!
        account.balance = 999999999; // 무제한 입금?!
    }
}
```

**문제점:**
- 데이터 무결성 보장 불가
- 잘못된 값 설정 가능
- 검증 로직 추가 불가

### 캡슐화 적용

```java
public class BankAccount {
    private int balance;  // ✅ 외부 접근 차단

    public BankAccount(int initialBalance) {
        if (initialBalance < 0) {
            throw new IllegalArgumentException("초기 잔액은 0 이상이어야 합니다.");
        }
        this.balance = initialBalance;
    }

    // Getter - 읽기만 허용
    public int getBalance() {
        return this.balance;
    }

    // 입금 - 검증 로직 포함
    public void deposit(int amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("입금액은 0보다 커야 합니다.");
        }
        this.balance += amount;
    }

    // 출금 - 검증 로직 포함
    public void withdraw(int amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("출금액은 0보다 커야 합니다.");
        }
        if (amount > this.balance) {
            throw new IllegalArgumentException("잔액이 부족합니다.");
        }
        this.balance -= amount;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        BankAccount account = new BankAccount(1000000);

        // ✅ 메서드를 통해서만 접근
        account.deposit(50000);
        account.withdraw(20000);

        System.out.println("잔액: " + account.getBalance());

        // account.balance = -1000;  // ❌ 컴파일 에러!
        // account.withdraw(2000000);  // ❌ 런타임 에러 (검증 실패)
    }
}
```

### 캡슐화의 장점

1. **데이터 보호**: 잘못된 값 설정 방지
2. **유지보수성**: 내부 구현 변경 시 외부 코드 영향 최소화
3. **검증 로직 집중화**: getter/setter에서 일괄 처리

### JavaScript와의 비교

```javascript
// JavaScript - private 필드 (ES2022+)
class BankAccount {
    #balance;  // private 필드

    constructor(initialBalance) {
        if (initialBalance < 0) {
            throw new Error("초기 잔액은 0 이상이어야 합니다.");
        }
        this.#balance = initialBalance;
    }

    getBalance() {
        return this.#balance;
    }

    deposit(amount) {
        if (amount <= 0) {
            throw new Error("입금액은 0보다 커야 합니다.");
        }
        this.#balance += amount;
    }
}
```

**차이점:**
- Java: private 키워드 (오래전부터 지원)
- JavaScript: # 접두사 (최근 추가)

---

## 4. 상속 (Inheritance)

### 개념

**상속**은 기존 클래스의 속성과 메서드를 **물려받아** 새로운 클래스를 생성하는 것입니다.

**목적:**
- 코드 재사용
- 계층 구조 표현 (is-a 관계)
- 공통 기능 통합

### 예시

```java
public class Animal {
    protected String name;
    protected int age;

    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void eat() {
        System.out.println(name + "이(가) 먹습니다.");
    }

    public void sleep() {
        System.out.println(name + "이(가) 잡니다.");
    }
}
```

```java
public class Dog extends Animal {
    private String breed;

    public Dog(String name, int age, String breed) {
        super(name, age);  // 부모 생성자 호출
        this.breed = breed;
    }

    // Dog만의 메서드
    public void bark() {
        System.out.println(name + ": 멍멍!");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog("백구", 3, "진돗개");

        // 상속받은 메서드
        dog.eat();
        dog.sleep();

        // Dog만의 메서드
        dog.bark();
    }
}
```

**출력:**
```
백구이(가) 먹습니다.
백구이(가) 잡니다.
백구: 멍멍!
```

### 상속의 장점

1. **코드 재사용**: 공통 기능을 한 번만 작성
2. **일관성 유지**: 공통 인터페이스 제공
3. **확장 용이**: 새로운 하위 타입 추가 쉬움

### 주의사항

**상속보다 컴포지션을 선호하라 (5.4장 복습)**

- 명확한 is-a 관계에만 상속 사용
- has-a 관계는 컴포지션 사용

---

## 5. 추상화 (Abstraction)

### 개념

**추상화**는 객체의 복잡한 세부 사항은 **숨기고**, 외부에 필요한 **핵심 기능만 노출**하는 것입니다.

**비유:**
- 자동차 운전: 엑셀/브레이크만 알면 됨 (엔진 동작 원리는 몰라도 됨)
- TV 리모컨: 버튼만 누르면 됨 (내부 회로는 몰라도 됨)

### 캡슐화 vs 추상화

| 구분 | 캡슐화 | 추상화 |
|------|--------|--------|
| 목적 | 데이터 보호 | 복잡도 감소 |
| 초점 | 정보 은닉 | 핵심 기능 노출 |
| 구현 | 접근 제어자 | 추상 클래스/인터페이스 |

### 예시: 추상 클래스

```java
public abstract class Shape {
    protected String name;

    public Shape(String name) {
        this.name = name;
    }

    // 추상 메서드 - "무엇을" 할지만 정의
    public abstract double calculateArea();
    public abstract double calculatePerimeter();

    // 일반 메서드 - 공통 기능
    public void printInfo() {
        System.out.println("[" + name + "]");
        System.out.println("면적: " + calculateArea());
        System.out.println("둘레: " + calculatePerimeter());
    }
}
```

```java
public class Circle extends Shape {
    private double radius;

    public Circle(double radius) {
        super("원");
        this.radius = radius;
    }

    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }

    @Override
    public double calculatePerimeter() {
        return 2 * Math.PI * radius;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Shape circle = new Circle(5);

        // 세부 구현은 몰라도 사용 가능 (추상화)
        circle.printInfo();
    }
}
```

### 추상화의 장점

1. **복잡도 감소**: 핵심만 보면 됨
2. **유지보수 용이**: 세부 구현 변경 시 영향 최소화
3. **다형성 지원**: 추상 타입으로 다양한 구현체 사용

---

## 6. 다형성 (Polymorphism)

### 개념

**다형성**은 **하나의 타입**으로 **여러 형태의 객체**를 다룰 수 있는 특성입니다.

**어원:**
- Poly (여러) + Morph (형태) = 여러 형태

### 핵심 메커니즘

1. **메서드 오버라이딩**: 같은 메서드 이름, 다른 구현
2. **업캐스팅**: 상위 타입 변수로 하위 타입 객체 참조
3. **동적 바인딩**: 런타임에 실제 메서드 결정

### 예시

```java
public interface Drawable {
    void draw();
}

public class Circle implements Drawable {
    @Override
    public void draw() {
        System.out.println("○ 원을 그립니다.");
    }
}

public class Rectangle implements Drawable {
    @Override
    public void draw() {
        System.out.println("□ 사각형을 그립니다.");
    }
}

public class Triangle implements Drawable {
    @Override
    public void draw() {
        System.out.println("△ 삼각형을 그립니다.");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        // 하나의 타입(Drawable)으로 여러 형태의 객체 관리
        Drawable[] shapes = {
            new Circle(),
            new Rectangle(),
            new Triangle()
        };

        // 동일한 코드로 다양한 동작 실행
        for (Drawable shape : shapes) {
            shape.draw();  // 다형성!
        }
    }
}
```

**출력:**
```
○ 원을 그립니다.
□ 사각형을 그립니다.
△ 삼각형을 그립니다.
```

### 다형성의 장점

1. **코드 유연성**: 새로운 타입 추가 시 기존 코드 수정 불필요
2. **재사용성**: 하나의 코드로 여러 타입 처리
3. **확장성**: Open-Closed 원칙 만족

### JavaScript와의 비교

```javascript
// JavaScript - 덕 타이핑 (Duck Typing)
class Circle {
    draw() {
        console.log("○ 원을 그립니다.");
    }
}

class Rectangle {
    draw() {
        console.log("□ 사각형을 그립니다.");
    }
}

const shapes = [new Circle(), new Rectangle()];
shapes.forEach(shape => shape.draw());  // 타입 명시 없이 동작
```

**차이점:**
- Java: 명시적 타입 (컴파일 타임 체크)
- JavaScript: 암묵적 타입 (런타임 체크)

---

## 7. 4가지 특징의 상호작용

### 실제 시스템에서의 조합

```java
// 캡슐화: private 필드
public abstract class Employee {
    private String name;
    private int salary;

    public Employee(String name, int salary) {
        this.name = name;
        this.salary = salary;
    }

    // 캡슐화: getter
    public int getSalary() {
        return this.salary;
    }

    // 추상화: 추상 메서드
    public abstract int calculateBonus();

    // 다형성을 위한 공통 메서드
    public void printInfo() {
        System.out.println("이름: " + name);
        System.out.println("급여: " + salary);
        System.out.println("보너스: " + calculateBonus());
    }
}

// 상속: Employee 확장
public class Manager extends Employee {
    public Manager(String name, int salary) {
        super(name, salary);
    }

    @Override
    public int calculateBonus() {
        return getSalary() / 5;  // 급여의 20%
    }
}

public class Developer extends Employee {
    public Developer(String name, int salary) {
        super(name, salary);
    }

    @Override
    public int calculateBonus() {
        return getSalary() / 10;  // 급여의 10%
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        // 다형성: Employee 타입으로 다양한 객체 관리
        Employee[] employees = {
            new Manager("김팀장", 5000000),
            new Developer("이개발", 4000000)
        };

        for (Employee emp : employees) {
            emp.printInfo();  // 추상화된 인터페이스 사용
            System.out.println();
        }
    }
}
```

**이 코드는 4가지 특징을 모두 활용:**
- ✅ 캡슐화: private 필드, getter
- ✅ 상속: Manager, Developer가 Employee 상속
- ✅ 추상화: abstract 메서드로 핵심만 정의
- ✅ 다형성: Employee 타입으로 다양한 직원 처리

---

## 8. 실습 문제

### 문제 1: 4가지 특징 식별하기

다음 코드에서 4가지 특징을 찾아보세요.

```java
public abstract class Vehicle {
    private String model;
    private int speed;

    public Vehicle(String model) {
        this.model = model;
        this.speed = 0;
    }

    public int getSpeed() {
        return this.speed;
    }

    protected void setSpeed(int speed) {
        this.speed = speed;
    }

    public abstract void accelerate();

    public void showStatus() {
        System.out.println(model + " - 속도: " + speed + "km/h");
    }
}

public class Car extends Vehicle {
    public Car(String model) {
        super(model);
    }

    @Override
    public void accelerate() {
        setSpeed(getSpeed() + 10);
    }
}

public class Motorcycle extends Vehicle {
    public Motorcycle(String model) {
        super(model);
    }

    @Override
    public void accelerate() {
        setSpeed(getSpeed() + 15);
    }
}
```

**질문:**
1. 캡슐화는 어디에 적용되었나요?
2. 상속은 어떻게 사용되었나요?
3. 추상화는 어떤 부분인가요?
4. 다형성은 어떻게 활용할 수 있나요?

### 문제 2: 4가지 특징 모두 활용하기

**요구사항:**

온라인 쇼핑몰의 상품 시스템을 구현하세요.

1. **캡슐화**: 가격, 재고 정보를 private으로 보호
2. **상속**: Product 추상 클래스 → Book, Electronics 상속
3. **추상화**: 할인 계산을 추상 메서드로 정의
4. **다형성**: Product 배열로 다양한 상품 관리

**클래스 구조:**
- `Product` (추상 클래스)
  - 필드: name, price, stock
  - 추상 메서드: `calculateDiscount()`
  - 일반 메서드: `sell(int quantity)`, `getPrice()`
- `Book`: 15% 할인
- `Electronics`: 10% 할인

**테스트 코드:**
```java
public class Main {
    public static void main(String[] args) {
        Product[] products = {
            new Book("자바의 정석", 30000, 50),
            new Electronics("노트북", 1000000, 10)
        };

        for (Product product : products) {
            System.out.println("상품: " + product.getName());
            System.out.println("원가: " + product.getPrice());
            System.out.println("할인가: " + product.calculateDiscount());
            System.out.println();
        }
    }
}
```

---

## 요약

### 객체지향의 4가지 특징

| 특징 | 목적 | Java 구현 | 효과 |
|------|------|-----------|------|
| **캡슐화** | 데이터 보호 | private, getter/setter | 데이터 무결성 |
| **상속** | 코드 재사용 | extends | 중복 제거 |
| **추상화** | 복잡도 감소 | abstract, interface | 유지보수성 |
| **다형성** | 유연한 설계 | 오버라이딩, 인터페이스 | 확장성 |

### 핵심 포인트

1. **4가지 특징은 독립적이 아니라 상호 보완적**
2. **좋은 OOP 설계는 4가지를 모두 적절히 활용**
3. **각 특징은 코드 품질을 다른 측면에서 향상**

### Java vs JavaScript

| 구분 | Java | JavaScript |
|------|------|------------|
| 캡슐화 | private 키워드 | # 접두사 (ES2022+) |
| 상속 | extends (단일 상속) | extends (단일 상속) |
| 추상화 | abstract, interface | 없음 (TypeScript는 지원) |
| 다형성 | 정적 타입 다형성 | 덕 타이핑 |

**다음 학습:**
- 6.2장에서 SOLID 원칙을 통한 설계 심화 학습
