# 10.3 미니 프로젝트: 도서 관리 시스템

## 프로젝트 개요

도서관에서 도서를 관리하고, 회원의 대여/반납을 처리하는 콘솔 기반 시스템입니다. 이 프로젝트는 **객체 지향 프로그래밍의 모든 개념을 종합적으로 활용**하는 실무형 프로젝트입니다.

**주요 기능**:
- 도서 추가/삭제/수정/검색
- 회원 등록/조회
- 도서 대여/반납
- 연체료 계산
- 대여 가능 도서 조회
- 통계 기능 (인기 도서, 회원별 대여 내역)

---

## 학습 목표

이 프로젝트를 통해 다음을 학습합니다:

- ✅ **클래스 설계**: 도메인 모델링 (Book, Member, Loan)
- ✅ **상속과 인터페이스**: 코드 재사용과 추상화
- ✅ **캡슐화**: 접근 제어자와 Getter/Setter
- ✅ **컬렉션 활용**: List, Map, Set을 실무에 적용
- ✅ **Enum**: 도서 카테고리, 대여 상태 관리
- ✅ **예외 처리**: 비즈니스 로직 예외
- ✅ **날짜/시간 API**: LocalDate를 이용한 날짜 계산
- ✅ **Stream API**: 검색, 필터링, 정렬
- ✅ **SOLID 원칙**: 객체 지향 설계 원칙 적용

---

## JavaScript와의 비교

### JavaScript 버전 (참고)

```javascript
// JavaScript로 구현한 간단한 도서 관리
class Book {
  constructor(id, title, author) {
    this.id = id;
    this.title = title;
    this.author = author;
    this.isAvailable = true;
  }
}

class Library {
  constructor() {
    this.books = [];
  }

  addBook(book) {
    this.books.push(book);
  }

  findBook(title) {
    return this.books.find(book =>
      book.title.includes(title)
    );
  }

  borrowBook(bookId) {
    const book = this.books.find(b => b.id === bookId);
    if (book && book.isAvailable) {
      book.isAvailable = false;
      return true;
    }
    return false;
  }
}
```

**JavaScript의 특징**:
- 동적 타입 (타입 선언 불필요)
- 간단한 객체 구조
- 배열 메서드 (`find`, `filter`, `map`)

**Java는 더 복잡하지만 더 안전하고 확장 가능합니다!**

---

## Java 구현

### 시스템 설계

```
┌─────────────────────────────────────────┐
│         Library Management System       │
└─────────────────────────────────────────┘
                    │
        ┌───────────┼───────────┐
        ▼           ▼           ▼
     Book       Member       Loan
        │           │           │
        │           │           │
    Category    MemberType   LoanStatus
     (Enum)      (Enum)       (Enum)
```

### 1단계: 기본 도메인 모델

#### Book 클래스

```java
// Book.java
import java.util.Objects;

public class Book {
    private String isbn;           // 도서 고유 번호
    private String title;          // 제목
    private String author;         // 저자
    private String publisher;      // 출판사
    private int publishYear;       // 출판 연도
    private BookCategory category; // 카테고리
    private boolean available;     // 대여 가능 여부

    public Book(String isbn, String title, String author,
                String publisher, int publishYear, BookCategory category) {
        this.isbn = isbn;
        this.title = title;
        this.author = author;
        this.publisher = publisher;
        this.publishYear = publishYear;
        this.category = category;
        this.available = true;  // 기본값: 대여 가능
    }

    // Getter 메서드
    public String getIsbn() {
        return isbn;
    }

    public String getTitle() {
        return title;
    }

    public String getAuthor() {
        return author;
    }

    public String getPublisher() {
        return publisher;
    }

    public int getPublishYear() {
        return publishYear;
    }

    public BookCategory getCategory() {
        return category;
    }

    public boolean isAvailable() {
        return available;
    }

    // Setter 메서드 (필요한 것만)
    public void setAvailable(boolean available) {
        this.available = available;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    // 도서 정보 업데이트
    public void updateInfo(String title, String author, String publisher) {
        if (title != null && !title.trim().isEmpty()) {
            this.title = title;
        }
        if (author != null && !author.trim().isEmpty()) {
            this.author = author;
        }
        if (publisher != null && !publisher.trim().isEmpty()) {
            this.publisher = publisher;
        }
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Book book = (Book) o;
        return Objects.equals(isbn, book.isbn);
    }

    @Override
    public int hashCode() {
        return Objects.hash(isbn);
    }

    @Override
    public String toString() {
        return String.format("[%s] %s - %s (%s, %d) [%s] %s",
            isbn, title, author, publisher, publishYear,
            category.getDescription(),
            available ? "대여가능" : "대여중");
    }
}
```

#### BookCategory Enum

```java
// BookCategory.java
public enum BookCategory {
    FICTION("소설"),
    NON_FICTION("비소설"),
    SCIENCE("과학"),
    TECHNOLOGY("기술/IT"),
    HISTORY("역사"),
    ART("예술"),
    SELF_HELP("자기계발"),
    KIDS("어린이"),
    MAGAZINE("잡지"),
    ETC("기타");

    private final String description;

    BookCategory(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }

    // 설명으로 카테고리 찾기
    public static BookCategory fromDescription(String description) {
        for (BookCategory category : values()) {
            if (category.description.equals(description)) {
                return category;
            }
        }
        throw new IllegalArgumentException("유효하지 않은 카테고리: " + description);
    }
}
```

#### Member 클래스

```java
// Member.java
import java.time.LocalDate;
import java.util.*;

public class Member {
    private String memberId;
    private String name;
    private String email;
    private String phone;
    private LocalDate joinDate;
    private MemberType memberType;
    private int maxBorrowLimit;  // 최대 대여 가능 권수

    public Member(String memberId, String name, String email,
                  String phone, MemberType memberType) {
        this.memberId = memberId;
        this.name = name;
        this.email = email;
        this.phone = phone;
        this.joinDate = LocalDate.now();
        this.memberType = memberType;
        this.maxBorrowLimit = memberType.getMaxBorrowLimit();
    }

    // Getter 메서드
    public String getMemberId() {
        return memberId;
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }

    public String getPhone() {
        return phone;
    }

    public LocalDate getJoinDate() {
        return joinDate;
    }

    public MemberType getMemberType() {
        return memberType;
    }

    public int getMaxBorrowLimit() {
        return maxBorrowLimit;
    }

    // 회원 정보 수정
    public void updateContact(String email, String phone) {
        if (email != null && !email.trim().isEmpty()) {
            this.email = email;
        }
        if (phone != null && !phone.trim().isEmpty()) {
            this.phone = phone;
        }
    }

    // 회원 등급 업그레이드
    public void upgradeMemberType(MemberType newType) {
        this.memberType = newType;
        this.maxBorrowLimit = newType.getMaxBorrowLimit();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Member member = (Member) o;
        return Objects.equals(memberId, member.memberId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(memberId);
    }

    @Override
    public String toString() {
        return String.format("[%s] %s (%s) - %s (가입일: %s)",
            memberId, name, memberType.getDescription(),
            phone, joinDate);
    }
}
```

#### MemberType Enum

```java
// MemberType.java
public enum MemberType {
    REGULAR("일반 회원", 3, 14),
    PREMIUM("프리미엄 회원", 5, 21),
    VIP("VIP 회원", 10, 30);

    private final String description;
    private final int maxBorrowLimit;    // 최대 대여 권수
    private final int maxBorrowDays;     // 최대 대여 일수

    MemberType(String description, int maxBorrowLimit, int maxBorrowDays) {
        this.description = description;
        this.maxBorrowLimit = maxBorrowLimit;
        this.maxBorrowDays = maxBorrowDays;
    }

    public String getDescription() {
        return description;
    }

    public int getMaxBorrowLimit() {
        return maxBorrowLimit;
    }

    public int getMaxBorrowDays() {
        return maxBorrowDays;
    }
}
```

#### Loan 클래스 (대여 기록)

```java
// Loan.java
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;

public class Loan {
    private String loanId;
    private Member member;
    private Book book;
    private LocalDate borrowDate;
    private LocalDate dueDate;
    private LocalDate returnDate;
    private LoanStatus status;

    public Loan(String loanId, Member member, Book book) {
        this.loanId = loanId;
        this.member = member;
        this.book = book;
        this.borrowDate = LocalDate.now();
        this.dueDate = borrowDate.plusDays(member.getMemberType().getMaxBorrowDays());
        this.returnDate = null;
        this.status = LoanStatus.BORROWED;
    }

    // Getter 메서드
    public String getLoanId() {
        return loanId;
    }

    public Member getMember() {
        return member;
    }

    public Book getBook() {
        return book;
    }

    public LocalDate getBorrowDate() {
        return borrowDate;
    }

    public LocalDate getDueDate() {
        return dueDate;
    }

    public LocalDate getReturnDate() {
        return returnDate;
    }

    public LoanStatus getStatus() {
        return status;
    }

    // 반납 처리
    public void returnBook() {
        this.returnDate = LocalDate.now();
        this.status = isOverdue() ? LoanStatus.RETURNED_LATE : LoanStatus.RETURNED;
        this.book.setAvailable(true);
    }

    // 연체 여부 확인
    public boolean isOverdue() {
        LocalDate checkDate = (returnDate != null) ? returnDate : LocalDate.now();
        return checkDate.isAfter(dueDate);
    }

    // 연체 일수 계산
    public long getOverdueDays() {
        if (!isOverdue()) {
            return 0;
        }
        LocalDate checkDate = (returnDate != null) ? returnDate : LocalDate.now();
        return ChronoUnit.DAYS.between(dueDate, checkDate);
    }

    // 연체료 계산 (하루당 500원)
    public int getLateFee() {
        return (int) (getOverdueDays() * 500);
    }

    @Override
    public String toString() {
        String overdueInfo = isOverdue() ?
            String.format(" [연체 %d일, 연체료 %,d원]", getOverdueDays(), getLateFee()) : "";

        return String.format("[%s] %s - %s (대여일: %s, 반납예정: %s)%s %s",
            loanId,
            member.getName(),
            book.getTitle(),
            borrowDate,
            dueDate,
            overdueInfo,
            status.getDescription());
    }
}
```

#### LoanStatus Enum

```java
// LoanStatus.java
public enum LoanStatus {
    BORROWED("대여중"),
    RETURNED("반납완료"),
    RETURNED_LATE("연체반납"),
    LOST("분실");

    private final String description;

    LoanStatus(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}
```

---

### 2단계: 비즈니스 로직 - Library 클래스

```java
// Library.java
import java.util.*;
import java.util.stream.Collectors;

public class Library {
    private String name;
    private Map<String, Book> books;           // ISBN -> Book
    private Map<String, Member> members;       // MemberId -> Member
    private Map<String, Loan> loans;           // LoanId -> Loan
    private Map<String, List<Loan>> memberLoans; // MemberId -> List<Loan>

    public Library(String name) {
        this.name = name;
        this.books = new HashMap<>();
        this.members = new HashMap<>();
        this.loans = new HashMap<>();
        this.memberLoans = new HashMap<>();
    }

    // ========== 도서 관리 ==========

    public void addBook(Book book) {
        if (books.containsKey(book.getIsbn())) {
            throw new IllegalArgumentException("이미 존재하는 ISBN입니다: " + book.getIsbn());
        }
        books.put(book.getIsbn(), book);
        System.out.println("✓ 도서가 추가되었습니다: " + book.getTitle());
    }

    public void removeBook(String isbn) {
        Book book = books.get(isbn);
        if (book == null) {
            throw new IllegalArgumentException("존재하지 않는 도서입니다.");
        }
        if (!book.isAvailable()) {
            throw new IllegalStateException("대여 중인 도서는 삭제할 수 없습니다.");
        }
        books.remove(isbn);
        System.out.println("✓ 도서가 삭제되었습니다: " + book.getTitle());
    }

    public Book getBook(String isbn) {
        return books.get(isbn);
    }

    public List<Book> getAllBooks() {
        return new ArrayList<>(books.values());
    }

    // 도서 검색 (제목으로)
    public List<Book> searchBooksByTitle(String keyword) {
        return books.values().stream()
                .filter(book -> book.getTitle().contains(keyword))
                .collect(Collectors.toList());
    }

    // 도서 검색 (저자로)
    public List<Book> searchBooksByAuthor(String author) {
        return books.values().stream()
                .filter(book -> book.getAuthor().contains(author))
                .collect(Collectors.toList());
    }

    // 도서 검색 (카테고리로)
    public List<Book> searchBooksByCategory(BookCategory category) {
        return books.values().stream()
                .filter(book -> book.getCategory() == category)
                .collect(Collectors.toList());
    }

    // 대여 가능한 도서 목록
    public List<Book> getAvailableBooks() {
        return books.values().stream()
                .filter(Book::isAvailable)
                .collect(Collectors.toList());
    }

    // ========== 회원 관리 ==========

    public void registerMember(Member member) {
        if (members.containsKey(member.getMemberId())) {
            throw new IllegalArgumentException("이미 존재하는 회원 ID입니다: " + member.getMemberId());
        }
        members.put(member.getMemberId(), member);
        memberLoans.put(member.getMemberId(), new ArrayList<>());
        System.out.println("✓ 회원이 등록되었습니다: " + member.getName());
    }

    public Member getMember(String memberId) {
        return members.get(memberId);
    }

    public List<Member> getAllMembers() {
        return new ArrayList<>(members.values());
    }

    // ========== 대여/반납 관리 ==========

    public Loan borrowBook(String memberId, String isbn) {
        Member member = members.get(memberId);
        if (member == null) {
            throw new IllegalArgumentException("존재하지 않는 회원입니다.");
        }

        Book book = books.get(isbn);
        if (book == null) {
            throw new IllegalArgumentException("존재하지 않는 도서입니다.");
        }

        if (!book.isAvailable()) {
            throw new IllegalStateException("이미 대여 중인 도서입니다.");
        }

        // 대여 권수 제한 확인
        long currentBorrowCount = getCurrentBorrowCount(memberId);
        if (currentBorrowCount >= member.getMaxBorrowLimit()) {
            throw new IllegalStateException(
                String.format("대여 권수 제한을 초과했습니다. (현재: %d권, 최대: %d권)",
                    currentBorrowCount, member.getMaxBorrowLimit()));
        }

        // 대여 처리
        String loanId = generateLoanId();
        Loan loan = new Loan(loanId, member, book);
        loans.put(loanId, loan);
        memberLoans.get(memberId).add(loan);
        book.setAvailable(false);

        System.out.println("✓ 대여가 완료되었습니다.");
        System.out.println("  반납 예정일: " + loan.getDueDate());

        return loan;
    }

    public void returnBook(String loanId) {
        Loan loan = loans.get(loanId);
        if (loan == null) {
            throw new IllegalArgumentException("존재하지 않는 대여 기록입니다.");
        }

        if (loan.getStatus() != LoanStatus.BORROWED) {
            throw new IllegalStateException("이미 반납된 도서입니다.");
        }

        loan.returnBook();

        System.out.println("✓ 반납이 완료되었습니다.");
        if (loan.isOverdue()) {
            System.out.printf("  연체료: %,d원 (%d일 연체)\n",
                loan.getLateFee(), loan.getOverdueDays());
        }
    }

    // 현재 대여 중인 도서 수
    private long getCurrentBorrowCount(String memberId) {
        return memberLoans.get(memberId).stream()
                .filter(loan -> loan.getStatus() == LoanStatus.BORROWED)
                .count();
    }

    // 회원의 현재 대여 목록
    public List<Loan> getCurrentLoans(String memberId) {
        return memberLoans.getOrDefault(memberId, new ArrayList<>()).stream()
                .filter(loan -> loan.getStatus() == LoanStatus.BORROWED)
                .collect(Collectors.toList());
    }

    // 회원의 전체 대여 이력
    public List<Loan> getLoanHistory(String memberId) {
        return new ArrayList<>(memberLoans.getOrDefault(memberId, new ArrayList<>()));
    }

    // 대여 ID 생성
    private String generateLoanId() {
        return "L" + System.currentTimeMillis();
    }

    // ========== 통계 및 조회 ==========

    // 인기 도서 Top N
    public List<Book> getPopularBooks(int topN) {
        Map<Book, Long> bookBorrowCount = loans.values().stream()
                .collect(Collectors.groupingBy(
                    Loan::getBook,
                    Collectors.counting()
                ));

        return bookBorrowCount.entrySet().stream()
                .sorted(Map.Entry.<Book, Long>comparingByValue().reversed())
                .limit(topN)
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());
    }

    // 연체 중인 대여 목록
    public List<Loan> getOverdueLoans() {
        return loans.values().stream()
                .filter(loan -> loan.getStatus() == LoanStatus.BORROWED)
                .filter(Loan::isOverdue)
                .collect(Collectors.toList());
    }

    public String getName() {
        return name;
    }
}
```

---

### 3단계: 사용자 인터페이스

```java
// LibraryApp.java
import java.util.*;

public class LibraryApp {
    private Library library;
    private Scanner scanner;

    public LibraryApp(String libraryName) {
        this.library = new Library(libraryName);
        this.scanner = new Scanner(System.in);
        initSampleData();  // 샘플 데이터 초기화
    }

    public void start() {
        System.out.println("===== " + library.getName() + " =====\n");

        while (true) {
            showMainMenu();
            int choice = getIntInput("선택: ");

            try {
                switch (choice) {
                    case 1: manageBooks(); break;
                    case 2: manageMembers(); break;
                    case 3: borrowBook(); break;
                    case 4: returnBook(); break;
                    case 5: searchBooks(); break;
                    case 6: viewStatistics(); break;
                    case 0:
                        System.out.println("프로그램을 종료합니다.");
                        scanner.close();
                        return;
                    default:
                        System.out.println("⚠️  잘못된 선택입니다.");
                }
            } catch (Exception e) {
                System.out.println("⚠️  오류: " + e.getMessage());
            }

            System.out.println();
        }
    }

    private void showMainMenu() {
        System.out.println("===== 메인 메뉴 =====");
        System.out.println("1. 도서 관리");
        System.out.println("2. 회원 관리");
        System.out.println("3. 도서 대여");
        System.out.println("4. 도서 반납");
        System.out.println("5. 도서 검색");
        System.out.println("6. 통계 조회");
        System.out.println("0. 종료");
    }

    // ========== 도서 관리 ==========

    private void manageBooks() {
        System.out.println("\n[도서 관리]");
        System.out.println("1. 도서 추가");
        System.out.println("2. 도서 삭제");
        System.out.println("3. 전체 도서 목록");
        System.out.println("4. 대여 가능 도서");

        int choice = getIntInput("선택: ");

        switch (choice) {
            case 1: addBook(); break;
            case 2: removeBook(); break;
            case 3: listAllBooks(); break;
            case 4: listAvailableBooks(); break;
        }
    }

    private void addBook() {
        System.out.println("\n[도서 추가]");

        String isbn = getInput("ISBN: ");
        String title = getInput("제목: ");
        String author = getInput("저자: ");
        String publisher = getInput("출판사: ");
        int year = getIntInput("출판 연도: ");

        System.out.println("\n카테고리 선택:");
        BookCategory[] categories = BookCategory.values();
        for (int i = 0; i < categories.length; i++) {
            System.out.printf("%d. %s\n", i + 1, categories[i].getDescription());
        }

        int categoryIndex = getIntInput("선택: ") - 1;
        BookCategory category = categories[categoryIndex];

        Book book = new Book(isbn, title, author, publisher, year, category);
        library.addBook(book);
    }

    private void removeBook() {
        String isbn = getInput("삭제할 도서의 ISBN: ");
        library.removeBook(isbn);
    }

    private void listAllBooks() {
        List<Book> books = library.getAllBooks();
        System.out.println("\n[전체 도서 목록] (총 " + books.size() + "권)");
        books.forEach(System.out::println);
    }

    private void listAvailableBooks() {
        List<Book> books = library.getAvailableBooks();
        System.out.println("\n[대여 가능 도서] (총 " + books.size() + "권)");
        books.forEach(System.out::println);
    }

    // ========== 회원 관리 ==========

    private void manageMembers() {
        System.out.println("\n[회원 관리]");
        System.out.println("1. 회원 등록");
        System.out.println("2. 회원 조회");
        System.out.println("3. 회원 대여 내역");

        int choice = getIntInput("선택: ");

        switch (choice) {
            case 1: registerMember(); break;
            case 2: viewMember(); break;
            case 3: viewMemberLoans(); break;
        }
    }

    private void registerMember() {
        System.out.println("\n[회원 등록]");

        String memberId = getInput("회원 ID: ");
        String name = getInput("이름: ");
        String email = getInput("이메일: ");
        String phone = getInput("전화번호: ");

        System.out.println("\n회원 등급:");
        System.out.println("1. 일반 회원 (최대 3권, 14일)");
        System.out.println("2. 프리미엄 회원 (최대 5권, 21일)");
        System.out.println("3. VIP 회원 (최대 10권, 30일)");

        int typeChoice = getIntInput("선택: ");
        MemberType type = MemberType.values()[typeChoice - 1];

        Member member = new Member(memberId, name, email, phone, type);
        library.registerMember(member);
    }

    private void viewMember() {
        String memberId = getInput("회원 ID: ");
        Member member = library.getMember(memberId);

        if (member == null) {
            System.out.println("존재하지 않는 회원입니다.");
            return;
        }

        System.out.println("\n[회원 정보]");
        System.out.println(member);

        List<Loan> currentLoans = library.getCurrentLoans(memberId);
        System.out.println("\n현재 대여 중: " + currentLoans.size() + "권");
        currentLoans.forEach(System.out::println);
    }

    private void viewMemberLoans() {
        String memberId = getInput("회원 ID: ");
        List<Loan> history = library.getLoanHistory(memberId);

        System.out.println("\n[대여 이력] (총 " + history.size() + "건)");
        history.forEach(System.out::println);
    }

    // ========== 대여/반납 ==========

    private void borrowBook() {
        System.out.println("\n[도서 대여]");

        String memberId = getInput("회원 ID: ");
        String isbn = getInput("도서 ISBN: ");

        Loan loan = library.borrowBook(memberId, isbn);
    }

    private void returnBook() {
        System.out.println("\n[도서 반납]");

        String memberId = getInput("회원 ID: ");
        List<Loan> currentLoans = library.getCurrentLoans(memberId);

        if (currentLoans.isEmpty()) {
            System.out.println("대여 중인 도서가 없습니다.");
            return;
        }

        System.out.println("\n대여 중인 도서:");
        for (int i = 0; i < currentLoans.size(); i++) {
            System.out.printf("%d. %s\n", i + 1, currentLoans.get(i));
        }

        int choice = getIntInput("반납할 도서 번호: ");
        Loan loan = currentLoans.get(choice - 1);

        library.returnBook(loan.getLoanId());
    }

    // ========== 검색 ==========

    private void searchBooks() {
        System.out.println("\n[도서 검색]");
        System.out.println("1. 제목으로 검색");
        System.out.println("2. 저자로 검색");
        System.out.println("3. 카테고리로 검색");

        int choice = getIntInput("선택: ");

        switch (choice) {
            case 1:
                String title = getInput("제목 키워드: ");
                library.searchBooksByTitle(title).forEach(System.out::println);
                break;
            case 2:
                String author = getInput("저자 이름: ");
                library.searchBooksByAuthor(author).forEach(System.out::println);
                break;
            case 3:
                BookCategory[] categories = BookCategory.values();
                for (int i = 0; i < categories.length; i++) {
                    System.out.printf("%d. %s\n", i + 1, categories[i].getDescription());
                }
                int catIndex = getIntInput("선택: ") - 1;
                library.searchBooksByCategory(categories[catIndex]).forEach(System.out::println);
                break;
        }
    }

    // ========== 통계 ==========

    private void viewStatistics() {
        System.out.println("\n[통계 조회]");
        System.out.println("1. 인기 도서 Top 5");
        System.out.println("2. 연체 목록");

        int choice = getIntInput("선택: ");

        switch (choice) {
            case 1:
                System.out.println("\n[인기 도서 Top 5]");
                library.getPopularBooks(5).forEach(System.out::println);
                break;
            case 2:
                List<Loan> overdueLoans = library.getOverdueLoans();
                System.out.println("\n[연체 목록] (총 " + overdueLoans.size() + "건)");
                overdueLoans.forEach(System.out::println);
                break;
        }
    }

    // ========== 헬퍼 메서드 ==========

    private String getInput(String prompt) {
        System.out.print(prompt);
        return scanner.nextLine().trim();
    }

    private int getIntInput(String prompt) {
        while (true) {
            try {
                System.out.print(prompt);
                int value = Integer.parseInt(scanner.nextLine().trim());
                return value;
            } catch (NumberFormatException e) {
                System.out.println("⚠️  숫자를 입력해주세요.");
            }
        }
    }

    // ========== 샘플 데이터 ==========

    private void initSampleData() {
        // 샘플 도서
        library.addBook(new Book("978-1", "클린 코드", "Robert C. Martin",
            "인사이트", 2013, BookCategory.TECHNOLOGY));
        library.addBook(new Book("978-2", "이펙티브 자바", "Joshua Bloch",
            "인사이트", 2018, BookCategory.TECHNOLOGY));
        library.addBook(new Book("978-3", "Do it! 자바 프로그래밍 입문", "박은종",
            "이지스퍼블리싱", 2019, BookCategory.TECHNOLOGY));

        // 샘플 회원
        library.registerMember(new Member("M001", "김철수",
            "kim@example.com", "010-1234-5678", MemberType.REGULAR));
        library.registerMember(new Member("M002", "이영희",
            "lee@example.com", "010-9876-5432", MemberType.PREMIUM));
    }

    // ========== 메인 ==========

    public static void main(String[] args) {
        LibraryApp app = new LibraryApp("새싹 도서관");
        app.start();
    }
}
```

---

## 실행 예시

```
===== 새싹 도서관 =====

===== 메인 메뉴 =====
1. 도서 관리
2. 회원 관리
3. 도서 대여
4. 도서 반납
5. 도서 검색
6. 통계 조회
0. 종료
선택: 3

[도서 대여]
회원 ID: M001
도서 ISBN: 978-1
✓ 대여가 완료되었습니다.
  반납 예정일: 2025-10-30

===== 메인 메뉴 =====
선택: 4

[도서 반납]
회원 ID: M001

대여 중인 도서:
1. [L1729029600000] 김철수 - 클린 코드 (대여일: 2025-10-16, 반납예정: 2025-10-30) 대여중

반납할 도서 번호: 1
✓ 반납이 완료되었습니다.
```

---

## 확장 아이디어

### Level 2: 파일 저장/불러오기

```java
import java.io.*;
import java.util.*;

public class LibraryPersistence {
    // 도서 목록을 파일로 저장
    public static void saveBooks(Library library, String filename) throws IOException {
        try (PrintWriter writer = new PrintWriter(new FileWriter(filename))) {
            for (Book book : library.getAllBooks()) {
                writer.printf("%s,%s,%s,%s,%d,%s,%b\n",
                    book.getIsbn(),
                    book.getTitle(),
                    book.getAuthor(),
                    book.getPublisher(),
                    book.getPublishYear(),
                    book.getCategory().name(),
                    book.isAvailable());
            }
        }
    }

    // 파일에서 도서 목록 불러오기
    public static void loadBooks(Library library, String filename) throws IOException {
        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.split(",");
                Book book = new Book(
                    parts[0],  // isbn
                    parts[1],  // title
                    parts[2],  // author
                    parts[3],  // publisher
                    Integer.parseInt(parts[4]),  // publishYear
                    BookCategory.valueOf(parts[5])  // category
                );
                book.setAvailable(Boolean.parseBoolean(parts[6]));
                library.addBook(book);
            }
        }
    }
}
```

### Level 3: 예약 시스템

```java
// Reservation.java
public class Reservation {
    private String reservationId;
    private Member member;
    private Book book;
    private LocalDate reservationDate;
    private boolean fulfilled;

    // 예약 대기 순서 관리
    public void notifyAvailable() {
        System.out.println("예약하신 도서가 반납되었습니다: " + book.getTitle());
    }
}

// Library.java에 추가
public void reserveBook(String memberId, String isbn) {
    // 도서가 대여 중이면 예약 추가
    // 반납 시 예약자에게 우선 대여
}
```

### Level 4: 벌금 관리 시스템

```java
public class Fine {
    private Member member;
    private int amount;
    private boolean paid;

    public void payFine(int payment) {
        if (payment >= amount) {
            this.paid = true;
            System.out.println("벌금이 완납되었습니다.");
        } else {
            this.amount -= payment;
            System.out.println("부분 납부되었습니다. 잔액: " + amount + "원");
        }
    }
}
```

---

## 실습 문제

### 문제 1: 도서 정렬 기능
도서 목록을 다양한 기준으로 정렬하는 기능을 추가하세요.
- 제목 순 (오름차순/내림차순)
- 출판 연도 순
- 카테고리 순

**힌트**: `Comparator` 사용

### 문제 2: 회원 등급 자동 업그레이드
대여 횟수가 10회 이상이면 자동으로 프리미엄 회원으로, 30회 이상이면 VIP로 업그레이드하는 기능을 구현하세요.

### 문제 3: 대여 이력 통계
회원별로 다음 통계를 출력하세요:
- 총 대여 횟수
- 평균 대여 일수
- 연체 횟수
- 가장 많이 빌린 카테고리

---

## 답안 예시

### 문제 1 답안

```java
// Library.java에 추가
public List<Book> getSortedBooks(Comparator<Book> comparator) {
    return books.values().stream()
            .sorted(comparator)
            .collect(Collectors.toList());
}

// 사용 예시
// 제목 순 정렬
List<Book> byTitle = library.getSortedBooks(
    Comparator.comparing(Book::getTitle)
);

// 출판 연도 역순
List<Book> byYear = library.getSortedBooks(
    Comparator.comparing(Book::getPublishYear).reversed()
);

// 카테고리, 그다음 제목 순
List<Book> byCategoryAndTitle = library.getSortedBooks(
    Comparator.comparing(Book::getCategory)
              .thenComparing(Book::getTitle)
);
```

### 문제 2 답안

```java
// Library.java에 추가
public void checkAndUpgradeMember(String memberId) {
    Member member = members.get(memberId);
    if (member == null) return;

    int borrowCount = memberLoans.get(memberId).size();

    if (borrowCount >= 30 && member.getMemberType() != MemberType.VIP) {
        member.upgradeMemberType(MemberType.VIP);
        System.out.println("🎉 VIP 회원으로 업그레이드되었습니다!");
    } else if (borrowCount >= 10 && member.getMemberType() == MemberType.REGULAR) {
        member.upgradeMemberType(MemberType.PREMIUM);
        System.out.println("🎉 프리미엄 회원으로 업그레이드되었습니다!");
    }
}

// borrowBook 메서드에서 호출
public Loan borrowBook(String memberId, String isbn) {
    // ... 기존 코드 ...
    checkAndUpgradeMember(memberId);  // 대여 후 등급 확인
    return loan;
}
```

### 문제 3 답안

```java
public class MemberStatistics {
    private Member member;
    private List<Loan> loanHistory;

    public MemberStatistics(Member member, List<Loan> loanHistory) {
        this.member = member;
        this.loanHistory = loanHistory;
    }

    public int getTotalBorrowCount() {
        return loanHistory.size();
    }

    public double getAverageBorrowDays() {
        return loanHistory.stream()
                .filter(loan -> loan.getReturnDate() != null)
                .mapToLong(loan ->
                    ChronoUnit.DAYS.between(
                        loan.getBorrowDate(),
                        loan.getReturnDate()
                    ))
                .average()
                .orElse(0.0);
    }

    public long getOverdueCount() {
        return loanHistory.stream()
                .filter(loan -> loan.getStatus() == LoanStatus.RETURNED_LATE)
                .count();
    }

    public BookCategory getMostBorrowedCategory() {
        return loanHistory.stream()
                .map(loan -> loan.getBook().getCategory())
                .collect(Collectors.groupingBy(
                    category -> category,
                    Collectors.counting()
                ))
                .entrySet().stream()
                .max(Map.Entry.comparingByValue())
                .map(Map.Entry::getKey)
                .orElse(null);
    }

    public void printStatistics() {
        System.out.println("\n===== 회원 통계 =====");
        System.out.println("회원: " + member.getName());
        System.out.println("총 대여 횟수: " + getTotalBorrowCount() + "회");
        System.out.printf("평균 대여 일수: %.1f일\n", getAverageBorrowDays());
        System.out.println("연체 횟수: " + getOverdueCount() + "회");
        System.out.println("선호 카테고리: " +
            (getMostBorrowedCategory() != null ?
                getMostBorrowedCategory().getDescription() : "없음"));
    }
}
```

---

## 핵심 개념 정리

### 사용된 Java 개념 총정리

| 개념 | 사용 예시 |
|------|----------|
| **클래스 설계** | Book, Member, Loan, Library |
| **Enum** | BookCategory, MemberType, LoanStatus |
| **캡슐화** | private 필드 + Getter/Setter |
| **컬렉션** | Map, List, Set |
| **제네릭** | `Map<String, Book>`, `List<Loan>` |
| **Stream API** | filter, map, collect, sorted |
| **람다 표현식** | `book -> book.isAvailable()` |
| **날짜/시간 API** | LocalDate, ChronoUnit |
| **예외 처리** | IllegalArgumentException, IllegalStateException |
| **equals/hashCode** | Book, Member의 동등성 비교 |
| **toString** | 객체 정보 출력 |
| **Comparator** | 정렬 기준 정의 |

### JavaScript와의 주요 차이점

1. **타입 안전성**:
   - JS: `{ isbn: "123", title: "Book" }`
   - Java: `Book` 클래스로 타입 강제

2. **컬렉션 선택**:
   - JS: 주로 Array 사용
   - Java: List, Set, Map 상황별 선택

3. **날짜 처리**:
   - JS: `Date` 객체 (복잡함)
   - Java: `LocalDate` (간편함)

4. **에러 처리**:
   - JS: try-catch 선택적
   - Java: 명시적 예외 처리

---

## 강사 노트

### 수업 진행 팁 (2일 코스, 총 12시간)

#### Day 1 (6시간)
- **1-2시간**: 도메인 모델 설계 (Book, Member, Loan)
- **2-3시간**: Enum 설계 및 활용
- **3-4시간**: Library 기본 CRUD 구현
- **4-6시간**: 대여/반납 로직 구현

#### Day 2 (6시간)
- **1-2시간**: 검색 및 필터링 (Stream API)
- **2-3시간**: 통계 기능 구현
- **3-4시간**: UI 구현
- **4-6시간**: 확장 기능 및 리팩토링

### 강조할 설계 원칙

1. **단일 책임 원칙 (SRP)**:
   - `Book`은 도서 정보만
   - `Library`는 도서관 운영 로직만

2. **개방-폐쇄 원칙 (OCP)**:
   - Enum을 통한 확장 가능한 설계

3. **캡슐화**:
   - 방어적 복사 (`new ArrayList<>(books)`)
   - 불변 필드 (final)

### 학습자 수준별 조언

**초급자**:
- 먼저 간단한 버전 구현 (대여/반납만)
- Stream API 대신 for-loop 사용
- 예외 처리 생략 후 나중에 추가

**중급자**:
- Stream API 적극 활용
- 예약 시스템 추가
- 파일 저장/불러오기 구현

**고급자**:
- GUI 버전 (JavaFX 또는 Swing)
- 데이터베이스 연동 (JDBC)
- RESTful API 서버로 변환

이 프로젝트는 **실무 Java 개발의 축소판**입니다. 모든 OOP 개념이 자연스럽게 녹아있어, JavaScript 개발자가 Java의 장점을 체감하기에 최적의 프로젝트입니다!
