# 제네릭

## 제네릭(Generics)이란?

제네릭(Generics)이란, 다양한 타입의 객체를 다루는 클래스나 메서드에 `컴파일 시의 타입 체크`를 해주는 기능을 말한다.

- `꺾쇠(<>)`와 함께 사용된다. 아래의 예시는 제네릭을 이용해 ArrayList에 담기는 자료형을 문자열로 지정하는 코드이다.
    
    ```java
    ArrayList<String> list = new ArrayList<>();
    ```
    
- 제네릭은 타입을 동적으로 처리하기 때문에, 마치 타입 자체를 변수화 한 기능이라고 볼 수도 있다.
    

제네릭은 아래와 같은 `장점`이 존재한다.

1. 객체의 타입을 컴파일 시에 체크하기 때문에 `타입 안정성`을 높인다.
    - `타입 안정성`이란, 의도하지 않은 타입의 객체가 저장되는 것을 막아 저장된 객체를 꺼낼 때 원래의 타입과 다른 타입으로 잘못 형변환되어 발생할 수 있는 오류가 적은 정도를 말한다.
2. 타입 체크와 형변환을 생략하여 코드를 `간결`하게 만든다.

제네릭은 크게 클래스와 메서드로 나누어 사용되어진다.

---

## 제네릭 클래스

> 클래스에서 제네릭을 사용하는 경우

### 문법

```java
public class Test<T> {

    private T value;

    public T getValue() {
        return value;
    }

    public void setValue(T value) {
        this.value = value;
    }
}
```

- 클래스에서 제네릭을 사용할 때는, 일단 선언부의 클래스명 옆에 꺾쇠를 이용해 제네릭을 지정한다.
- T와 같은 것을 `타입 변수(Type Variable)`이라고 하며, T 이외에도 자유롭게 이름을 지정할 수 있다.
- 따라서 T를 통해 어떤 타입이 들어오느냐에 따라 value의 타입이 동적으로 지정된다.

위에서 지정한 제네릭 클래스 Test를 Main에서 사용해보자.

```java
public class Main {

    public static void main(String[] args) {
        // 1. String으로 지정
        Test<String> test1 = new Test<String>();
        test1.setValue("Hello!");
        System.out.println(test1.getValue());

        // 2. Integer로 지정
        Test<Integer> test2 = new Test<>(); // 생성자 부분의 타입 매개변수는 생략 가능
        test2.setValue(120);
        System.out.println(test2.getValue());
    }
}
```

```
Hello!
120
```

- 제네릭 클래스의 실제 인스턴스를 생성할 때에는 T 대신 실제 타입을 넣어주면 된다.
- 타입 매개변수를 `String`으로 지정하면 value 변수에는 `문자열`만 할당될 수 있다.
- 타입 매개변수를 `Integer`로 지정하면 value 변수에는 `정수형`만 할당될 수 있다.
- 타입 매개변수에는 기본 자료형(int, double 등)은 대입될 수 없으므로, 기본 자료형의 사용을 위해서는 래퍼 클래스(Integer, Double 등)를 이용해야한다.

만약 타입 매개변수로 지정한 타입과 다른 타입의 값을 넣으면 `컴파일 에러`가 발생한다.

```java
public class Main {

    public static void main(String[] args) {
        Test<String> test = new Test<>(); // 타입 매개변수로 String을 지정
        test.setValue(120); // 문법 오류!!!
        System.out.println(test.getValue());
    }
}
```

```
java: incompatible types: int cannot be converted to java.lang.String
```

- 타입 매개변수로 String을 지정했으나, 실제 값은 int를 넣어 에러가 발생하였다.
- 이렇게 제네릭을 통해 올바른 타입의 값만 설정할 수 있도록 하여 전반적인 `타입 안정성`을 확보한다.

### 주의사항

1. **제네릭 타입으로 객체나 배열을 직접 생성 할 수 없다.**
    
    ```java
    public class Test<T> {
    
        public T variable = new T(); // 직접 객체 생성 불가
        public T[] array = new T[10]; // 직접 배열 생성 불가
    }
    ```
    
    ```
    java: Type parameter 'T' cannot be instantiated direct
    ```
    
2. **static 멤버에 제네릭 타입을 사용할 수 없다.**
    
    ```java
    public class Test<T> {
    
        public static void method1(T variable) {
            System.out.println(variable);
        }
    
        public static void method2(T[] array) {
            System.out.println(array);
        }
    
        public static void method3(List<T> list) {
            System.out.println(list);
        }
    }
    ```
    
    ```
    java: 'com.test.Test.this' cannot be referenced from a static context
    ```
    
    - static 멤버는 클래스의 인스턴스가 생성되기 전에 이미 메모리에 할당되어 있다.
    - 하지만 타입 변수 T는 클래스의 인스턴스가 생성될 때 지정되므로, static 멤버에서는 T가 어떤 타입을 의미하는지 알 수 없어서 에러가 발생한다.
    - 이는 객체, 배열, 컬렉션 모두에 해당한다.

### 타입 제한

제네릭은 타입 안정성을 확보하지만, 반대로 너무 자유롭기도 하다.

예를 들어, `Test<T>` 라고하면 T에는 어떤 타입도 들어갈 수 있다. 이는 제네릭 타입에 제한이 없다는 뜻이다.

제네릭으로 특정 타입으로만 가능하게 제한할 필요가 있다면 `extends` 키워드를 사용해야 한다.

아래는 Test 클래스의 제네릭 타입을 `Number라는 타입과 하위 타입`만 가능하도록 제한한 예시이다.

```java
public class Test<T extends Number> {

    public void show(T number) {
        System.out.println(number);
    }
}
```

```java
public class Main {

    public static void main(String[] args) {
        Test<Integer> test = new Test<>();
        test.show(100);
    }
}
```

```
100
```

- Test 클래스의 타입 변수 T를 `extends` 키워드를 이용해 제한 할 수 있다.
- `<T extends Number>` 에 의해 타입 변수 T는 **Number 클래스와 그 하위 클래스(Integer, Double 등)만** 받도록 설정된다.

만약 Number 타입이나 하위 타입에 해당하지 않는 타입을 넣으면 `컴파일 에러`가 발생한다.

```java
public class Main {

    public static void main(String[] args) {
        Test<String> test = new Test<>(); // 문법 오류!!!
        test.show("100");
    }
}
```

```
java: type argument java.lang.String is not within bounds of type-variable T
```

- main 메서드에서 String으로 타입 변수를 지정하려고 시도할 때 에러가 발생한다.

---

## 제네릭 메서드

> 메서드에서 제네릭을 사용하는 경우

### 문법

```java
public class Test<T> {

    private T value;

    Test(T value) {
        this.value = value;
    }

    // 제네릭 메서드
    public <V> void show(V object1, V object2) {
        System.out.println(object1);
        System.out.println(object2);
    }
}
```

- 제네릭 메서드란, 메서드 선언부에 `타입 파라미터(ex. <T>)`가 선언된 메서드를 말한다.
- 클래스에 선언된 타입 변수 T와, 메서드에 선언된 타입 변수 V는 서로 독립적으로 사용된다.

### 주의사항

1. **단순히 클래스의 제네릭을 이용해 매개변수 타입을 지정한 경우에는 제네릭 메서드가 아니다.**
    
    ```java
    public class Test<T> {
    
    		// 제네릭 메서드 아님 (매개변수의 타입 T는 Test 클래스의 제네릭 T에 해당)
        public void show(T object1, T object2) {
            System.out.println(object1);
            System.out.println(object2);
        }
    }
    ```
    
2. **제네릭 메서드의 타입 변수는, 클래스의 타입 변수와는 독립적으로 사용된다. (이름은 같을 수 있음)**
    
    ```java
    public class Test<T> {
    
        private T value;
    
        Test(T value) {
            this.value = value;
        }
    
        // 이름이 T로 동일하지만, Test 클래스의 제네릭 T와는 엄연히 다른 독립적인 제네릭에 해당
    		public <T> void show(T object1, T object2) {
            System.out.println(object1);
            System.out.println(object2);
        }
    }
    ```
    
    ```java
    public class Main {
    
        public static void main(String[] args) {
            Test<Integer> test = new Test<>(100);
            
            // Integer가 아닌 String 타입의 인자를 넣었지만 컴파일 에러가 발생하지 않는다.
            // 제네릭 메서드의 타입 변수는 클래스의 타입 변수와는 별도이기 때문이다.
            test.show("hello", "world");
        }
    }
    ```
    
    ```
    hello
    world
    ```
    
    - Test 클래스의 제네릭으로 T가 사용되고, 인스턴스를 생성할 때 이를 `Integer`로 지정했다.
    - 하지만, 제네릭 메서드 `show()`도 같은 문자인 T로 타입 변수를 사용하지만, `String` 타입의 데이터를 넣었을 때 컴파일 에러가 발생하지 않았다.
    - 이는 **제네릭 메서드에 사용되는 타입 변수가 클래스에 지정된 타입 변수와 이름이 같다 하더라도, 엄연히 독립적으로 취급**한다는 것을 의미한다.

### 와일드 카드

제네릭 클래스에서 타입 제한을 사용해 특정 타입과 그의 하위 타입만을 허용한 것처럼, 제네릭 메서드에서도 `와일드 카드를 이용해 매개변수 타입에 대한 제한`을 설정할 수 있다.

static 메서드에서도 타입 제한을 이용해 특정 타입들의 매개변수만 허용하기를 원할 수도 있다.

하지만 앞서 제네릭 클래스에 대해 학습하면서, static 메서드에는 클래스 단위의 제네릭을 사용할 수 없다는 것을 알았다. 따라서 아래의 코드는 컴파일 에러가 발생한다.

```java
public class Test<T extends Number> {

    public static void show(List<T> numberList) {
        System.out.println(numberList);
    }
}
```

```
java: non-static type variable T cannot be referenced from a static context
```

그렇다면 static 메서드에서는 어떻게 타입 제한을 할 수 있을까?

일단 아래처럼 각 타입에 맞는 메서드를 오버로딩하여 작성하는 방법을 떠올릴 수 있다.

```java
import java.util.List;

public class Test {

    public static void show(List<Integer> intList) {
        System.out.println(intList);
    }

    public static void show(List<Double> doubleList) {
        System.out.println(doubleList);
    }
}
```

```
java: name clash: method(java.util.List<java.lang.Double>) and method(java.util.List<java.lang.Integer>) have the same erasure
```

- 아쉽게도 위 코드는 컴파일 에러가 발생한다.
- 매개변수의 타입이 달라서 오버로딩이 된다고 생각할 수 있지만, 단순히 `제네릭 타입만 다른 경우는 매개변수의 타입이 다르다고 취급하지 않는다.` 제네릭 타입이 달라도 List 타입인 것은 동일하기 때문에, 결국 위와 아래의 메서드는 시그니처가 동일하다고 취급된다.

**와일드 카드**를 이용하면 위의 문제를 해결할 수 있다. 와일드 카드는 `?`로 표현한다.

제네릭 클래스에서는 하위 타입으로만 제한하던 것과 달리, 와일드 카드에는 세 종류가 존재한다.

1. `<? extends T>` : 상한 제한(T가 상한)으로, 특정 타입과 그의 하위 타입만을 허용한다.
2. `<? super T>` : 하한 제한(T가 하한)으로, 특정 타입과 그의 상위 타입만을 허용한다.
3. `<?>` : 제한 없음으로, 모든 타입을 허용한다. `<? extends Object>`와 동일한 개념이다.

```java
import java.util.List;

public class Test {

    public static void show(List<? extends Number> numberList) {
        System.out.println(numberList);
    }
}
```

```java
import java.util.ArrayList;
import java.util.List;

public class Main {

    public static void main(String[] args) {
        // Integer List 생성
        List<Integer> intList = new ArrayList<>();
        intList.add(1);
        intList.add(2);

        // Double List 생성
        List<Double> doubleList = new ArrayList<>();
        doubleList.add(1.0);
        doubleList.add(2.0);

        // Test 클래스의 static 메서드 호출
        Test.show(intList);
        Test.show(doubleList);
    }
}
```

```
[1, 2]
[1.0, 2.0]
```

- 와일드 카드를 이용해 static 메서드의 매개변수에 대한 타입 제한을 설정하면 된다.
- 여기에서는 Number 클래스와 하위 타입만을 허용하도록 제한하였다.