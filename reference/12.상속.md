

# 상속

## 상속(Inheritance)이란?

### 개념

상속(Inheritance)이란, 기존 클래스(부모 클래스)의 멤버를 새로운 클래스(자식 클래스)가 `물려받아` 사용하는 기능을 말한다.

자신의 멤버 변수와 메서드를 물려주는 기존 클래스를 `부모 클래스` 혹은 `상위 클래스`라고 한다.

기존 클래스의 멤버 변수와 메서드를 물려받는 새로운 클래스를 `자식 클래스` 혹은 `하위 클래스`라고 한다.

상속은 `extends` 키워드를 이용해 적용할 수 있다.

```java
public class Parent {
    // 부모 클래스
}
public class Child extends Parent {
    // 자식 클래스
}
```

- extends는 “확장하다”라는 뜻의 단어이다. 따라서, 상속을 한다는 것은 기존 클래스의 기능에 더해 `새로운 클래스에서 기능을 확장한다`는 의미를 가진다.
- 생성자와 초기화 블록은 상속되지 않고 오로지 `멤버 변수와 메서드만 상속`된다.

Java는 오직 `단일 상속만 지원`한다. 아래처럼 다중 상속을 시도하는 경우 `컴파일 에러`가 발생한다.

```java
public class Child extends Parent1, Parent2 {
    // 문법 오류!!!
}
```

```
java: Class cannot extend multiple classes
```

### 장점

상속은 `코드의 재사용성을 높이고 중복을 제거`할 수 있다는 장점이 존재한다. 이를 예시를 통해 알아보자.

먼저, 사람을 의미하는 클래스인 Person을 아래와 같이 선언하였다.

```java
public class Person {

    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return this.name;
    }

    public int getAge() {
        return this.age;
    }
}
```

- 사람의 이름을 나타내는 `name`과 나이를 나타내는 `age`가 인스턴스 변수로 정의되어 있다.
- 생성자와 각종 인스턴스 메서드들도 정의되어 있다.

만약, 사람이자 동시에 학생인 사람들에 대해 별도의 Student 클래스로 선언해야 한다고 가정해보자.

학생들은 사람이 가지는 속성과 기능을 그대로 가지면서, 학생만의 속성과 기능을 추가적으로 가져야 한다.

상속의 개념이 없다면, Student 클래스를 아래와 같이 작성해야만 한다.

```java
public class Student {

    private String name;
    private int age;
    private String major;

    public Student(String name, int age, String major) {
        this.name = name;
        this.age = age;
        this.major = major;
    }

    public String getName() {
        return this.name;
    }

    public int getAge() {
        return this.age;
    }

    public String getMajor() {
        return this.major;
    }
}
```

- Student에도 Person에 있는 인스턴스 변수와 메서드들을 그대로 포함시킨다.
- 학생이라는 특성에 맞게, 전공을 나타내는 `major`가 인스턴스 변수로 정의되어 있고 관련 인스턴스 메서드도 추가되었다.

Student는 Person의 모든 변수와 메서드를 포함하면서 학생이라는 특성에 맞게 기능을 확장한 클래스이다.

따라서 **Student에서 Person의 모든 변수와 메서드를 사용하기 위해서는 중복으로 코드를 작성**할 수 밖에 없다.

이러한 중복을 `상속`을 통해 개선해보자.

```java
public class Student extends Person {

    private String major;

    public Student(String name, int age, String major) {
        super(name, age); // 부모 클래스의 생성자 호출
        this.major = major;
    }

    public String getMajor() {
        return this.major;
    }
}
```

- Person이 부모 클래스가 되고, Student가 자식 클래스가 되었다.

- 따라서 Student는 중복 코드 없이도 Person의 속성과 기능을 모두 사용할 수 있다. (Student에 직접 작성하지 않은 `getName()`과 `getAge()` 메서드 사용 가능)

- `extends`의 의미에 맞게, Person의 모든 것을 포함하면서 Student에 기능을 추가하여 `확장`시켰다.

![[Pasted image 20250924160654.png]]

### super()

`super()`는 자식 클래스에서 `부모 클래스의 생성자를 호출`하는데 사용된다.

`this()`는 같은 클래스의 다른 생성자를 호출하지만, `super()`는 부모 클래스의 생성자를 호출한다.

자식 클래스는 부모 클래스의 모든 것을 포함하므로, **일단 부모 클래스의 멤버에 대한 초기화 작업이 우선**되어야 한다. 따라서, `자식 클래스의 생성자의 맨 첫 줄에서 반드시 super()가 먼저 호출`되어야 한다.

```java
public class Child extends Parent {
    
    자식 클래스 인스턴스 변수1;
    자식 클래스 인스턴스 변수2;
    
    public Child() {
        super(); // 맨 첫 줄에서 반드시 호출
        자식 클래스 인스턴스 변수 초기화 동작 1;
        자식 클래스 인스턴스 변수 초기화 동작 2;
        ...
    }
}
```

`super()`를 사용할 때, 아래와 같은 몇 가지 `특징`이 존재한다.

1. **super()를 생략하면, 컴파일러가 부모 클래스의 기본 생성자를 호출하는 super()를 자동으로 삽입한다.**

   ```java
   public class Parent {
   
       // 부모 클래스 기본 생성자
       public Parent() {
       }
   }
   ```

   ```java
   public class Child extends Parent {
   
       // 자식 클래스 기본 생성자
       public Child() {
           // 부모 클래스의 기본 생성자를 호출하는 super()를 컴파일러가 자동으로 삽입한다.
       }
   }
   ```

   - Child의 생성자에서 명시적으로 `super()`를 호출하지 않아도, 컴파일 단계에서 자동으로 `super()`가 삽입된다.
   - 자식 클래스의 인스턴스가 생성될 때, 자동으로 `부모 클래스의 기본 생성자`가 먼저 호출되어 부모 클래스의 인스턴스가 먼저 생성되고, 이후 자식 클래스 생성자의 나머지 동작을 수행한다.

2. **부모 클래스에 기본 생성자가 없다면, 자식 클래스의 생성자에서 매개변수가 있는 super()를 명시적으로 호출해야 한다.**

   ```java
   public class Parent {
   
       private String parentValue;
       
       // 부모 클래스에 매개변수가 있는 생성자만 존재 (기본 생성자 X)
       public Parent(String parentValue) {
           this.parentValue = parentValue;
       }
   }
   ```

   ```java
   public class Child extends Parent {
   
       private String childValue;
   
       public Child(String parentValue, String childValue) {
           super(parentValue); // 명시적으로 매개변수가 있는 super()를 호출해야 한다.
           this.childValue = childValue;
       }
   }
   ```

   - 부모 클래스에 매개변수가 있는 생성자만 존재한다면, 자식 클래스의 생성자에서 부모 클래스의 기본 생성자를 호출할 수 없다. 즉, **매개변수가 없는 super()를 호출할 수 없다.**
   - 기본 생성자와 달리, 매개변수가 있는 생성자는 컴파일러에 의해 자동으로 삽입되지 않는다. 따라서, `매개변수가 있는 super()`는 반드시 자식 클래스의 생성자의 첫 줄에 `명시`되어야 한다.

### super

`super`는 부모 클래스의 멤버 변수나 메서드를 참조할 때 사용된다.

`this`는 인스턴스 자신에 대한 참조 변수이지만, `super`는 부모에 대한 참조 변수이다.

자식 클래스는 부모 클래스의 변수와 메서드를 모두 포함하기 때문에, 굳이 `super`를 쓰지 않고 `this`를 써도 무방하다. 하지만 **부모 클래스의 멤버와 자식 클래스의 멤버가 이름이 같게 정의되는 경우**, 이를 구별하기 위해 `super`를 사용한다.

만약, 아래와 같이 Parent 클래스와 Student 클래스의 인스턴스 변수명이 같다고 가정해보자.

```java
public class Parent {

    public String value = "parent value";
}
public class Child extends Parent {

    public String value = "child value";
    
    public void show() {
        System.out.println(value); // 자식 클래스의 value
    }
}
```

- Child의 `show()` 메서드에서 출력하는 `value`는 Child의 `value`이다.

Child에서 자신의 변수 value가 아닌, Parent의 변수 value를 사용하고 싶다면 어떻게 할까?

```java
public class Child extends Parent {

    public String value = "child value";

    public void show() {
        System.out.println(super.value); // 부모 클래스의 value
        System.out.println(this.value); // 자식 클래스의 value
    }
}
```

- `super` 키워드를 이용해 참조한 변수는 부모 클래스에 정의된 변수이다.
- 따라서, `super`와 `this` 키워드를 이용해 이를 명시적으로 구분할 수 있다.
- 인스턴스 변수 뿐만 아니라, 부모 클래스의 **인스턴스** **메서드를 호출**할 때도 `super` 키워드를 사용할 수 있다.

### 메서드 오버라이딩

메서드 오버라이딩(Overriding)이란, 부모 클래스로부터 상속받은 메서드를 자식 클래스에서 `재정의`하는 것을 말한다.

메서드 오버라이딩을 할 수 있는 `조건`은 아래와 같다.

1. **기존 메서드와 재정의한 메서드의 시그니처(이름과 매개변수 정보)가 같아야 한다.**
2. **기존 메서드와 재정의한 메서드의 반환타입이 같아야 한다.**
3. 재정의한 메서드의 접근 제어자는 기존 메서드보다 좁은 범위로 변경할 수 없다.
   - 기존 메서드의 접근 제어자가 protected라면, 재정의한 메서드의 접근 제어자는 반드시 protected이거나 public이어야 한다. private으로 재정의할 수 없다.
4. static 메서드는 재정의 할 수 없다.
   - 자식 클래스에서 동일한 이름으로 static 메서드를 선언할 수는 있지만, 이는 재정의를 한 것이아니라 별개의 메서드를 선언한 것이다.

Person, Student 클래스의 예시를 통해 메서드 오버라이딩에 대해 알아보자.

먼저, Person 클래스를 아래와 같이 선언하였다.

```java
public class Person {

    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void introduce() {
        System.out.println("안녕하세요. " + this.name + "입니다.");
        System.out.println("나이는 " + this.age + "살 입니다.");
    }
}
```

- `introduce()` 메서드를 통해 자신을 소개하는 문구를 출력한다.

다음으로, Student 클래스를 아래와 같이 선언하였다.

```java
public class Student extends Person {

    private String major;

    public Student(String name, int age, String major) {
        super(name, age);
        this.major = major;
    }

    // 메서드 오버라이딩(재정의)
    @Override
    public void introduce() {
        super.introduce(); // 부모 클래스의 메서드 호출
        System.out.println("전공은 " + this.major + "입니다."); // 새로운 로직 추가
    }
}
```

- Student의 경우, 자신을 소개하는 문구에 `major`에 관한 문구를 추가해야 한다. 따라서, 단순히 Person에 선언된 `introduce()`의 로직만으로는 부족하므로, 이를 **오버라이딩(재정의)하여 로직을 추가해야 한다.**
- 이를 위해, `super` 키워드로 부모의 `introduce()`를 먼저 호출하고 이후 새로운 출력 로직을 추가하였다.
- 재정의한 메서드 위의 `@Override`는 Java의 어노테이션이다. 붙이지 않아도 오버라이딩은 가능하다. 하지만 해당 메서드를 재정의한다는 의도를 잘 드러낼 수 있으므로 일반적으로 붙이는 것이 권장된다.

Main 클래스의 main 메서드에서 각 클래스의 `introduce()` 메서드를 호출한 후 결과를 알아보자.

```java
public class Main {

    public static void main(String[] args) {
        // Person 인스턴스
        Person person = new Person("kyle", 17);
        person.introduce();

        System.out.println(); // 구분을 위한 공백 출력

        // Student 인스턴스
        Student student = new Student("alex", 21, "economics");
        student.introduce();
    }
}
```

```
안녕하세요. kyle입니다.
나이는 17살 입니다.

안녕하세요. alex입니다.
나이는 21살 입니다.
전공은 economics입니다.
```

만약, 메서드 오버라이딩이 없다면 Student 클래스에 `introduceStudent()`와 같은 다른 이름의 메서드를 추가해야 한다. 즉, Student는 `introduce()`와 `introduceStudent()`를 모두 호출할 수 있는 상태가 된다.

이는 학생이 반드시 major에 대한 문구를 소개에 추가해야한다는 요구사항을 어길 수 있는 가능성을 만든다.

따라서, 기존 메서드 자체를 재정의하여 Person과 Student에 상관없이 `introduce()`라는 이름으로만 호출할 수 있도록 만들어, “자기 소개”라는 기능의 `일관성`을 보장해야 한다.

------

## Object 클래스

### 개념

Object 클래스는 모든 클래스의 `최상위 부모 클래스`이다.

Java의 모든 클래스는 `Object 클래스를 암묵적으로 상속`받으며, 이로 인해 아래와 같은 기본 메서드를 자동으로 상속받는다. 따라서, 각 클래스는 상황에 맞게 해당 메서드들을 오버라이딩하여 기능을 확장할 수 있다.

| **Object 클래스의 메서드**                                                          | **설명**                                                                                 |
| ---------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- |
| `String toString()`                                                          | 객체 자신의 정보를 문자열로 반환한다.                                                                  |
| `boolean equals(Object obj)`                                                 | 객체 자신과 obj가 동등한 객체인지 비교한다.                                                             |
| `int hashCode()`                                                             | 객체 자신의 해시코드를 반환한다.                                                                     |
| Object clone()                                                               | 객체 자신의 복사본을 반환한다.                                                                      |
| void finalize()                                                              | 가비지 컬렉션에 의해 객체가 소멸될 때 호출된다.                                                            |
| Class getClass()                                                             | 객체 자신의 클래스 정보를 담고 있는 Class 인스턴스를 반환한다.                                                 |
| void notify()                                                                | 현재 객체를 사용하려고 기다리는 쓰레드 중 하나를 깨운다.                                                       |
| void notifyAll()                                                             | 현재 객체를 사용하려고 기다리는 모든 쓰레드를 깨운다.                                                         |
| void wait()<br>void wait(long timeout)<br>void wait(long timeout, int nanos) | 다른 쓰레드가 notify()나 notifyAll()을 호출할 때까지, 현재 쓰레드를 무한히 혹은 지정된 시간(timeout, nanos)동안 대기시킨다. |

이 중 toString(), equals(), hashCode() 메서드를 가장 많이 재정의하여 사용한다. 아래에서 하나씩 살펴보자.

### toString()

객체 자신의 정보를 문자열로 반환하는 메서드이다.

실제 Object 클래스의 `toString()` 메서드는 아래와 같이 작성되어 있다.

```java
public class Object {

		...

		public String toString() {
		    return getClass().getName() + "@" + Integer.toHexString(hashCode());
		}
		
		...
}
```

- 자식 클래스에서 오버라이딩하지 않으면, 객체 출력 시 `클래스이름 + 16진수 해시코드 값`을 출력한다.
- 따라서, 자식 클래스에서 이를 재정의하여 원하는 형식으로 출력될 수 있도록 해야한다.

예를 들어, Person 클래스를 아래와 같이 선언하였다.

```java
public class Person {

    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

Main 클래스의 main 메서드에서 Person 클래스의 인스턴스를 만들고 이를 출력해본다.

```java
public class Main {

    public static void main(String[] args) {
        Person person = new Person("kyle", 30); // 인스턴스 생성
        System.out.println(person); // 출력
    }
}
```

```
com.test.Person@2ff4acd0
```

- `System.out.println()`은 내부적으로, 인자로 넣은 객체의 `toString()` 값을 출력하도록 되어있다.
- Person에서 `toString()`을 따로 재정의 하지 않았기 때문에, Object 클래스의 로직을 그대로 사용한다.
- 따라서, 인스턴스를 출력하면 `클래스이름 + 16진수 해시코드 값`이 나타난다.

원하는 형식으로 출력하고 싶다면 `toString()`을 오버라이딩 하면 된다.

```java
public class Person {

    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "이름: " + this.name + ", 나이: " + this.age;
    }
}
```

이후 main 메서드를 다시 실행하면, 이번에는 원하는 형식으로 출력된다.

```
이름: kyle, 나이: 30
```

### equals(Object obj)

객체 자신과 obj가 동등한 객체인지 비교하는 메서드이다.

실제 Object 클래스의 `equals()` 메서드는 아래와 같이 작성되어 있다.

```java
public class Object {

		...

		public boolean equals(Object obj) {
		    return (this == obj);
		}
		
		...
}
```

- 자식 클래스에서 오버라이딩 하지 않으면, `동일 연산자(==)`를 통해 두 객체가 `서로 같은 주소값`을 갖는지 비교한다.

예를 들어, Person 클래스를 아래와 같이 선언하였다.

```java
public class Person {

    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

Main 클래스의 main 메서드에서 Person 클래스의 인스턴스를 동일한 정보로 2개를 만들고 이를 비교해본다.

```java
public class Main {

    public static void main(String[] args) {
        Person person1 = new Person("kyle", 30);
        Person person2 = new Person("kyle", 30);

        System.out.println(person1.equals(person2));
    }
}
```

```
false
```

- person1과 person2 모두 동일한 name과 age를 가지고 있으므로, 이를 비교하면 `true`가 나오지 않을까라고 착각할 수 있다.
- Person에서 `equals()`를 따로 재정의 하지 않았기 때문에, Object 클래스의 로직을 그대로 사용한다.
- 따라서, 현재의 `equals()` 메서드는 객체의 주소값을 `==`로 비교하기 때문에, 내부 변수들의 값이 같다해도 서로 다르다는 결과를 반환한다.

주소값이 아니라, 내부 변수들의 값을 기준으로 비교하고 싶다면 `equals()` 를 오버라이딩 하면된다.

```java
public class Person {

    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null || getClass() != obj.getClass()) {
            return false; // null이거나 타입이 다른 객체라면 비교할 것도 없이 false를 반환
        }

        Person other = (Person)obj; // Object -> Person 형변환
        return this.name.equals(other.name) && this.age == other.age;
    }
}
```

- obj가 비교할 수 있는 유효한 객체인지에 대한 검사를 먼저 수행해야 한다.
- obj는 Object 타입이기 때문에, 내부 변수의 값을 비교하려면 Person 타입으로 형변환 해야한다.

이후 main 메서드를 다시 실행하면, 이번에는 원하는대로 내부 변수 값을 이용해 비교한다.

```
true
```

대표적으로, Java의 `문자열(String)`도 리터럴 값을 통해 비교할 수 있도록 equals()가 재정의되어 있다.

```java
public final class String 
		implements java.io.Serializable, Comparable<String>, CharSequence,
               Constable, ConstantDesc{
		
		...
		
		public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        return (anObject instanceof String aString)
                && (!COMPACT_STRINGS || this.coder == aString.coder)
                && StringLatin1.equals(value, aString.value);
    }
    
    ...
}
```

### hashCode()

객체 자신의 해시코드를 반환한다.

실제 Object 클래스의 `hashCode()` 메서드는 아래와 같이 작성되어 있다.

```java
public class Object {

		...
		
		@IntrinsicCandidate
		public native int hashCode();

		...
}
```

- 객체의 메모리 주소 값을 이용하여 `해시 코드`를 만들어 반환한다.
- 정확히 말하면 해시 코드는 주소값과는 조금 다르다. 다만 주소값을 통해 만들어지는 `고유한 값`이기 때문에 각 객체를 구별할 수 있는 값이 된다.
- 32bit JVM에서 서로 다른 두 객체는 같은 해시 코드를 가질 수 없었다. 하지만, 64bit JVM에서는 8 byte 주소값으로 4 byte의 해시 코드를 만들기 때문에 중복 가능성이 존재한다.
- 메서드를 살펴보면 native라는 키워드가 등장하며 구현부가 보이지 않는다. 이는 OS가 가지고 있는 저수준의 native 언어로 작성되어 있기 때문이고, Java에서는 해당 메서드를 호출할 수만 있지, 상세 구현은 볼 수 없다. 저수준의 native 언어를 Java에서도 실행할 수 있는 이유는 `JNI(Java Native Interface)` 덕분이다.

 🚨**equals() 메서드를 재정의할 때는, 반드시 hashCode() 메서드도 함께 재정의 해야한다.**

만약 함께 재정의하지 않으면, Java의 컬렉션 프레임워크에서 **해시 코드를 사용하는 HashSet, HashMap과 같은 자료구조를 사용할 때 문제가 발생할 수 있다.**

```java
@Override
public int hashCode() {
    return Objects.hash(name, age);
}
```


---
# 상속 실습

- inheritanceprac 이라는 패키지를 생성하시오.
    
- Main 클래스를 생성하고 main 메서드를 작성하시오.
    
- 다음을 구현하시오
    
    - 이름, 나이, 소리내기 기능 갖는 Animal 클래스를 구현하시오.
    - Animal 클래스를 상속받는 Dog 클래스를 작성하시오.
        - 소리내기 기능을 오버라이딩 하시오.
        - 품종 변수를 추가하시오.
    - Animal 클래스를 상속받는 Cat 클래스를 작성하시오.
        - 소리내기 기능을 오버라이딩하시오.
        - 골골대는 기능을 추가하시오.
- 다음을 구현하시오
    
    - 모델명, 속도, 연료량을 갖는 Vehicle 클래스를 구현하시오.
        - 속도 관련 기능을 구현하시오
        - 최대 연료량은 100입니다
    - Vehicle 클래스를 상속받는 Bus 클래스를 작성하시오.
        - 승객 관련 기능을 추가하시오
        - 최대 연료량은 300입니다
    - Vehicle 클래스를 상속받는 Truck 클래스를 작성하시오.
        - 짐 관련 기능을 추가하시오
        - 최대연료량은 250입니다
- 다음을 구현하시오
    
    - 이름, 레벨, 체력을 갖는 Character 클래스를 구현하시오
        
        - 레벨은 1부터 시작합니다
        - 기본 공격 기능을 구현하시오 (단순 출력)
        - 레벨업 기능을 구현하시오
    - Character 클래스를 상속받는 Warrior 클래스를 작성하시오
        
        - 분노게이지 관련 기능을 추가하시오 (최대 100)
        - 기본 체력은 120입니다
        - 레벨업 시 체력 30 증가
    - Character 클래스를 상속받는 Mage 클래스를 작성하시오
        
        - 마나 관련 기능을 추가하시오 (최대 100)
        - 기본 체력은 70입니다
        - 레벨업 시 체력 15 증가
    - 추가사항
        
        - 기본 공격 기능을 캐릭터끼리의 상호작용으로 구현하시오.