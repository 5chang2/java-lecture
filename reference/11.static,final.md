# static, final

## static

### 개념

static 키워드는 `정적인, 고정된`이라는 뜻을 가진 제어자이다. `클래스 단위의 멤버에 사용`하며, 이들은 클래스가 최초 로딩되는 시점에 메모리에 적재되므로 별도의 인스턴스 생성 없이도 사용할 수 있다.

### 종류

1. **클래스 변수**
    
    - 모든 인스턴스에서 공통적으로 사용하는 변수를 말한다.
    - 별도의 인스턴스 생성 없이, `클래스명.변수명`의 형태로 사용할 수 있다.
    - 클래스가 최초 로딩되는 시점에 메모리에 적재되어, 프로그램이 종료될 때까지 계속 유지된다.
2. **클래스 초기화 블록**
    
    - 클래스 변수의 복잡한 초기화를 위한 목적으로 사용한다.
    - 클래스가 최초 로딩되는 시점에 `단 한 번만` 수행된다.
    - `자료형의 기본값 → 명시적인 초기화 → 클래스 초기화 블록에 의한 초기화` 순서로 초기화된다.
3. **클래스 메서드**
    
    - 별도의 인스턴스 생성 없이, `클래스명.메서드명`의 형태로 사용할 수 있다.
    - 클래스가 최초 로딩되는 시점에 메모리에 적재되어, 프로그램이 종료될 때까지 계속 사용할 수 있다.
    - **클래스 메서드에서는 인스턴스 변수를 사용하거나, 인스턴스 메서드를 호출할 수 없다.**

### 예시

static 키워드를 이용해 아래와 같이 클래스 변수, 클래스 초기화 블록, 클래스 메서드를 작성할 수 있다.

```java
public class Rectangle {

    // 클래스 변수
    public static String color;

    // 클래스 초기화 블록
    static {
        color = "red";
    }

    // 클래스 메서드
    public static void printInfomation() {
        System.out.println("사각형의 색깔 : " + color);
    }
}
```

---

## final

### 개념

final 키워드는 `마지막의, 최종의`라는 뜻을 가진 제어자이다. `변수, 메서드, 클래스`에 사용하며, 이들은 최초 선언 이후 프로그램이 종료될 때까지 변경될 수 없다.

final 키워드는 아래와 같은 `장점`을 가진다.

1. 재할당, 오버라이딩, 상속 등을 금지하여 의도치 않은 코드 변경을 방지하고 코드의 안정성을 높인다.
2. 해당 변수, 메서드, 클래스가 변경 불가능 하다는 의도를 명시하여 다른 사람이 이를 변경하지 않도록 한다. 이로인해, 예측 불가능한 사고와 에러를 미연에 방지할 수 있다.

### final 변수

final 키워드는 클래스 변수, 인스턴스 변수, 지역 변수에 사용할 수 있다.

final 키워드가 변수와 함께 사용되면, 해당 변수는 한 번 초기화 된 후 값을 `재할당할 수 없다`. (변경 불가능)

1. **final 클래스 변수 (=상수)**
    
    ```java
    public class Rectangle {
    
        // final 클래스 변수 (=상수)
        public static final int MAX_WIDTH = 100; // 명시적인 초기화
    }
    ```
    
    - `static final` 키워드가 붙은 변수로, 클래스가 최초 로딩될 때 초기화 된다. 이후에 프로그램이 종료될 때까지 변경할 수 없다.
    - static을 통해 메모리에 고정되어 프로그램 종료 시까지 유효하며, final을 통해 변경 불가능하기 때문에, static final이 붙은 변수를 `상수(Constant)`라고도 한다.
    - 보통 상수는 `대문자`로만 작성하며, 띄어쓰기는 `언더바(_)`로 표현한다.
    
    final 클래스 변수는 명시적인 초기화를 하지 않는다면, 반드시 클래스 초기화 블록에서 초기화를 해야한다.
    
    ```java
    public class Rectangle {
    
        public static final int MAX_WIDTH;
        
        static {
            MAX_WIDTH = 100; // 클래스 초기화 블록에 의한 초기화
        }
    }
    ```
    
    - 명시적인 초기화나 클래스 초기화 블록에서의 초기화 중 아무것도 하지 않으면 `컴파일 에러`가 발생한다.
    
    final 클래스 변수는 한 번 초기화 된 후, 재할당을 시도하면 `컴파일 에러`가 발생한다.
    
    ```java
    public class Rectangle {
    
        public static final int MAX_WIDTH = 100;
        
        public static void method() {
            MAX_WIDTH = 200; // 재할당 불가능!!!
        }
    }
    ```
    
2. **final 인스턴스 변수**
    
    ```java
    public class Rectangle {
    
        // final 인스턴스 변수
        public final int width = 50; // 명시적인 초기화
    }
    ```
    
    - 각 인스턴스에 고유한 변수로, 인스턴스가 생성될 때 초기화 된다. 이후에 인스턴스가 소멸할 때까지 변경할 수 없다.
    
    final 인스턴스 변수는 명시적인 초기화를 하지 않는다면, 반드시 인스턴스 초기화 블록이나 생성자에서 초기화를 해야한다.
    
    - **인스턴스 초기화 블록에 의한 초기화**
        
        ```java
        public class Rectangle {
        
            public final int width;
        
            {
                width = 50; // 인스턴스 초기화 블록에 의한 초기화
            }
        }
        ```
        
    - **생성자에 의한 초기화**
        
        ```java
        public class Rectangle {
        
            public final int width;
        
            public Rectangle(int width) {
                this.width = width; // 생성자에 의한 초기화
            }
        }
        ```
        
    - 명시적인 초기화, 인스턴스 초기화 블록에서의 초기화, 생성자 초기화 중 아무것도 하지 않으면 `컴파일 에러`가 발생한다.
        
    
    final 인스턴스 변수는 한 번 초기화 된 후, 재할당을 시도하면 `컴파일 에러`가 발생한다.
    
    ```java
    public class Rectangle {
    
        public final int width = 50;
    
        public void method() {
            this.width = 100; // 재할당 불가능!!!
        }
    }
    ```
    
3. **final 지역 변수**
    
    ```java
    public class Rectangle {
    
        public void method() {
            // final 지역 변수
            final int width = 50; // 명시적인 초기화
        }
    }
    ```
    
    - 메서드 안에서 선언된 final 변수로, 해당 메서드가 실행될 때 초기화 된다. 이후 메서드가 종료될 때까지 변경할 수 없다.
    
    final 지역 변수도 일반 지역 변수와 마찬가지로 반드시 명시적인 초기화를 해야한다.
    
    이때에도 미리 선언만 하는 것은 가능하나, 변수를 사용하기 전에는 반드시 값을 초기화 해야한다.
    
    ```java
    public class Rectangle {
    
        public void method() {
            final int width = 50; // 명시적인 초기화
    
            final int height; // 미리 선언은 가능
            height = 20; // 하지만, 이후 사용하기 전에는 초기화 필수
            System.out.println(height);
        }
    }
    ```
    
    final 지역 변수는 한 번 초기화 된 후, 재할당을 시도하면 `컴파일 에러`가 발생한다.
    
    ```java
    public class Rectangle {
    
        public void method() {// final 지역 변수
            final int width = 50;
            width = 100; // 재할당 불가능!!!
        }
    }
    ```
    

### final 메서드

final 키워드는 메서드에도 사용할 수 있다.

final 키워드가 메서드와 함께 사용되면, 해당 메서드는 상속 관계에서 `오버라이딩(Overriding)`할 수 없다.

아직 상속에 관해 학습하지 않았으므로 일단 참고로만 보고 넘어간다.

`상속`은 하나의 클래스를 재사용하여 새로운 클래스를 작성하는 것을 말한다.

따라서 기준이 되는 `부모 클래스`가 존재하고, 이 부모 클래스를 바탕으로 만들어지는 `자식 클래스`가 존재한다.

`오버라이딩`이란, 상속 관계에서 자식 클래스가 부모 클래스에 작성된 메서드의 내용을 `재정의`하는 것이다.

```java
public class ParentClass {

    public void method() {
        // 부모 클래스의 메서드 내용 작성
    }
}
```

```java
public class ChildClass extends ParentClass {

    @Override
    public void method() {
        // 자식 클래스에서 동일 메서드에 대해 내용 재정의(오버라이딩)
    }
}
```

- ParentClass라는 부모 클래스에 method라는 이름의 메서드가 정의되어 있다.
- ParentClass를 상속하는 ChildClass라는 자식 클래스에서 method라는 이름의 메서드를 재정의하여 새로운 내용으로 변경한다.
- 따라서, 오버라이딩이란 결국 메서드를 `변경`하는 것이다.

final 키워드는 변경을 불가능하게 하는 제어자이므로, 메서드에서는 자식 클래스에서의 오버라이딩을 금지시켜 내용을 변경하지 못하도록 막기 위해 사용한다.

```java
public class ParentClass {

    public final void method() {
        // 부모 클래스의 메서드 내용 작성
    }
}
```

```java
public class ChildClass extends ParentClass {

    @Override
    public void method() {
        // final 메서드 오버라이딩 불가능!!!
    }
}
```

```
java: 'method()' cannot override 'method()' in 'com.test.ParentClass'; overridden method is final
```

### final 클래스

final 키워드는 클래스에도 사용할 수 있다.

final 키워드가 클래스와 함께 사용되면, 해당 클래스는 `상속 불가능`한 클래스가 된다.

해당 클래스의 설계 의도를 명확히 하며, 상속을 통해 동작이 변경되거나 확장되지 않도록 보호하려는 경우에 사용한다.

```java
public final class ParentClass {
    
}
```

```java
public class ChildClass extends ParentClass {
		// final 클래스 상속 불가능!!!
}
```

```
java: Cannot inherit from final 'com.test.ParentClass'
```




---

# 접근제어자 실습

- modifierprac 이라는 패키지를 생성하시오.
    
- Main 클래스를 생성하고 main 메서드를 작성하시오.
    
- 다음 내용을 바탕으로 Person 클래스를 구현하시오
    
    - 같은 클래스 내에서만 접근할 수 있는 이름(String name) 변수를 작성하시오.
        
    - 모든 곳에서 접근할 수 있는 나이(int age) 변수를 작성하시오.
        
    - 같은 패키지 내에서만 접근할 수 있는 키(double height) 변수를 작성하시오.
        
    - 같은 클래스 내에서만 접근할 수 있는 “달리기” 메서드를 작성하시오.
        
    - 모든 곳에서 접근할 수 있는 “걷기” 메서드를 작성하시오.
        
    - 같은 패키지 내에서만 접근할 수 있는 “공부하기” 메서드를 작성하시오.
        
    - 접근할 수 없는 변수를 사용하기 위한 메서드를 작성하시오.
        
    - Main 클래스에서 Person 객체를 생성하고 각 변수와 메서드에 접근해보시오.
        
    - 단, 메서드들은 단순 출력으로 구현합니다.
        
- 다음 내용을 바탕으로 BankAccount 클래스를 구현하시오.
    
    - 계좌는 잔액과 비밀번호 정보를 가진다
    - 잔액과 비밀번호는 외부에서 직접 접근할 수 없다
- 다음 기능을 수행할 수 있다.
    
    - 계좌 생성 (비밀번호 설정)
    - 입금
    - 출금 (비밀번호 확인 필요)
    - 잔액 조회 (비밀번호 확인 필요)

단, 입금이나 출금시 0원 이하의 금액은 불가능하며, 잔액보다 큰 금액은 출금할 수 없다.