
# 추상 클래스와 인터페이스

## 다형성(Polymorphism)이란?

### 개념

다형성(Polymorphism)이란, `상위 타입의 참조 변수로 하위 타입의 객체를 참조`할 수 있도록 하는 특성을 말한다.

예를 들어, 도형을 의미하는 Shape 클래스가 있고, 이를 상속하는 Triangle, Rectangle 클래스가 있다고 가정해보자. 상속 계층도로 나타내면 아래와 같다.

![[Pasted image 20250924161304.png]]

Triangle과 Rectangle의 메서드를 사용하기 위해서는 아래와 같이 작성할 수 있다.

```java
Triangle triangle = new Triangle(10, 5);
triangle.calculateArea(); // 삼각형의 면적 계산 메서드

Rectangle rectangle = new Rectangle(15, 30);
rectangle.calculateArea(); // 사각형의 면적 계산 메서드
```

- 각 클래스의 인스턴스를 생성하고, 이를 Triangle과 Rectangle이라는 `하위 타입` 변수에 할당한다.

하위 타입 변수가 아니라, 상위 타입 변수에 인스턴스를 할당할 수도 있다.

```java
Shape triangle = new Triangle(10, 5);
triangle.calculateArea(); // 삼각형의 면적 계산 메서드

Shape rectangle = new Rectangle(15, 30);
rectangle.calculateArea(); // 사각형의 면적 계산 메서드
```

- 각 클래스의 인스턴스를 생성하고, 이를 Shape이라는 `상위 타입` 변수에 할당한다.
- 즉, 상위 타입의 참조 변수가 하위 타입의 인스턴스를 직접 참조하고 있다. `다형성`의 정의에 부합한다.
- 다형성은 사전적으로 “여러 가지의 형태를 가지는 성질”을 뜻한다. 따라서, 다형성에 따라 Shape라는 한 가지의 타입을 통해 Triangle과 Rectangle이라는 여러 타입을 가질 수 있게 된다.

다형성을 이용하면 아래와 같은 여러 `장점`이 존재한다.

1. 다양한 객체를 하나의 타입으로 처리할 수 있으므로, `코드의 유연성`이 높아진다.
2. 새로운 기능을 추가할 때 기존 코드를 수정하지 않아도 되므로, `코드의 확장성`이 높아진다.
3. 공통 부모 클래스를 활용할 수 있으므로. 코드의 중복이 줄어들고 `재사용성`이 높아진다.

### 예시

먼저, 부모 클래스인 Shape를 아래와 같이 선언한다.

```java
public class Shape {

    public int calculateArea() {
        return 0;
    }
}
```

- 자식 클래스에서 재정의할 `calculateArea()` 메서드를 선언한다.
- Shape 자체는 “도형”이라는 추상적인 존재이므로, 면적을 구하는 구체적인 구현은 작성하지 않는다.

자식 클래스인 Triangle과 Rectangle을 아래와 같이 선언한다.

```java
public class Triangle extends Shape {

    private int width;
    private int height;

    public Triangle(int width, int height) {
        this.width = width;
        this.height = height;
    }

    @Override
    public int calculateArea() {
        return (this.width * this.height) / 2;
    }
}
```

```java
public class Rectangle extends Shape {

    private int width;
    private int height;

    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }

    @Override
    public int calculateArea() {
        return this.width * this.height;
    }
}
```

- 각 도형에서 필요한 속성들을 정의한다.
- Shape의 `calculateArea()` 메서드를 각 도형의 면적 공식에 맞게 재정의한다.

Main 클래스의 main 메서드에서 삼각형과 사각형의 면적을 출력하려 한다.

만약, 다형성을 적용하지 않는다면 아래와 같이 하위 타입 변수에 인스턴스를 할당해야 한다.

따라서 출력을 위한 메서드를 삼각형과 사각형으로 나누어 최종적으로 두 개의 메서드를 작성해야 한다.

```java
public class Main {

    public static void main(String[] args) {
        Triangle triangle = new Triangle(10, 5);
        printTriangleArea(triangle);

        Rectangle rectangle = new Rectangle(15, 30);
        printRectangleArea(rectangle);
    }

		// 삼각형의 면적을 출력하는 메서드
    private static void printTriangleArea(Triangle triangle) {
        int triangleArea = triangle.calculateArea();
        System.out.println("삼각형의 면적 : " + triangleArea);
    }

		// 사각형의 면적을 출력하는 메서드
    private static void printRectangleArea(Rectangle rectangle) {
        int rectangleArea = rectangle.calculateArea();
        System.out.println("사각형의 면적 : " + rectangleArea);
    }
}
```

```
삼각형의 면적 : 25
사각형의 면적 : 450
```

- Triangle과 Rectangle은 모두 Shape라는 공통의 부모 클래스로부터 상속을 받는 자식 클래스들이다.
- `calculateArea()` 메서드 또한, Shape라는 공통의 부모 클래스에 정의된 공통의 메서드이다.
- 따라서, 이들을 마치 관련이 없는 타입처럼 취급하여 두 개의 메서드로 기능을 나누는 것은 굉장히 어색하다.

다형성을 이용하면 하나의 메서드로 합칠 수 있다.

```java
public class Main {

    public static void main(String[] args) {
        Shape triangle = new Triangle(10, 5);
        printShapeArea(triangle);

        Shape rectangle = new Rectangle(15, 30);
        printShapeArea(rectangle);
    }

    // 도형의 면적을 출력하는 메서드
    private static void printShapeArea(Shape shape) {
        int shapeArea = shape.calculateArea();

        if (shape instanceof Triangle) {
            System.out.println("삼각형의 면적 : " + shapeArea);
        } else if (shape instanceof Rectangle) {
            System.out.println("사각형의 면적 : " + shapeArea);
        }
    }
}
```

```
삼각형의 면적 : 25
사각형의 면적 : 450
```

- `printShapeArea()`라는 하나의 메서드로 출력 로직을 통합하였다.
- 메서드의 매개변수를 상위 타입인 Shape로 받고 있어, Shape의 하위 타입들을 모두 인자로 넘길 수 있다.
- Shape에 공통 메서드인 `calculateArea()`가 선언되어 있기 때문에 이를 호출 할 수 있다. 실제 구현 로직은 자식 클래스에서 재정의한 로직으로 실행된다.
- 다만, 출력을 할 때는 삼각형과 사각형에 따라 출력 메시지가 다르므로, `instanceof` 연산자를 이용해 **Shape 인스턴스가 정확히 어떤 하위 타입의 인스턴스인지 판별**하여 이에 따라 다르게 출력한다.

다형성을 이용하면 이처럼 상위 타입을 이용해 하나의 타입으로 여러 하위 타입의 인스턴스를 사용할 수 있다.

이후 도형이 더 추가되더라도 메서드를 새로 선언할 필요없이, `단순히 else if문만 추가`하면 된다.

따라서, 다형성에 의해 전반적으로 코드의 중복이 줄어들고 확장성이 높아지게 된다.

---

## 추상 클래스

### 개념

추상 클래스(Abstract Class)란, `완성되지 않은 클래스`를 말한다.

추상 클래스는 자체적으로는 사용하기 힘들고, 추상 클래스를 상속한 자식 클래스를 실질적으로 사용한다.

따라서, 추상 클래스는 `다형성을 위한 상위 타입의 역할`만을 수행한다. 자식 클래스를 어떻게 구현할 것인지에 대한 `틀`을 제시한다고 보면 된다.

추상 클래스는 아래와 같이 `abstract` 키워드를 이용해 선언할 수 있다.

```java
public abstract class AbstractClass {
		
		...
}
```

- 변수, 메서드, 생성자는 일반 클래스와 동일한 방식으로 선언한다.
- 일반 클래스의 상속과 마찬가지로, 추상 클래스를 상속한 자식 클래스에서 추상 클래스에 선언된 변수, 메서드, 생성자를 사용할 수 있다.

추상 클래스는 아래와 같은 `특징`을 가진다.

1. **추상 클래스는 자체 인스턴스를 생성할 수 없다.**
    
![[Pasted image 20250924161558.png]]
    
    - 추상 클래스의 인스턴스를 생성하려고 하면 `컴파일 에러`가 발생한다.
2. **추상 클래스는 구현부가 없는 추상 메서드를 통해, 자식 클래스에게 구현의 책임을 부여한다.**
    

### 추상 메서드

추상 메서드(Abstract Method)란, `구현부가 없는 메서드`를 말한다.

구현부가 없다는 것은 메서드의 시그니처와 반환 타입만 정의하고, 블록 내부를 정의하지 않는다는 것을 말한다.

추상 메서드 또한 아래와 같이 `abstract` 키워드를 이용해 선언할 수 있다.

```java
public abstract class AbstractClass {

		...

    public abstract void abstractMethod1();
    public abstract void abstractMethod2(int number);
    public abstract void abstractMethod3(int number1, int number2);
}
```

- 구현부가 없으므로 중괄호는 생략하고, 매개변수를 정의하는 소괄호 이후에 세미콜론(;)을 붙인다.

추상 메서드는 추상 클래스를 상속한 자식 클래스에서 `재정의(오버라이딩)`하여 구현부를 정의해야 한다.

```java
public abstract class Parent {

    public abstract void hello(); // 추상 메서드
}
```

```java
public class Child extends Parent {

    @Override
    public void hello() {
        System.out.println("Hello World!"); // 구현부 재정의
    }
}
```

- 추상 메서드는 그 자체로는 의미가 없는 일종의 `명세`와 같은 역할을 한다.
- **추상 메서드는 반드시 재정의 되어야 한다.** 자식 클래스에서 추상 메서드를 재정의하지 않으면 `컴파일 에러`가 발생한다.

### 사용 이유

일반 클래스도 상속할 수 있고, 메서드를 재정의할 수 있다. 그렇다면 추상 클래스는 왜 사용하는 것일까?

이를 이해하기 위해서는, 먼저 `추상화(Abstraction)`라는 용어에 대해 알아야 한다.

일상에서는 `“추상적이다.”` 라는 단어를 `“모호한, 손에 잡히지 않는”` 이라는 뜻으로 많이 사용하는데, 결국 “**핵심적인 사항만 정해지고, 구체적인 사항은 정해지지 않았음”**을 의미한다.

따라서, 추상화란 `세부적인 부분은 가리고, 중요한 부분만 드러내는 것`을 의미한다.

추상화는 컴퓨터 공학 전반적으로 굉장히 중요한 의미를 가진다. 컴퓨터 공학의 모든 것이 추상화이기 때문이다.

- 키보드를 눌렀을 때 어떤 원리로 글자가 나타나는지 알지 못해도, 우리는 키보드로 글을 쓸 수 있다.
- 운영체제가 어떤 원리로 프로세스를 실행시키는지 알지 못해도, 우리는 프로세스를 띄우고 제거할 수 있다.
- `Integer.parseInt()`의 세부 동작을 알지 못해도, 우리는 문자열을 정수로 변환할 수 있다.

이런 것들이 모두 추상화에 해당한다. 세부적인 것들은 몰라도 핵심만 알 수 있도록 하는 것이다.

결국 추상 클래스는 이름 그대로, 추상화를 위한 의도로 만들어진 클래스라고 할 수 있다.

앞서 다형성에 관해 설명할 때, Shape와 자식 클래스 Triangle, Rectangle을 예시로 사용했다.

```java
public class Shape {

    public int calculateArea() {
        return 0;
    }
}
```

- Shape는 일반 클래스이다. 따라서, 인스턴스를 생성할 수도 있고 `calculateArea()` 메서드를 호출할 수도 있다.
- **하지만, “도형”은 추상적인 개념이다. “도형”이라는 존재가 그 자체로 실재하지도 않고, 면적을 계산할 수도 없다. 오로지 “삼각형”, “사각형”과 같은 구체적인 존재로써만 의미가 있다.**

따라서, 도형의 세부적인 구현은 가리고 중요한 특징만 드러낼 필요가 있다. Shape를 추상 클래스를 통해 정의하면, 아직 `calculateArea()`가 어떻게 구현될지는 모르지만, 중요한 부분(=면적 계산)에 대해서는 먼저 드러낼 수 있다.

```java
public abstract class Shape {

		// 인스턴스 변수
    protected int width;
    protected int height;

		// 생성자
    protected Shape(int width, int height) {
        this.width = width;
        this.height = height;
    }

		// 인스턴스 메서드
    public void show() {
        System.out.println("너비 : " + this.width);
        System.out.println("높이 : " + this.height);
    }

		// 추상 메서드
    public abstract int calculateArea();
}
```

- 추상 클래스도 자체적인 변수, 생성자, 메서드를 가질 수 있다. 하지만, 자체 인스턴스를 생성할 수는 없으므로, 멤버들을 사용하기 위해서는 반드시 상속을 통해 자식 클래스를 구현해야 한다.
- 추상 메서드 `calculateArea()`는 면적을 구하는 메서드가 있어야 한다는 `명세`의 의미를 갖는다. 실제 세부적인 구현은 자식 클래스에서 담당한다.

자식 클래스 Triangle과 Rectangle은 아래와 같이 선언한다.

```java
public class Triangle extends Shape {

    public Triangle(int width, int height) {
        super(width, height);
    }

    @Override
    public int calculateArea() {
        return (this.width * this.height) / 2; // 추상 메서드 구현
    }
}
```

```java
public class Rectangle extends Shape {

    public Rectangle(int width, int height) {
        super(width, height);
    }

    @Override
    public int calculateArea() {
        return this.width * this.height; // 추상 메서드 구현
    }
}
```

- 삼각형과 사각형 모두 너비와 높이를 공통적으로 가지고 있으므로, 이는 추상 클래스에 정의된 인스턴스 변수width와 height를 사용한다.
- 면적을 구하는 공식은 삼각형과 사각형이 각각 다르므로, 이는 추상 메서드를 재정의하여 구현한다.

다형성을 이용해 이들을 아래와 같이 사용할 수 있다.

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("도형의 종류를 입력하세요 : ");
        String shapeType = scanner.nextLine();

        Shape shape = null; // 일단 null로 초기화

        // 사용자의 입력에 따라 인스턴스가 달라짐 => 다형성
        if (shapeType.equals("삼각형")) {
            shape = new Triangle(3, 5);
        } else if (shapeType.equals("사각형")) {
            shape = new Rectangle(10, 20);
        }

        int area = shape.calculateArea(); // 인스턴스의 재정의된 메서드가 호출됨
        System.out.println("면적 : " + area);
    }
}
```

```
>>> 도형의 종류를 입력하세요 : 삼각형
면적 : 7
```

```
>>> 도형의 종류를 입력하세요 : 사각형
면적 : 200
```

1. 사용자는 도형의 종류(삼각형, 사각형 등)를 입력한다.
2. 조건문을 통해 도형의 종류에 따라 인스턴스를 생성하고, Shape 타입의 변수 shape에 할당한다.
3. 해당 도형의 면적을 구하고 출력한다.

사용자의 입력에 따라 Triangle의 인스턴스가 생성될 지, Rectangle의 인스턴스가 생성될 지 결정된다.

하지만, 모두 Shape의 하위 타입이기 때문에 어떤 인스턴스가 생성되든 Shape 타입의 변수에 할당될 수 있다.

Shape에서는 `calculateArea()`를 추상 메서드로 정의하여 반드시 자식 클래스에서 구현하도록 강제하였다.

따라서, Triangle이든 Rectangle이든 `calculateArea()`를 무조건 호출 할 수 있다는 것이 보장된다.

결론적으로, 면적을 구한다는 핵심 사항만 알고 있으면, 세부 구현이 어떻게 되는지 알지 못해도 도형의 면적을 구할 수 있다. 이것이 바로 추상 클래스를 이용한 `추상화`이다. 추상 클래스는 이러한 추상화와 다형성이라는 특징을 통해 훨씬 유연하고 확장성 있는 프로그래밍을 가능하게 한다.

---

## 인터페이스

### 개념

인터페이스(Interface)란, 일종의 `명세`로써 각 구현 클래스들이 어떤 기능을 필수로 구현해야 하는지를 정의한 추상 클래스를 말한다.

인터페이스는 Java에서만 사용하는 용어는 아니다. 원래 인터페이스는 `“서로 다른 대상끼리 맞닿은 면”`을 의미한다. 그래서 `GUI`나 `CLI`와 같은 것들에서 `I`가 모두 인터페이스를 의미하는데, 이들은 컴퓨터와 사람이라는 서로 다른 대상이 맞닿을 수 있는 면을 제공하고 정해진 규칙을 통해 서로 소통할 수 있게 한다.

Java의 인터페이스에는 각 클래스들이 어떤 메서드를 구현해야 하는지에 대한 선언부만 작성된다. 메서드를 사용하는 외부 대상은 명세에 따라 호출만 할 뿐, 실제 세부 구현은 알지 못한다. 세부 구현은 각 구현 클래스에서만 알고 있다. 따라서, 인터페이스도 추상 클래스와 마찬가지로 추상화와 다형성이라는 특징을 통해 유연한 프로그래밍을 가능하게 하고자 사용된다.

인터페이스는 아래와 같이 `interface` 키워드를 이용해 선언할 수 있다.

```java
public interface Interface {

    int NUMBER = 2;

    void abstractMethod1();
    void abstractMethod2(int number);
    void abstractMethod3(int number1, int number2);
}
```

인터페이스는 아래와 같은 `특징`을 가진다.

1. 인터페이스의 변수는 `public static final`로 취급한다.
2. 인터페이스의 메서드는 `public abstract`로 취급한다.
3. 인터페이스는 다중 구현을 지원한다.

### 구현

인터페이스는 상속이라는 용어 대신, `구현(Implementation)`이라는 용어를 사용한다.

인터페이스는 추상 클래스처럼 자체적인 인스턴스 변수나 메서드를 가질 수 없으므로, 훨씬 추상체에 가깝다.

인터페이스의 명세를 실제로 구현하는 클래스들은 이를 상속한다기 보다는 `구현한다`는 의미가 더 자연스럽다.

인터페이스의 구성 요소를 물려 받는다는 느낌보다는, 작성된 명세의 내용을 실제로 채우는 느낌이기 때문이다.

인터페이스의 구현은 아래와 같이 `implements` 키워드를 통해 할 수 있다.

```java
public interface Parent {

    void hello();
}
```

```java
public class Child implements Parent {

    @Override
    public void hello() {
        System.out.println("Hello World!");
    }
}
```

- 인터페이스의 메서드는 모두 추상 메서드이기 때문에, 구현 클래스에서는 이를 반드시 재정의해야 한다.
- 메서드 재정의 시 접근 제어자는 부모 클래스 메서드의 접근 제어자보다 `같거나 넓은 범위`여야 한다. 인터페이스의 메서드는 기본적으로 `public`이므로, 재정의 할 때 메서드의 접근 제어자를 무조건 `public`으로 설정해야 한다. (”해야 한다” 보다는 “할 수 밖에 없다”에 더 가깝다.)

### 다중 구현

Java는 기본적으로 클래스의 다중 상속을 허용하지 않는다. 하지만, 인터페이스는 다중 구현이 가능하다.

```java
public interface Parent1 {

    void parent1Method();
}
```

```java
public interface Parent2 {

    void parent2Method();
}
```

```java
public class Child implements Parent1, Parent2 {

    @Override
    public void parent1Method() {
        // Parent1의 메서드를 구현
    }

    @Override
    public void parent2Method() {
        // Parent2의 메서드를 구현
    }
}
```

- Child 구현 클래스는 Parent1과 Parent2 인터페이스를 모두 구현한다. (다중 구현)
- Child 구현 클래스는 Parent1과 Parent2 인터페이스에 선언된 모든 추상 메서드를 재정의해야 한다. 즉, Parent1과 Parent2에 정의된 모든 기능을 가진다.

또한, `extends`와 `implements` 키워드를 동시에 사용하여 여러 클래스를 상속 및 구현하는 것도 가능하다.

```java
public class AnotherParent {

}
```

```java
public class Child extends AnotherParent implements Parent1, Parent2 {

    @Override
    public void parent1Method() {
        // Parent1의 메서드를 구현
    }

    @Override
    public void parent2Method() {
        // Parent2의 메서드를 구현
    }
}
```

### static 메서드

Java 8 이전에는 인터페이스에 추상 메서드만 정의할 수 있었다. 그래서 인터페이스를 구현한 클래스들에서 공통으로 필요한 static 메서드를 구현하기 위해서는 별도의 클래스를 따로 만들어서 구현해야만 했다.

이러한 불편함을 해결하고자 Java 8 버전부터는 인터페이스에도 static 메서드를 정의할 수 있게 되었다.

```java
public interface Interface {

    static void staticMethod() {
        // static 메서드 구현
    }
}
```

- 인터페이스의 static 메서드도 public 접근 제어자를 가진 것으로 취급된다.
- `Interface.staticMethod()`의 형태로 호출할 수 있다.

### default 메서드

인터페이스에 메서드를 추가하면, 인터페이스를 구현하고 있던 클래스들은 모두 새로 추가된 메서드를 재정의해야 한다. 추상 메서드는 반드시 자식 클래스에서 재정의해야 하기 때문이다.

아래는 Child1과 Child2 클래스가 Parent 인터페이스를 구현하는 예시이다.

```java
public interface Parent {

    void method();
}
```

```java
public class Child1 implements Parent {

    @Override
    public void method() {
        // Child1에서 method 구현
    }
}
```

```java
public class Child2 implements Parent {

    @Override
    public void method() {
        // Child2에서 method 구현
    }
}
```

만약 Parent 인터페이스에 메서드가 추가되면 어떨까?

```java
public interface Parent {

    void method();
    void additionalMethod(); // 메서드 추가
}
```

- 이후 Child1과 Child2에서는 `additionalMethod()`를 재정의하지 않았다는 `컴파일 에러`가 발생한다.

따라서, Child1과 Child2에 각각 `additionalMethod()`를 재정의해야 한다.

```java
public class Child1 implements Parent {

    @Override
    public void method() {
        // Child1에서 method 구현
    }

    @Override
    public void additionalMethod() {
        // Child1에서 additionalMethod 구현
    }
}
```

```java
public class Child2 implements Parent {

    @Override
    public void method() {
        // Child2에서 method 구현
    }

    @Override
    public void additionalMethod() {
        // Child2에서 additionalMethod 구현
    }
}
```

- 인터페이스를 구현한 클래스가 많으면 많을수록, 새로운 메서드를 추가하면 재정의해야 하는 것들도 많아진다. 이는 유지보수성을 떨어뜨린다.

Java 8 버전부터는 인터페이스에 default 메서드를 작성하여 이 문제를 해결한다.

```java
public interface Parent {

    void method();
    
    default void additionalMethod() {
        // Parent 인터페이스에서 구현
    }
}
```

- 인터페이스의 default 메서드도 public 접근 제어자를 가진 것으로 취급된다.
    
- default 메서드는 자체 구현부를 가질 수 있다. 하지만 static 메서드와 달리 default 메서드는 구현 클래스를 통해서만 호출이 가능하다. (`Parent.additionalMethod()`로 호출 불가능)
    
- 구현 클래스에서는 default 메서드를 반드시 재정의하지 않아도 된다. 기존 로직을 그대로 사용해도 되고, 만약 새로운 로직이 필요하다면 그 때 재정의하면 된다. 따라서 **기존 구현 클래스에 대한 수정 없이도 인터페이스에 새로운 메서드를 추가**할 수 있게 된다.
    
    ```java
    public class Child1 implements Parent {
    
        @Override
        public void method() {
            // Child1에서 method 구현
        }
        
        // Child1은 additionalMethod를 재정의하지 않음
    }
    ```
    
    ```java
    public class Child2 implements Parent {
    
        @Override
        public void method() {
            // Child2에서 method 구현
        }
    
        @Override
        public void additionalMethod() {
            // Child2에서 additionalMethod 재정의
        }
    }
    ```
    

### private 메서드

Java 9 버전부터는 인터페이스에 private 메서드를 정의하는 것도 허용한다.

이전까지는 private 메서드를 선언할 수 없어서 static이나 default 메서드에서의 중복을 줄이기 힘들었다.

```java
public interface Interface {

    default void defaultMethod1() {
        System.out.println("이것은 디폴트 메서드입니다.");
        System.out.println("디폴트 메서드 중에서도 1번입니다.");
    }

    default void defaultMethod2() {
        System.out.println("이것은 디폴트 메서드입니다.");
        System.out.println("디폴트 메서드 중에서도 2번입니다.");
    }
}
```

- 두 개의 default 메서드에서 코드의 중복이 발생한다.
- 이를 줄이기 위해서는 별도의 메서드로 분리할 수 있는데, 인터페이스는 public 메서드만 허용하기 때문에 public 메서드로만 분리해야 한다. 하지만 분리된 내용은 외부에서 사용하는 것이 아니라 오직 인터페이스 내부에 있는 default 메서드에서만 사용하는 것이다.

따라서 이러한 문제를 해결하고자 인터페이스에서도 private 접근 제한자를 허용하도록 변경되었다.

```java
public interface Interface {

    default void defaultMethod1() {
        printDefaultMethod(1);
    }

    default void defaultMethod2() {
        printDefaultMethod(2);
    }

		// 중복 코드는 private 메서드로 분리
    private void printDefaultMethod(int number) {
        System.out.println("이것은 디폴트 메서드입니다.");
        System.out.println("디폴트 메서드 중에서도 " + number + "번입니다.");
    }
}
```

- `printDefaultMethod(int number)` 메서드는 private 접근 제한을 가지므로 인터페이스 내부에서만 사용 가능하다. 따라서, 순수하게 default 메서드들의 코드 중복을 줄이는 목적으로 사용할 수 있다.
- 참고로 private 접근 제한은 default 메서드 뿐만 아니라 static 메서드에도 적용할 수 있다.

---

## 추상 클래스와 인터페이스 비교

|                    | **추상 클래스**                        | **인터페이스**                                                |
| ------------------ | --------------------------------- | -------------------------------------------------------- |
| **키워드**            | `abstract class`                  | `interface`                                              |
| **목적**             | 상위 클래스에서 공통 속성/메서드를 제공하며, 일부만 추상화 | 클래스가 어떤 기능(메서드 집합)을 가져야 하는지에 대한 명세 역할                    |
| **설계 관점**          | “미완성된 클래스”로서 상속 계층 내 공통 구조 제공     | “기능 명세서”로서 다양한 구현체를 하나의 타입으로 다루기 위한 규약 제공                |
| **멤버 구성**          | 필드, 생성자, 추상 메서드, 일반 메서드           | 상수, 추상 메서드, default 메서드,  static 메서드, private 메서드        |
| **변수**             | 일반 변수 선언 가능                       | `public static final`로 취급  (즉, 상수만 가능)                   |
| **메서드**            | 추상 메서드, 일반 메서드 모두 선언 가능           | `public abstract`로 취급  (default, static, private 메서드 제외) |
| **인스턴스 생성**        | 직접 생성 불가                          | 직접 생성 불가                                                 |
| **다형성 지원**         | 가능                                | 가능                                                       |
| **상속(구현)**         | 단일 상속만 가능                         | 다중 구현 가능                                                 |
| **추가 메서드 정의 시 영향** | 하위 클래스가 영향을 받지 않음                 | 기존 구현 클래스가 영향을 받을 수 있으나 default 메서드로 해결 가능               |


---
# 실습

- 상속 실습문제를 추상 클래스, 인터페이스를 활용하여 구현하시오
    
    - 다음을 구현하시오
        
        - 이름, 나이, 소리내기 기능 갖는 Animal 클래스를 구현하시오.( `추상 클래스` 활용)
        - Animal 클래스를 상속받는 Dog 클래스를 작성하시오.
            - 소리내기 기능을 오버라이딩 하시오.
            - 품종 변수를 추가하시오.
        - Animal 클래스를 상속받는 Cat 클래스를 작성하시오.
            - 소리내기 기능을 오버라이딩하시오.
            - 골골대는 기능을 추가하시오. (`인터페이스` 활용)
    - 다음을 구현하시오
        
        - 모델명, 속도, 연료량을 갖는 Vehicle 클래스를 구현하시오.
            - 속도 관련 기능을 구현하시오
            - 최대 연료량은 100입니다
        - Vehicle 클래스를 상속받는 Bus 클래스를 작성하시오.
            - 승객 관련 기능을 추가하시오
            - 최대 연료량은 300입니다
        - Vehicle 클래스를 상속받는 Truck 클래스를 작성하시오.
            - 짐 관련 기능을 추가하시오
            - 최대연료량은 250입니다
        - Vehicle 클래스를 상속받는 Brucks 클래스를 작성하시오.
            - 승객 관련 기능을 추가하시오
            - 짐 관련 기능을 추가하시오
            - 최대 연료량은 1000입니다
    - 다음을 구현하시오
        
        - 이름, 레벨, 체력을 갖는 Character 클래스를 구현하시오
            
            - 레벨은 1부터 시작합니다
            - 기본 공격 기능을 구현하시오 (단순 출력)
            - 레벨업 기능을 구현하시오
        - Character 클래스를 상속받는 Warrior 클래스를 작성하시오
            
            - 분노게이지 관련 기능을 추가하시오 (최대 100)
            - 기본 체력은 120입니다
            - 레벨업 시 체력 30 증가
        - Character 클래스를 상속받는 Mage 클래스를 작성하시오
            
            - 마나 관련 기능을 추가하시오 (최대 100)
            - 기본 체력은 70입니다
            - 레벨업 시 체력 15 증가
        - 추가사항
            
            - 기본 공격 기능을 캐릭터끼리의 상호작용으로 구현하시오.
- 도서관 시스템
    
    - 모든 자료는 제목, ID, 대출 가능 여부를 가짐
    - 모든 자료는 대출/반납이 가능해야 함
    - 전자책은 다운로드도 가능해야 함
    - 책과 DVD는 물리적 위치 정보가 필요함