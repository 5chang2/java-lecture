# 8.3. 실습: 람다와 스트림 활용

## 학습 목표
- 람다 표현식과 스트림 API를 종합적으로 활용한다
- JavaScript 스타일의 함수형 프로그래밍을 Java로 구현한다
- 실전 프로젝트 수준의 데이터 처리를 경험한다

---

## 실습 1: 숫자 리스트 처리 (기본)

### 문제 설명

다음 숫자 리스트를 스트림으로 처리하세요.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
```

### 요구사항

1. 짝수만 필터링하여 리스트 반환
2. 모든 숫자에 2를 곱하여 리스트 반환
3. 숫자들의 합계 계산
4. 5보다 큰 숫자의 개수 계산
5. 모든 숫자가 양수인지 확인

### 예상 출력

```
짝수: [2, 4, 6, 8, 10]
2배: [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
합계: 55
5보다 큰 수의 개수: 5
모두 양수? true
```

<details>
<summary>답안 보기</summary>

```java
import java.util.*;
import java.util.stream.*;

public class NumberListPractice {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // 1. 짝수만 필터링
        List<Integer> evens = numbers.stream()
            .filter(n -> n % 2 == 0)
            .collect(Collectors.toList());
        System.out.println("짝수: " + evens);

        // 2. 모든 숫자에 2를 곱하기
        List<Integer> doubled = numbers.stream()
            .map(n -> n * 2)
            .collect(Collectors.toList());
        System.out.println("2배: " + doubled);

        // 3. 합계
        int sum = numbers.stream()
            .mapToInt(Integer::intValue)
            .sum();
        System.out.println("합계: " + sum);

        // 4. 5보다 큰 숫자의 개수
        long count = numbers.stream()
            .filter(n -> n > 5)
            .count();
        System.out.println("5보다 큰 수의 개수: " + count);

        // 5. 모든 숫자가 양수인지 확인
        boolean allPositive = numbers.stream()
            .allMatch(n -> n > 0);
        System.out.println("모두 양수? " + allPositive);
    }
}
```

</details>

---

## 실습 2: 문자열 리스트 처리 (기본)

### 문제 설명

다음 문자열 리스트를 스트림으로 처리하세요.

```java
List<String> words = Arrays.asList("apple", "banana", "cherry", "date", "elderberry", "fig");
```

### 요구사항

1. 길이가 5 이상인 단어만 필터링
2. 모든 단어를 대문자로 변환
3. 중복 제거 후 알파벳 순 정렬
4. 모든 단어를 쉼표로 연결
5. 'e'로 시작하는 단어 찾기

### 예상 출력

```
길이 5 이상: [apple, banana, cherry, elderberry]
대문자: [APPLE, BANANA, CHERRY, DATE, ELDERBERRY, FIG]
정렬: [apple, banana, cherry, date, elderberry, fig]
연결: apple, banana, cherry, date, elderberry, fig
e로 시작: elderberry
```

<details>
<summary>답안 보기</summary>

```java
import java.util.*;
import java.util.stream.*;

public class StringListPractice {
    public static void main(String[] args) {
        List<String> words = Arrays.asList("apple", "banana", "cherry", "date", "elderberry", "fig");

        // 1. 길이 5 이상
        List<String> longWords = words.stream()
            .filter(w -> w.length() >= 5)
            .collect(Collectors.toList());
        System.out.println("길이 5 이상: " + longWords);

        // 2. 대문자 변환
        List<String> upperWords = words.stream()
            .map(String::toUpperCase)
            .collect(Collectors.toList());
        System.out.println("대문자: " + upperWords);

        // 3. 정렬
        List<String> sorted = words.stream()
            .distinct()
            .sorted()
            .collect(Collectors.toList());
        System.out.println("정렬: " + sorted);

        // 4. 연결
        String joined = words.stream()
            .collect(Collectors.joining(", "));
        System.out.println("연결: " + joined);

        // 5. 'e'로 시작하는 단어
        Optional<String> startsWithE = words.stream()
            .filter(w -> w.startsWith("e"))
            .findFirst();
        startsWithE.ifPresent(w -> System.out.println("e로 시작: " + w));
    }
}
```

</details>

---

## 실습 3: 사용자 관리 시스템 (중급)

### 문제 설명

사용자 관리 시스템을 스트림으로 구현하세요.

### 요구사항

1. `User` 클래스 작성
   - 필드: `name`, `age`, `city`

2. 다음 기능 구현:
   - 20대 사용자만 필터링
   - 도시별 사용자 그룹화
   - 평균 나이 계산
   - 가장 나이 많은 사용자 찾기
   - 사용자 이름을 알파벳 순으로 정렬

### 예상 출력

```
=== 20대 사용자 ===
김철수 (25세, 서울)
박민수 (28세, 부산)

=== 도시별 사용자 ===
서울: 2명
부산: 2명
대구: 1명

=== 통계 ===
평균 나이: 29.2세
최고령: 이영희 (35세)

=== 이름 순 정렬 ===
김철수, 박민수, 이영희, 정수진, 최지원
```

<details>
<summary>답안 보기</summary>

```java
import java.util.*;
import java.util.stream.*;

class User {
    private String name;
    private int age;
    private String city;

    public User(String name, int age, String city) {
        this.name = name;
        this.age = age;
        this.city = city;
    }

    public String getName() { return name; }
    public int getAge() { return age; }
    public String getCity() { return city; }

    @Override
    public String toString() {
        return String.format("%s (%d세, %s)", name, age, city);
    }
}

public class UserManagementSystem {
    public static void main(String[] args) {
        List<User> users = Arrays.asList(
            new User("김철수", 25, "서울"),
            new User("이영희", 35, "서울"),
            new User("박민수", 28, "부산"),
            new User("최지원", 32, "대구"),
            new User("정수진", 26, "부산")
        );

        // 1. 20대 사용자
        System.out.println("=== 20대 사용자 ===");
        users.stream()
            .filter(u -> u.getAge() >= 20 && u.getAge() < 30)
            .forEach(System.out::println);

        // 2. 도시별 그룹화
        System.out.println("\n=== 도시별 사용자 ===");
        Map<String, Long> byCity = users.stream()
            .collect(Collectors.groupingBy(
                User::getCity,
                Collectors.counting()
            ));
        byCity.forEach((city, count) ->
            System.out.println(city + ": " + count + "명")
        );

        // 3. 평균 나이
        double avgAge = users.stream()
            .mapToInt(User::getAge)
            .average()
            .orElse(0.0);
        System.out.printf("\n=== 통계 ===\n평균 나이: %.1f세\n", avgAge);

        // 4. 최고령 사용자
        Optional<User> oldest = users.stream()
            .max(Comparator.comparingInt(User::getAge));
        oldest.ifPresent(u ->
            System.out.printf("최고령: %s (%d세)\n", u.getName(), u.getAge())
        );

        // 5. 이름 순 정렬
        String sortedNames = users.stream()
            .map(User::getName)
            .sorted()
            .collect(Collectors.joining(", "));
        System.out.println("\n=== 이름 순 정렬 ===");
        System.out.println(sortedNames);
    }
}
```

</details>

---

## 실습 4: 주문 처리 시스템 (고급)

### 문제 설명

온라인 쇼핑몰의 주문 처리 시스템을 스트림으로 구현하세요.

### 요구사항

1. `Order` 클래스 작성
   - 필드: `orderId`, `customerName`, `amount`, `status`
   - status: "PENDING", "COMPLETED", "CANCELLED"

2. 다음 기능 구현:
   - 완료된 주문만 필터링
   - 고객별 주문 금액 합계
   - 10만원 이상 주문 찾기
   - 상태별 주문 개수
   - 전체 매출 계산

### 예상 출력

```
=== 완료된 주문 ===
ORD-001: 김철수 (50,000원)
ORD-003: 이영희 (150,000원)
ORD-005: 김철수 (80,000원)

=== 고객별 주문 금액 ===
김철수: 130,000원
이영희: 200,000원
박민수: 30,000원

=== 고액 주문 (10만원 이상) ===
ORD-003: 이영희 (150,000원)

=== 상태별 주문 개수 ===
COMPLETED: 3건
PENDING: 1건
CANCELLED: 1건

=== 전체 매출 ===
총 매출: 360,000원
```

<details>
<summary>답안 보기</summary>

```java
import java.util.*;
import java.util.stream.*;

class Order {
    private String orderId;
    private String customerName;
    private int amount;
    private String status;

    public Order(String orderId, String customerName, int amount, String status) {
        this.orderId = orderId;
        this.customerName = customerName;
        this.amount = amount;
        this.status = status;
    }

    public String getOrderId() { return orderId; }
    public String getCustomerName() { return customerName; }
    public int getAmount() { return amount; }
    public String getStatus() { return status; }

    @Override
    public String toString() {
        return String.format("%s: %s (%,d원)", orderId, customerName, amount);
    }
}

public class OrderProcessingSystem {
    public static void main(String[] args) {
        List<Order> orders = Arrays.asList(
            new Order("ORD-001", "김철수", 50000, "COMPLETED"),
            new Order("ORD-002", "이영희", 50000, "CANCELLED"),
            new Order("ORD-003", "이영희", 150000, "COMPLETED"),
            new Order("ORD-004", "박민수", 30000, "PENDING"),
            new Order("ORD-005", "김철수", 80000, "COMPLETED")
        );

        // 1. 완료된 주문
        System.out.println("=== 완료된 주문 ===");
        orders.stream()
            .filter(o -> o.getStatus().equals("COMPLETED"))
            .forEach(System.out::println);

        // 2. 고객별 주문 금액 합계
        System.out.println("\n=== 고객별 주문 금액 ===");
        Map<String, Integer> byCustomer = orders.stream()
            .collect(Collectors.groupingBy(
                Order::getCustomerName,
                Collectors.summingInt(Order::getAmount)
            ));
        byCustomer.forEach((name, total) ->
            System.out.printf("%s: %,d원\n", name, total)
        );

        // 3. 고액 주문 (10만원 이상)
        System.out.println("\n=== 고액 주문 (10만원 이상) ===");
        orders.stream()
            .filter(o -> o.getAmount() >= 100000)
            .forEach(System.out::println);

        // 4. 상태별 주문 개수
        System.out.println("\n=== 상태별 주문 개수 ===");
        Map<String, Long> byStatus = orders.stream()
            .collect(Collectors.groupingBy(
                Order::getStatus,
                Collectors.counting()
            ));
        byStatus.forEach((status, count) ->
            System.out.println(status + ": " + count + "건")
        );

        // 5. 전체 매출 (완료된 주문만)
        int totalRevenue = orders.stream()
            .filter(o -> o.getStatus().equals("COMPLETED"))
            .mapToInt(Order::getAmount)
            .sum();
        System.out.printf("\n=== 전체 매출 ===\n총 매출: %,d원\n", totalRevenue);
    }
}
```

</details>

---

## 실습 5: 데이터 파이프라인 (심화)

### 문제 설명

복잡한 데이터 변환 파이프라인을 구현하세요.

### 요구사항

1. CSV 형식의 사용자 데이터 처리
   - 입력: `"이름,나이,도시"` 형식의 문자열 리스트
2. 파이프라인 구현:
   - CSV 파싱 → User 객체 변환
   - 유효성 검사 (나이 > 0)
   - 도시별 그룹화
   - 각 도시의 평균 나이 계산
3. 결과를 보기 좋게 출력

### 예상 출력

```
=== 데이터 처리 결과 ===
서울 (평균 30.0세): 2명
부산 (평균 27.0세): 2명
대구 (평균 32.0세): 1명

=== 전체 통계 ===
총 사용자: 5명
전체 평균 나이: 29.2세
```

<details>
<summary>답안 보기</summary>

```java
import java.util.*;
import java.util.stream.*;

class User {
    private String name;
    private int age;
    private String city;

    public User(String name, int age, String city) {
        this.name = name;
        this.age = age;
        this.city = city;
    }

    public String getName() { return name; }
    public int getAge() { return age; }
    public String getCity() { return city; }

    public static User fromCsv(String csv) {
        String[] parts = csv.split(",");
        return new User(
            parts[0].trim(),
            Integer.parseInt(parts[1].trim()),
            parts[2].trim()
        );
    }

    public boolean isValid() {
        return age > 0 && !name.isEmpty() && !city.isEmpty();
    }
}

public class DataPipelinePractice {
    public static void main(String[] args) {
        List<String> csvData = Arrays.asList(
            "김철수,25,서울",
            "이영희,35,서울",
            "박민수,28,부산",
            "최지원,32,대구",
            "정수진,26,부산",
            "Invalid,-1,Unknown"  // 유효하지 않은 데이터
        );

        // 파이프라인: CSV → User → 유효성 검사 → 그룹화
        Map<String, List<User>> usersByCity = csvData.stream()
            .map(User::fromCsv)
            .filter(User::isValid)
            .collect(Collectors.groupingBy(User::getCity));

        // 도시별 통계
        System.out.println("=== 데이터 처리 결과 ===");
        usersByCity.forEach((city, users) -> {
            double avgAge = users.stream()
                .mapToInt(User::getAge)
                .average()
                .orElse(0.0);

            System.out.printf("%s (평균 %.1f세): %d명\n",
                city, avgAge, users.size());
        });

        // 전체 통계
        List<User> allUsers = csvData.stream()
            .map(User::fromCsv)
            .filter(User::isValid)
            .collect(Collectors.toList());

        double overallAvgAge = allUsers.stream()
            .mapToInt(User::getAge)
            .average()
            .orElse(0.0);

        System.out.println("\n=== 전체 통계 ===");
        System.out.println("총 사용자: " + allUsers.size() + "명");
        System.out.printf("전체 평균 나이: %.1f세\n", overallAvgAge);
    }
}
```

</details>

---

## 실습 6: 함수형 유틸리티 라이브러리 (최고급)

### 문제 설명

JavaScript의 Lodash 스타일 유틸리티 함수를 Java로 구현하세요.

### 요구사항

`StreamUtils` 클래스 구현:
- `chunk(List, size)`: 리스트를 지정된 크기로 분할
- `partition(List, predicate)`: 조건에 따라 두 그룹으로 분할
- `unique(List)`: 중복 제거
- `flatten(List<List>)`: 중첩 리스트 평탄화
- `groupBy(List, keyExtractor)`: 그룹화

### 예상 출력

```
=== chunk ===
[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]

=== partition ===
짝수: [2, 4, 6, 8, 10]
홀수: [1, 3, 5, 7, 9]

=== unique ===
[1, 2, 3, 4, 5]

=== flatten ===
[1, 2, 3, 4, 5, 6]

=== groupBy ===
{3=[one, two], 4=[four], 5=[three]}
```

<details>
<summary>답안 보기</summary>

```java
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

class StreamUtils {
    // chunk: 리스트를 지정된 크기로 분할
    public static <T> List<List<T>> chunk(List<T> list, int size) {
        List<List<T>> chunks = new ArrayList<>();
        for (int i = 0; i < list.size(); i += size) {
            chunks.add(list.subList(i, Math.min(i + size, list.size())));
        }
        return chunks;
    }

    // partition: 조건에 따라 두 그룹으로 분할
    public static <T> Map<Boolean, List<T>> partition(
        List<T> list,
        Predicate<T> predicate
    ) {
        return list.stream()
            .collect(Collectors.partitioningBy(predicate));
    }

    // unique: 중복 제거
    public static <T> List<T> unique(List<T> list) {
        return list.stream()
            .distinct()
            .collect(Collectors.toList());
    }

    // flatten: 중첩 리스트 평탄화
    public static <T> List<T> flatten(List<List<T>> nestedList) {
        return nestedList.stream()
            .flatMap(List::stream)
            .collect(Collectors.toList());
    }

    // groupBy: 그룹화
    public static <T, K> Map<K, List<T>> groupBy(
        List<T> list,
        Function<T, K> keyExtractor
    ) {
        return list.stream()
            .collect(Collectors.groupingBy(keyExtractor));
    }
}

public class UtilityLibraryDemo {
    public static void main(String[] args) {
        // chunk
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        List<List<Integer>> chunks = StreamUtils.chunk(numbers, 3);
        System.out.println("=== chunk ===");
        System.out.println(chunks);

        // partition
        Map<Boolean, List<Integer>> partitioned =
            StreamUtils.partition(numbers, n -> n % 2 == 0);
        System.out.println("\n=== partition ===");
        System.out.println("짝수: " + partitioned.get(true));
        System.out.println("홀수: " + partitioned.get(false));

        // unique
        List<Integer> duplicates = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 5, 5);
        List<Integer> unique = StreamUtils.unique(duplicates);
        System.out.println("\n=== unique ===");
        System.out.println(unique);

        // flatten
        List<List<Integer>> nested = Arrays.asList(
            Arrays.asList(1, 2),
            Arrays.asList(3, 4),
            Arrays.asList(5, 6)
        );
        List<Integer> flattened = StreamUtils.flatten(nested);
        System.out.println("\n=== flatten ===");
        System.out.println(flattened);

        // groupBy
        List<String> words = Arrays.asList("one", "two", "three", "four");
        Map<Integer, List<String>> grouped =
            StreamUtils.groupBy(words, String::length);
        System.out.println("\n=== groupBy ===");
        System.out.println(grouped);
    }
}
```

**JavaScript Lodash 비교:**
```javascript
const _ = require('lodash');

const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// chunk
_.chunk(numbers, 3);

// partition
_.partition(numbers, n => n % 2 === 0);

// uniq
_.uniq([1, 2, 2, 3, 3, 3]);

// flatten
_.flatten([[1, 2], [3, 4], [5, 6]]);

// groupBy
_.groupBy(['one', 'two', 'three'], 'length');
```

</details>

---

## 종합 챌린지: 영화 추천 시스템

### 문제 설명

영화 데이터를 분석하여 사용자에게 영화를 추천하는 시스템을 구현하세요.

### 요구사항

1. `Movie` 클래스: title, genre, rating, year
2. 다음 기능 구현:
   - 장르별 영화 그룹화
   - 평점 4.0 이상 영화 필터링
   - 최신 영화 5개 추천 (년도 순)
   - 장르별 평균 평점
   - 가장 인기 있는 장르 찾기

이 챌린지는 스스로 설계하고 구현해보세요!

---

## 정리

### 학습한 내용

1. **람다 표현식**: 간결한 함수 표현
2. **스트림 API**: 선언적 데이터 처리
3. **함수형 프로그래밍**: filter, map, reduce 패턴
4. **실전 활용**: 실무 데이터 처리 시나리오

### JavaScript vs Java 함수형 프로그래밍

| 기능 | JavaScript | Java |
|------|-----------|------|
| 함수형 패러다임 | ✅ 기본 지원 | ⚠️ Java 8+ 지원 |
| 람다/화살표 함수 | `=>` | `->` |
| 배열 메서드 | 기본 제공 | 스트림 API |
| 타입 시스템 | 동적 | 정적 (안전함) |
| 불변성 | ⚠️ 주의 필요 | ✅ 기본 지원 |

### 다음 단계

Modern Java를 마스터했습니다! 이제 **예외 처리**를 학습하여 견고한 애플리케이션을 만들 준비가 되었습니다!

---

**다음 챕터:** [9장. 예외 처리](../09_예외_처리/9.1_예외_Exception란_무엇인가.md)
