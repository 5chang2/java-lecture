# 5.4. 컴포지션

> 컴포지션의 개념을 이해하고, 상속의 한계를 극복하는 방법을 학습합니다.

## 학습 목표
- 컴포지션(Composition)의 개념 이해
- is-a와 has-a 관계 구분
- 상속의 한계와 컴포지션의 장점 이해
- 결합도(Coupling)와 응집도(Cohesion) 개념 학습

---

## 1. 컴포지션(Composition)이란?

### 개념

**컴포지션(Composition)**이란, **하나의 클래스가 다른 클래스의 인스턴스를 멤버 변수로 포함**하는 것입니다.

**다른 이름:**
- 포함(Inclusion)
- 구성(Composition)
- 합성(Aggregation)

**비유:**
- 상속: 부모의 DNA를 물려받음 (계층 관계)
- 컴포지션: 도구를 가방에 넣고 다님 (포함 관계)

### 기본 문법

```java
public class Address {
    private String city;
    private String street;

    public Address(String city, String street) {
        this.city = city;
        this.street = street;
    }

    public String getCity() {
        return city;
    }

    public String getStreet() {
        return street;
    }
}
```

```java
public class Building {
    // 컴포지션: Address 타입의 멤버 변수
    private Address address;

    public Building(Address address) {
        this.address = address;
    }

    public void showAddress() {
        System.out.println("시: " + this.address.getCity());
        System.out.println("도로: " + this.address.getStreet());
    }
}
```

**사용:**

```java
public class Main {
    public static void main(String[] args) {
        Address address = new Address("서울", "강남대로");
        Building building = new Building(address);

        building.showAddress();
    }
}
```

**출력:**
```
시: 서울
도로: 강남대로
```

### JavaScript와의 비교

```javascript
// JavaScript - 컴포지션
class Address {
    constructor(city, street) {
        this.city = city;
        this.street = street;
    }
}

class Building {
    constructor(address) {
        this.address = address;  // 컴포지션
    }

    showAddress() {
        console.log(`시: ${this.address.city}`);
        console.log(`도로: ${this.address.street}`);
    }
}

const address = new Address("서울", "강남대로");
const building = new Building(address);
building.showAddress();
```

---

## 2. 상속 vs 컴포지션

### 상속으로 구현

```java
// Address를 상속
public class Building extends Address {
    public Building(String city, String street) {
        super(city, street);
    }

    public void showAddress() {
        System.out.println("시: " + getCity());
        System.out.println("도로: " + getStreet());
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Building building = new Building("서울", "강남대로");
        building.showAddress();
    }
}
```

**문제점:**
- Building **is-a** Address? → ❌ 어색함
- Building **has-a** Address? → ✅ 자연스러움

**건물은 주소가 아니라, 주소를 가집니다!**

### 컴포지션으로 구현

```java
// Address를 포함
public class Building {
    private Address address;  // 컴포지션

    public Building(Address address) {
        this.address = address;
    }

    public void showAddress() {
        System.out.println("시: " + this.address.getCity());
        System.out.println("도로: " + this.address.getStreet());
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Address address = new Address("서울", "강남대로");
        Building building = new Building(address);
        building.showAddress();
    }
}
```

**개선점:**
- Building **has-a** Address → 자연스러운 관계
- 의미가 명확함

---

## 3. is-a vs has-a 관계

### is-a 관계 (상속)

**"~은 ~이다"** 로 표현되는 관계입니다.

**예시:**
- 삼각형 **is-a** 도형 ✅
- 사각형 **is-a** 도형 ✅
- 개 **is-a** 동물 ✅
- 학생 **is-a** 사람 ✅

```java
// is-a 관계 - 상속 사용
public abstract class Shape {
    public abstract int calculateArea();
}

public class Triangle extends Shape {
    @Override
    public int calculateArea() {
        return (width * height) / 2;
    }
}

public class Rectangle extends Shape {
    @Override
    public int calculateArea() {
        return width * height;
    }
}
```

### has-a 관계 (컴포지션)

**"~은 ~를 가진다"** 로 표현되는 관계입니다.

**예시:**
- 건물 **has-a** 주소 ✅
- 자동차 **has-a** 엔진 ✅
- 사람 **has-a** 휴대폰 ✅
- 컴퓨터 **has-a** CPU ✅

```java
// has-a 관계 - 컴포지션 사용
public class Engine {
    private int horsePower;

    public Engine(int horsePower) {
        this.horsePower = horsePower;
    }

    public void start() {
        System.out.println("엔진 시동: " + horsePower + "마력");
    }
}

public class Car {
    private Engine engine;  // has-a 관계

    public Car(Engine engine) {
        this.engine = engine;
    }

    public void startCar() {
        engine.start();
        System.out.println("자동차 출발!");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Engine engine = new Engine(200);
        Car car = new Car(engine);
        car.startCar();
    }
}
```

**출력:**
```
엔진 시동: 200마력
자동차 출발!
```

### 관계 판단 가이드

| 질문 | 답변 | 사용 |
|------|------|------|
| X는 Y의 한 종류인가? | Yes | 상속 (is-a) |
| X는 Y를 포함하는가? | Yes | 컴포지션 (has-a) |

**예시:**
- 강아지는 동물의 한 종류? → Yes → 상속
- 자동차는 엔진의 한 종류? → No → 컴포지션
- 자동차는 엔진을 포함? → Yes → 컴포지션

---

## 4. 상속의 한계 1: 높은 결합도

### 결합도(Coupling)란?

**결합도**는 하나의 클래스가 다른 클래스에 대해 **얼마나 알고 있는가**를 나타냅니다.

**좋은 설계:**
- ✅ 낮은 결합도 (Loose Coupling)
- 클래스 간 독립적
- 한 클래스 수정 시 다른 클래스 영향 최소화

### 상속의 높은 결합도 문제

```java
public class Address {
    private String city;
    private String street;

    public Address(String city, String street) {
        this.city = city;
        this.street = street;
    }
}
```

```java
public class Building extends Address {
    public Building(String city, String street) {
        super(city, street);  // 부모 생성자 의존
    }
}
```

**Address 수정 시:**

```java
public class Address {
    private String city;
    private String street;
    private String postCode;  // ⭐ 필드 추가

    public Address(String city, String street, String postCode) {
        this.city = city;
        this.street = street;
        this.postCode = postCode;
    }
}
```

**결과:**
```java
public class Building extends Address {
    public Building(String city, String street) {
        super(city, street);  // ❌ 컴파일 에러!
    }
}
```

**에러 메시지:**
```
Constructor 'Address(String, String)' does not exist
```

**강제 수정:**

```java
public class Building extends Address {
    public Building(String city, String street, String postCode) {
        super(city, street, postCode);  // 수정 필요
    }
}
```

**문제점:**
- Address 수정 → Building도 수정 필요
- 높은 결합도로 인한 연쇄 수정

### 컴포지션으로 해결

```java
public class Building {
    private Address address;  // 인스턴스만 참조

    public Building(Address address) {
        this.address = address;
    }
}
```

**Address 수정 후:**

```java
public class Main {
    public static void main(String[] args) {
        // Address 생성 방식만 변경
        Address address = new Address("서울", "강남대로", "06000");
        Building building = new Building(address);  // ✅ 수정 불필요!
    }
}
```

**장점:**
- Address 내부 변경이 Building에 영향 없음
- 낮은 결합도 유지

---

## 5. 상속의 한계 2: 다중 상속 불가

### 문제 상황

**요구사항:**
- Building은 주소(Address) 정보가 필요
- Building은 주인(Owner) 정보도 필요

```java
public class Address {
    private String city;
    private String street;

    public Address(String city, String street) {
        this.city = city;
        this.street = street;
    }
}

public class Owner {
    private String name;
    private int age;

    public Owner(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

**다중 상속 시도:**

```java
// ❌ 컴파일 에러!
public class Building extends Address, Owner {
}
```

**에러 메시지:**
```
Class cannot extend multiple classes
```

### 잘못된 해결: 연쇄 상속

```java
public class Address {
    private String city;
    private String street;
}

public class Owner extends Address {
    private String name;
    private int age;
}

public class Building extends Owner {
}
```

**문제점:**
- Owner **is-a** Address? → ❌ 의미 없음
- Address 수정 → Owner 수정 → Building 수정 (연쇄 수정)
- 극도로 높은 결합도

### 컴포지션으로 해결

```java
public class Building {
    private Address address;  // has-a
    private Owner owner;      // has-a

    public Building(Address address, Owner owner) {
        this.address = address;
        this.owner = owner;
    }

    public void showInfo() {
        System.out.println("주소: " + address.getCity());
        System.out.println("주인: " + owner.getName());
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Address address = new Address("서울", "강남대로");
        Owner owner = new Owner("홍길동", 35);

        Building building = new Building(address, owner);
        building.showInfo();
    }
}
```

**장점:**
- 다중 포함 가능 (마치 다중 상속처럼)
- 낮은 결합도 유지
- 의미가 명확함

---

## 6. 언제 상속을 사용할까?

### 상속이 적절한 경우

**1. 명확한 is-a 관계**

```java
public abstract class Animal {
    public abstract void makeSound();
}

public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("멍멍!");
    }
}
```

**2. 다형성 활용**

```java
public class Main {
    public static void main(String[] args) {
        Animal[] animals = {
            new Dog(),
            new Cat(),
            new Cow()
        };

        for (Animal animal : animals) {
            animal.makeSound();  // 다형성
        }
    }
}
```

**3. 템플릿 메서드 패턴**

```java
public abstract class GameCharacter {
    // 템플릿 메서드
    public final void attack() {
        prepareAttack();
        executeAttack();  // 추상 메서드
        finishAttack();
    }

    protected void prepareAttack() {
        System.out.println("공격 준비");
    }

    protected abstract void executeAttack();

    protected void finishAttack() {
        System.out.println("공격 완료");
    }
}

public class Warrior extends GameCharacter {
    @Override
    protected void executeAttack() {
        System.out.println("칼로 베기!");
    }
}
```

### 컴포지션이 적절한 경우

**1. has-a 관계**

```java
public class Person {
    private Phone phone;  // has-a
    private Address address;  // has-a
}
```

**2. 기능 조합**

```java
public class SmartPhone {
    private Camera camera;
    private GPS gps;
    private MP3Player mp3Player;

    public void takePhoto() {
        camera.capture();
    }

    public void navigate() {
        gps.getLocation();
    }

    public void playMusic() {
        mp3Player.play();
    }
}
```

**3. 런타임 동작 변경**

```java
public class Robot {
    private Weapon weapon;

    public void setWeapon(Weapon weapon) {
        this.weapon = weapon;  // 런타임에 무기 교체
    }

    public void attack() {
        if (weapon != null) {
            weapon.fire();
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Robot robot = new Robot();

        robot.setWeapon(new Gun());
        robot.attack();  // 총 발사

        robot.setWeapon(new Laser());
        robot.attack();  // 레이저 발사
    }
}
```

---

## 7. 실습 문제

### 문제 1: 사람과 연필

**요구사항:**
- `Pencil` 클래스: 색상(color), 쓰기(write) 기능
- `Person` 클래스: 이름(name), Pencil을 멤버 변수로 포함
- `Person`의 `doWrite()` 메서드: 연필로 쓰기

**테스트 코드:**
```java
public class Main {
    public static void main(String[] args) {
        Pencil pencil = new Pencil("빨강");
        Person person = new Person("홍길동", pencil);

        person.doWrite("안녕하세요");
    }
}
```

**예상 출력:**
```
홍길동이(가) 빨강 연필로 '안녕하세요'를 씁니다.
```

### 문제 2: 자동차와 엔진

**요구사항:**
- `Engine` 클래스:
  - 필드: horsePower (마력)
  - 메서드: `start()`, `stop()`
- `Car` 클래스:
  - 필드: model (모델명), engine (Engine), speed (속도)
  - 메서드:
    - `startCar()`: 엔진 시동, "자동차 시작" 출력
    - `accelerate()`: 엔진 마력에 따라 속도 증가
    - `showStatus()`: 모델명, 마력, 현재 속도 출력

**테스트 코드:**
```java
public class Main {
    public static void main(String[] args) {
        Engine engine = new Engine(200);
        Car car = new Car("Sonata", engine);

        car.startCar();
        car.accelerate();
        car.accelerate();
        car.showStatus();
    }
}
```

**예상 출력:**
```
엔진 시동 (200마력)
자동차 시작
가속 (속도 +20)
가속 (속도 +20)
[Sonata] 마력: 200, 속도: 40km/h
```

### 문제 3: 캐릭터와 무기

**요구사항:**
- `Weapon` 인터페이스:
  - `attack()`: 공격
  - `getDamage()`: 공격력 반환
- `Gun`, `Sword` 클래스: Weapon 구현
  - Gun: 데미지 30, "총 발사!" 출력
  - Sword: 데미지 20, "칼로 베기!" 출력
- `Character` 클래스:
  - 필드: name, health, weapon
  - 메서드:
    - `equipWeapon(Weapon weapon)`: 무기 장착
    - `attack()`: 무기로 공격 (무기 없으면 "맨손 공격!")
    - `takeDamage(int damage)`: 데미지 받기

**테스트 코드:**
```java
public class Main {
    public static void main(String[] args) {
        Character player = new Character("전사", 100);

        player.attack();  // 맨손

        player.equipWeapon(new Sword());
        player.attack();  // 칼 공격

        player.equipWeapon(new Gun());
        player.attack();  // 총 공격
    }
}
```

**예상 출력:**
```
전사: 맨손 공격! (데미지: 5)
전사: 칼로 베기! (데미지: 20)
전사: 총 발사! (데미지: 30)
```

### 문제 4: 컴퓨터 조립

**요구사항:**
- `CPU`, `RAM`, `Storage` 클래스 작성
- `Computer` 클래스: 위 3개를 컴포지션으로 포함
- `printSpecs()` 메서드: 모든 부품 정보 출력

**테스트 코드:**
```java
public class Main {
    public static void main(String[] args) {
        CPU cpu = new CPU("Intel i7", 3.5);
        RAM ram = new RAM("Samsung", 16);
        Storage storage = new Storage("SSD", 512);

        Computer computer = new Computer(cpu, ram, storage);
        computer.printSpecs();
    }
}
```

---

## 요약

| 개념 | 설명 |
|------|------|
| **컴포지션** | 다른 클래스의 인스턴스를 멤버로 포함 |
| **is-a 관계** | "~은 ~이다" → 상속 사용 |
| **has-a 관계** | "~은 ~를 가진다" → 컴포지션 사용 |
| **결합도** | 클래스 간 의존 정도 (낮을수록 좋음) |
| **응집도** | 클래스 내 요소의 관련성 (높을수록 좋음) |

**상속 vs 컴포지션:**

| 구분 | 상속 | 컴포지션 |
|------|------|----------|
| **관계** | is-a | has-a |
| **결합도** | 높음 | 낮음 |
| **유연성** | 컴파일 타임 고정 | 런타임 변경 가능 |
| **다중성** | 단일 상속만 | 다중 포함 가능 |

**설계 원칙:**
- ✅ "상속보다는 컴포지션을 선호하라" (Effective Java)
- ✅ 명확한 is-a 관계에만 상속 사용
- ✅ 기능 조합은 컴포지션 사용

**다음 학습:**
- 5.5장에서 실습을 통해 OOP 개념 종합 정리
