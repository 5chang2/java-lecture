# 7.4. 어노테이션 소개

## 학습 목표
- 어노테이션(Annotation)의 개념과 역할을 이해한다
- JavaScript 데코레이터와의 차이점을 비교한다
- 주요 표준 어노테이션의 사용법을 익힌다
- 메타 어노테이션의 역할을 이해한다

---

## 1. 어노테이션이란?

### 1.1. 개념

**어노테이션(Annotation)**은 Java 코드에 메타데이터를 제공하는 특수한 형태의 주석입니다.

```java
@Override
public void show() {
    System.out.println("재정의된 메서드입니다.");
}
```

**주요 특징:**
- `@` 기호로 시작
- 코드의 실행 로직에는 직접적인 영향을 주지 않음
- 컴파일러, 런타임 환경, 개발 도구에게 추가 정보 제공

**어노테이션의 주요 목적:**

1. **컴파일러에게 정보 제공**
   - 컴파일 시 경고/에러 체크
   - 코드 검증

2. **컴파일 시점에 코드 생성/처리**
   - 소스 코드 자동 생성
   - XML, JSON 등 설정 파일 생성

3. **런타임 시점에 특정 기능 실행**
   - 리플렉션을 통한 동적 처리
   - 프레임워크/라이브러리에서 활용

---

### 1.2. JavaScript와 비교

#### JavaScript의 주석

```javascript
// 일반 주석 - 아무 기능 없음
function calculate() {
    // 계산 로직
}

/**
 * JSDoc 주석 - 문서화용
 * @param {number} x
 * @param {number} y
 * @returns {number}
 */
function add(x, y) {
    return x + y;
}
```

#### TypeScript의 데코레이터

```typescript
// 데코레이터 - 실험적 기능 (experimentalDecorators 필요)
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = function(...args: any[]) {
        console.log(`Calling ${propertyKey} with args:`, args);
        return originalMethod.apply(this, args);
    };
}

class Calculator {
    @log  // 데코레이터 적용
    add(x: number, y: number): number {
        return x + y;
    }
}

const calc = new Calculator();
calc.add(5, 3);  // Calling add with args: [5, 3]
```

#### Java의 어노테이션

```java
public class Parent {
    public void show() {
        System.out.println("Parent");
    }
}

public class Child extends Parent {
    @Override  // 컴파일러에게 오버라이드 확인 요청
    public void show() {
        System.out.println("Child");
    }
}
```

**비교 정리:**

| 특성 | JavaScript 주석 | TypeScript 데코레이터 | Java 어노테이션 |
|------|---------------|-------------------|--------------|
| 문법 | `//`, `/* */` | `@decorator` | `@Annotation` |
| 컴파일 시 검증 | ❌ 없음 | ⚠️ 일부 | ✅ 완전 지원 |
| 런타임 활용 | ❌ 불가능 | ✅ 가능 | ✅ 가능 |
| 표준 지원 | ✅ 완전 | ⚠️ 실험적 | ✅ 완전 |
| 메타데이터 | ❌ 없음 | ✅ 있음 | ✅ 있음 |
| 주 사용처 | 문서화 | 로깅, AOP | 검증, 설정, 처리 |

---

## 2. 표준 어노테이션

Java에서 기본적으로 제공하는 어노테이션들입니다.

### 2.1. @Override

**역할:** 메서드가 부모 클래스 또는 인터페이스의 메서드를 올바르게 재정의했는지 컴파일러가 확인합니다.

```java
public class Animal {
    public void makeSound() {
        System.out.println("동물 소리");
    }
}

public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("멍멍!");
    }

    // ❌ 컴파일 에러 - 부모에 없는 메서드
    // @Override
    // public void makeSounds() {  // 오타!
    //     System.out.println("멍멍!");
    // }
}
```

**장점:**
- 오타로 인한 실수 방지
- 부모 클래스 메서드 시그니처 변경 시 즉시 감지
- 코드 가독성 향상

**JavaScript 비교:**

```javascript
class Animal {
    makeSound() {
        console.log("동물 소리");
    }
}

class Dog extends Animal {
    makeSound() {  // 오버라이드
        console.log("멍멍!");
    }

    makeSounds() {  // 오타지만 에러 발생 안함!
        console.log("멍멍!");
    }
}
```

---

### 2.2. @Deprecated

**역할:** 해당 요소가 더 이상 사용되지 않음을 표시하고, 컴파일 시 경고를 출력합니다.

```java
public class Calculator {
    /**
     * @deprecated add() 메서드를 대신 사용하세요.
     */
    @Deprecated
    public int sum(int a, int b) {
        return a + b;
    }

    public int add(int a, int b) {
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        Calculator calc = new Calculator();

        // 경고: 'sum(int,int)' is deprecated
        int result = calc.sum(5, 3);

        // 권장 방법
        int result2 = calc.add(5, 3);
    }
}
```

**Java 9 이후 추가 속성:**

```java
public class LegacyCode {
    @Deprecated(since = "1.5", forRemoval = true)
    public void oldMethod() {
        System.out.println("이 메서드는 곧 제거될 예정입니다.");
    }
}
```

- `since`: 언제부터 deprecated 되었는지 명시
- `forRemoval`: 향후 버전에서 제거 예정 여부

---

### 2.3. @SuppressWarnings

**역할:** 컴파일러의 특정 경고를 무시하도록 지시합니다.

```java
public class WarningExample {
    @SuppressWarnings("unused")
    public void method1() {
        int unusedVariable = 10;  // 경고 발생 안함
    }

    @SuppressWarnings("deprecation")
    public void method2() {
        Calculator calc = new Calculator();
        calc.sum(5, 3);  // deprecated 경고 무시
    }

    @SuppressWarnings({"unchecked", "rawtypes"})
    public void method3() {
        List list = new ArrayList();  // 제네릭 경고 무시
        list.add("test");
    }

    @SuppressWarnings("all")
    public void method4() {
        // 모든 경고 무시
    }
}
```

**주요 경고 타입:**
- `"unused"`: 사용되지 않는 변수/메서드
- `"deprecation"`: deprecated된 요소 사용
- `"unchecked"`: 제네릭 타입 체크 경고
- `"rawtypes"`: 제네릭 타입 미지정
- `"all"`: 모든 경고

⚠️ **주의:** 경고를 무시하기보다는 코드를 수정하는 것이 권장됩니다.

---

### 2.4. @FunctionalInterface

**역할:** 인터페이스가 함수형 인터페이스임을 명시하고, 정확히 하나의 추상 메서드만 가지는지 검증합니다.

```java
@FunctionalInterface
public interface Calculator {
    int calculate(int x, int y);  // 단 하나의 추상 메서드

    // default 메서드와 static 메서드는 여러 개 가능
    default void printResult(int result) {
        System.out.println("결과: " + result);
    }

    static void info() {
        System.out.println("계산기 인터페이스");
    }

    // ❌ 컴파일 에러 - 추상 메서드가 2개
    // int subtract(int x, int y);
}
```

**사용 예:**

```java
public class Main {
    public static void main(String[] args) {
        // 람다 표현식으로 구현
        Calculator add = (x, y) -> x + y;
        Calculator multiply = (x, y) -> x * y;

        System.out.println(add.calculate(5, 3));       // 8
        System.out.println(multiply.calculate(5, 3));  // 15
    }
}
```

**JavaScript 비교:**

```javascript
// JavaScript는 함수를 일급 객체로 취급
const add = (x, y) => x + y;
const multiply = (x, y) => x * y;

console.log(add(5, 3));       // 8
console.log(multiply(5, 3));  // 15

// TypeScript 함수 타입
type Calculator = (x: number, y: number) => number;

const add: Calculator = (x, y) => x + y;
```

---

### 2.5. @SafeVarargs

**역할:** 제네릭 가변 인수에서 발생하는 힙 오염 경고를 제거합니다.

```java
public class VarargsExample {
    // 경고 발생: Possible heap pollution from parameterized vararg type
    public static <T> void printAll(T... elements) {
        for (T element : elements) {
            System.out.println(element);
        }
    }

    // @SafeVarargs로 경고 제거
    @SafeVarargs
    public static <T> void printAllSafe(T... elements) {
        for (T element : elements) {
            System.out.println(element);
        }
    }

    public static void main(String[] args) {
        printAllSafe(1, 2, 3, 4, 5);
        printAllSafe("A", "B", "C");
    }
}
```

⚠️ **주의:** final이나 static 메서드에만 사용 가능합니다.

---

## 3. 메타 어노테이션

**메타 어노테이션**은 어노테이션을 위한 어노테이션입니다. 커스텀 어노테이션을 만들 때 사용합니다.

### 3.1. @Target

**역할:** 어노테이션이 적용될 수 있는 위치를 제한합니다.

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

// 메서드에만 적용 가능
@Target(ElementType.METHOD)
public @interface Test {
}

// 클래스와 인터페이스에만 적용 가능
@Target({ElementType.TYPE})
public @interface Entity {
}

// 필드에만 적용 가능
@Target(ElementType.FIELD)
public @interface Column {
}
```

**주요 ElementType 값:**

| ElementType | 적용 대상 |
|------------|---------|
| `TYPE` | 클래스, 인터페이스, Enum |
| `FIELD` | 필드 (멤버 변수) |
| `METHOD` | 메서드 |
| `PARAMETER` | 메서드 매개변수 |
| `CONSTRUCTOR` | 생성자 |
| `LOCAL_VARIABLE` | 지역 변수 |
| `ANNOTATION_TYPE` | 어노테이션 타입 |
| `PACKAGE` | 패키지 |

**사용 예:**

```java
@Target(ElementType.METHOD)
public @interface Test {
}

public class TestClass {
    @Test  // ✅ OK - 메서드에 적용
    public void testMethod() {
    }

    // @Test  // ❌ 컴파일 에러 - 필드에는 적용 불가
    // private int value;
}
```

---

### 3.2. @Retention

**역할:** 어노테이션이 유지되는 기간(라이프사이클)을 정의합니다.

```java
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

// 소스 코드에만 존재 (컴파일 후 제거)
@Retention(RetentionPolicy.SOURCE)
public @interface SourceAnnotation {
}

// 클래스 파일까지 유지 (런타임에는 사용 불가)
@Retention(RetentionPolicy.CLASS)
public @interface ClassAnnotation {
}

// 런타임까지 유지 (리플렉션으로 읽기 가능)
@Retention(RetentionPolicy.RUNTIME)
public @interface RuntimeAnnotation {
}
```

**RetentionPolicy 종류:**

| 정책 | 유지 범위 | 사용 예 |
|------|----------|---------|
| `SOURCE` | 소스 코드에만 | `@Override`, `@SuppressWarnings` |
| `CLASS` | 클래스 파일까지 (기본값) | 컴파일 시점 처리 |
| `RUNTIME` | 런타임까지 | Spring, JUnit 등 프레임워크 |

**런타임 리플렉션 예:**

```java
import java.lang.annotation.*;
import java.lang.reflect.Method;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Info {
    String author();
    String date();
}

public class MyClass {
    @Info(author = "홍길동", date = "2024-01-15")
    public void myMethod() {
        System.out.println("메서드 실행");
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        Method method = MyClass.class.getMethod("myMethod");

        if (method.isAnnotationPresent(Info.class)) {
            Info info = method.getAnnotation(Info.class);
            System.out.println("작성자: " + info.author());
            System.out.println("날짜: " + info.date());
        }
    }
}
```

**출력:**
```
작성자: 홍길동
날짜: 2024-01-15
```

---

### 3.3. @Documented

**역할:** 어노테이션 정보를 Javadoc에 포함시킵니다.

```java
import java.lang.annotation.Documented;

@Documented
public @interface Important {
    String value();
}

/**
 * 중요한 클래스입니다.
 */
@Important("핵심 비즈니스 로직")
public class ImportantClass {
}
```

`javadoc` 생성 시 `@Important` 어노테이션 정보도 문서에 포함됩니다.

---

### 3.4. @Inherited

**역할:** 어노테이션이 자식 클래스에 상속될 수 있도록 합니다.

```java
import java.lang.annotation.*;

@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface InheritedAnnotation {
}

@InheritedAnnotation
public class Parent {
}

// Child 클래스도 @InheritedAnnotation을 가지게 됨
public class Child extends Parent {
}

public class Main {
    public static void main(String[] args) {
        // Parent 확인
        System.out.println("Parent has annotation: " +
            Parent.class.isAnnotationPresent(InheritedAnnotation.class));  // true

        // Child도 상속받음
        System.out.println("Child has annotation: " +
            Child.class.isAnnotationPresent(InheritedAnnotation.class));   // true
    }
}
```

⚠️ **주의:** 클래스 상속에만 적용되며, 인터페이스 구현에는 적용되지 않습니다.

---

### 3.5. @Repeatable

**역할:** 같은 어노테이션을 여러 번 적용할 수 있도록 합니다 (Java 8+).

```java
import java.lang.annotation.*;

// 반복 가능한 어노테이션
@Repeatable(Schedules.class)
@Retention(RetentionPolicy.RUNTIME)
public @interface Schedule {
    String day();
    String time();
}

// 컨테이너 어노테이션
@Retention(RetentionPolicy.RUNTIME)
public @interface Schedules {
    Schedule[] value();
}

// 사용 예
@Schedule(day = "월", time = "09:00")
@Schedule(day = "수", time = "14:00")
@Schedule(day = "금", time = "16:00")
public class Meeting {
}

public class Main {
    public static void main(String[] args) {
        Schedule[] schedules = Meeting.class.getAnnotationsByType(Schedule.class);

        System.out.println("회의 일정:");
        for (Schedule schedule : schedules) {
            System.out.printf("%s요일 %s\n", schedule.day(), schedule.time());
        }
    }
}
```

**출력:**
```
회의 일정:
월요일 09:00
수요일 14:00
금요일 16:00
```

---

## 4. 어노테이션 요소 (Element)

어노테이션에 값을 저장할 수 있습니다.

### 4.1. 기본 문법

```java
public @interface MyAnnotation {
    String value();           // 요소 선언
    int count() default 1;    // 기본값 지정
    String[] tags() default {}; // 배열 타입
}

// 사용
@MyAnnotation(value = "테스트", count = 5, tags = {"tag1", "tag2"})
public class Test1 {
}

// value만 사용할 때는 이름 생략 가능
@MyAnnotation("테스트")
public class Test2 {
}

// 기본값이 있는 요소는 생략 가능
@MyAnnotation(value = "테스트")
public class Test3 {
}
```

### 4.2. 요소 타입 제한

어노테이션 요소로 사용 가능한 타입:
- 기본 타입 (int, double, boolean 등)
- String
- Enum
- Class
- 다른 어노테이션
- 위 타입들의 배열

```java
public enum Priority {
    LOW, MEDIUM, HIGH
}

public @interface Task {
    String name();
    Priority priority();
    Class<?> assignee();
    String[] tags();
}

// 사용
@Task(
    name = "버그 수정",
    priority = Priority.HIGH,
    assignee = Developer.class,
    tags = {"버그", "긴급"}
)
public class BugFixTask {
}
```

---

## 5. 실전 예제 - 간단한 테스트 프레임워크

어노테이션을 활용하여 간단한 테스트 프레임워크를 만들어봅시다.

### 5.1. 어노테이션 정의

```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Test {
    String description() default "";
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface BeforeEach {
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface AfterEach {
}
```

### 5.2. 테스트 클래스 작성

```java
public class CalculatorTest {
    private Calculator calculator;

    @BeforeEach
    public void setup() {
        calculator = new Calculator();
        System.out.println("테스트 준비 완료");
    }

    @Test(description = "덧셈 테스트")
    public void testAdd() {
        int result = calculator.add(5, 3);
        if (result == 8) {
            System.out.println("✅ 덧셈 테스트 성공");
        } else {
            System.out.println("❌ 덧셈 테스트 실패");
        }
    }

    @Test(description = "뺄셈 테스트")
    public void testSubtract() {
        int result = calculator.subtract(5, 3);
        if (result == 2) {
            System.out.println("✅ 뺄셈 테스트 성공");
        } else {
            System.out.println("❌ 뺄셈 테스트 실패");
        }
    }

    @AfterEach
    public void cleanup() {
        calculator = null;
        System.out.println("테스트 정리 완료");
        System.out.println();
    }
}

class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public int subtract(int a, int b) {
        return a - b;
    }
}
```

### 5.3. 테스트 실행기 (리플렉션 활용)

```java
import java.lang.reflect.Method;

public class TestRunner {
    public static void runTests(Class<?> testClass) throws Exception {
        Object testInstance = testClass.getDeclaredConstructor().newInstance();

        Method[] methods = testClass.getDeclaredMethods();

        // @Test 어노테이션이 있는 메서드 찾기
        for (Method method : methods) {
            if (method.isAnnotationPresent(Test.class)) {
                Test testAnnotation = method.getAnnotation(Test.class);

                System.out.println("=== " + testAnnotation.description() + " ===");

                // @BeforeEach 실행
                runMethodsWithAnnotation(testInstance, methods, BeforeEach.class);

                // 테스트 메서드 실행
                method.invoke(testInstance);

                // @AfterEach 실행
                runMethodsWithAnnotation(testInstance, methods, AfterEach.class);
            }
        }
    }

    private static void runMethodsWithAnnotation(
        Object instance,
        Method[] methods,
        Class<? extends java.lang.annotation.Annotation> annotationClass
    ) throws Exception {
        for (Method method : methods) {
            if (method.isAnnotationPresent(annotationClass)) {
                method.invoke(instance);
            }
        }
    }

    public static void main(String[] args) throws Exception {
        runTests(CalculatorTest.class);
    }
}
```

**출력:**
```
=== 덧셈 테스트 ===
테스트 준비 완료
✅ 덧셈 테스트 성공
테스트 정리 완료

=== 뺄셈 테스트 ===
테스트 준비 완료
✅ 뺄셈 테스트 성공
테스트 정리 완료
```

---

## 6. 실전 활용 사례

### 6.1. Spring Framework

```java
// 컴포넌트 등록
@Component
public class MyService {
}

// 의존성 주입
@Service
public class UserService {
    @Autowired
    private UserRepository repository;
}

// 웹 컨트롤러
@RestController
@RequestMapping("/api/users")
public class UserController {
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
}
```

### 6.2. JUnit 테스트

```java
public class UserServiceTest {
    @BeforeEach
    void setup() {
        // 테스트 준비
    }

    @Test
    @DisplayName("사용자 조회 테스트")
    void testFindUser() {
        // 테스트 로직
    }

    @AfterEach
    void cleanup() {
        // 정리
    }
}
```

### 6.3. JPA (데이터베이스)

```java
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String email;

    @OneToMany(mappedBy = "user")
    private List<Order> orders;
}
```

---

## 7. 연습 문제

### 문제 1: @Deprecated 실습

다음 클래스에 적절한 `@Deprecated` 어노테이션을 추가하세요.

```java
public class StringUtils {
    // 구 버전 메서드 (2.0에서 제거 예정)
    public static boolean isEmpty(String str) {
        return str == null || str.length() == 0;
    }

    // 신 버전 메서드
    public static boolean isBlank(String str) {
        return str == null || str.trim().length() == 0;
    }
}
```

<details>
<summary>답안 보기</summary>

```java
public class StringUtils {
    /**
     * @deprecated isBlank() 메서드를 사용하세요.
     */
    @Deprecated(since = "1.5", forRemoval = true)
    public static boolean isEmpty(String str) {
        return str == null || str.length() == 0;
    }

    public static boolean isBlank(String str) {
        return str == null || str.trim().length() == 0;
    }
}
```

</details>

---

### 문제 2: 커스텀 어노테이션 만들기

다음 요구사항을 만족하는 `@Author` 어노테이션을 작성하세요.

**요구사항:**
- 클래스와 메서드에 적용 가능
- 런타임에 읽을 수 있어야 함
- `name`(작성자 이름)과 `date`(작성 날짜) 요소 포함
- Javadoc에 포함되어야 함

<details>
<summary>답안 보기</summary>

```java
import java.lang.annotation.*;

@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Author {
    String name();
    String date();
}

// 사용 예
@Author(name = "홍길동", date = "2024-01-15")
public class MyClass {
    @Author(name = "김철수", date = "2024-01-20")
    public void myMethod() {
    }
}
```

</details>

---

### 문제 3: 검증 어노테이션 (종합)

다음 요구사항을 만족하는 `@NotNull` 어노테이션을 만들고, 이를 검증하는 Validator 클래스를 작성하세요.

**요구사항:**
- 필드에만 적용 가능
- 런타임에 읽을 수 있어야 함
- 필드 값이 null이면 예외 발생

<details>
<summary>답안 보기</summary>

```java
import java.lang.annotation.*;
import java.lang.reflect.Field;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface NotNull {
    String message() default "null이 될 수 없습니다.";
}

// 검증 클래스
class Validator {
    public static void validate(Object obj) throws Exception {
        Class<?> clazz = obj.getClass();
        Field[] fields = clazz.getDeclaredFields();

        for (Field field : fields) {
            if (field.isAnnotationPresent(NotNull.class)) {
                field.setAccessible(true);
                Object value = field.get(obj);

                if (value == null) {
                    NotNull annotation = field.getAnnotation(NotNull.class);
                    throw new IllegalArgumentException(
                        field.getName() + ": " + annotation.message()
                    );
                }
            }
        }
        System.out.println("검증 성공!");
    }
}

// 사용 예
class User {
    @NotNull(message = "이름은 필수입니다.")
    private String name;

    @NotNull(message = "이메일은 필수입니다.")
    private String email;

    private String phone;  // @NotNull 없음 - null 허용

    public User(String name, String email, String phone) {
        this.name = name;
        this.email = email;
        this.phone = phone;
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        // 정상 케이스
        User user1 = new User("홍길동", "hong@example.com", null);
        Validator.validate(user1);  // 검증 성공!

        // 예외 발생 케이스
        try {
            User user2 = new User(null, "hong@example.com", null);
            Validator.validate(user2);
        } catch (IllegalArgumentException e) {
            System.out.println("에러: " + e.getMessage());
            // 에러: name: 이름은 필수입니다.
        }
    }
}
```

</details>

---

## 8. 정리

### 핵심 개념

1. **어노테이션은 메타데이터**
   - 코드에 정보를 추가하는 특수한 주석
   - 컴파일러, 런타임, 도구가 활용

2. **표준 어노테이션**
   - `@Override`: 메서드 재정의 검증
   - `@Deprecated`: 사용 중단 표시
   - `@SuppressWarnings`: 경고 무시
   - `@FunctionalInterface`: 함수형 인터페이스 검증

3. **메타 어노테이션**
   - `@Target`: 적용 위치 제한
   - `@Retention`: 유지 기간 설정
   - `@Documented`: 문서화 포함
   - `@Inherited`: 상속 허용
   - `@Repeatable`: 중복 적용 허용

4. **실전 활용**
   - Spring, JUnit, JPA 등 프레임워크에서 필수
   - 리플렉션과 함께 사용하여 동적 처리
   - 코드 가독성과 유지보수성 향상

### JavaScript/TypeScript vs Java

| 기능 | JavaScript | TypeScript | Java |
|-----|-----------|-----------|------|
| 메타데이터 | JSDoc (문서만) | 데코레이터 (실험적) | 어노테이션 (표준) |
| 컴파일 검증 | ❌ | ⚠️ | ✅ |
| 런타임 활용 | ❌ | ✅ | ✅ |
| 프레임워크 지원 | ❌ | ⚠️ | ✅ |

---

**다음 섹션:** [7.5. 실습: 컬렉션 프레임워크 활용](./7.5_실습.md)
