# 7.3. 열거형 (Enum)

## 학습 목표
- 열거형(Enum)의 개념과 필요성을 이해한다
- JavaScript와 Java의 상수 처리 방식 차이를 비교한다
- Enum의 다양한 활용법을 실습한다
- Enum에 변수, 생성자, 메서드를 추가하는 방법을 익힌다

---

## 1. 열거형이란?

### 1.1. 개념

**열거형(Enum)**은 관련있는 상수들의 모임을 타입으로 정의한 것입니다.

```java
public enum Day {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY;
}
```

**주요 특징:**
- `enum` 키워드로 선언
- 자동으로 `java.lang.Enum` 클래스를 상속
- 각 상수는 해당 Enum 타입의 **인스턴스**
- 타입 안정성(Type Safety)을 보장
- 상수는 유일하게 하나만 생성되므로 `==`로 비교 가능

---

### 1.2. JavaScript와 비교

#### JavaScript의 상수 처리

```javascript
// 방법 1: 별도의 변수로 관리
const MONDAY = 'MONDAY';
const TUESDAY = 'TUESDAY';
const WEDNESDAY = 'WEDNESDAY';
// ... 너무 번거로움

// 방법 2: 객체로 관리
const Day = {
    MONDAY: 'MONDAY',
    TUESDAY: 'TUESDAY',
    WEDNESDAY: 'WEDNESDAY',
    THURSDAY: 'THURSDAY',
    FRIDAY: 'FRIDAY',
    SATURDAY: 'SATURDAY',
    SUNDAY: 'SUNDAY'
};

// 방법 3: Object.freeze로 불변 객체 만들기
const Day = Object.freeze({
    MONDAY: 'MONDAY',
    TUESDAY: 'TUESDAY',
    // ...
});

// 사용
let today = Day.MONDAY;

// 문제점: 타입 체크가 불가능
today = 'INVALID_DAY';  // 에러 발생 안함
today = 123;             // 에러 발생 안함
```

#### TypeScript의 Enum

```typescript
enum Day {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}

let today: Day = Day.MONDAY;

// today = 'INVALID_DAY';  // 컴파일 에러!
// today = 123;            // 컴파일 에러!
```

#### Java의 Enum

```java
public enum Day {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY;
}

public class Main {
    public static void main(String[] args) {
        Day today = Day.MONDAY;

        // today = "INVALID_DAY";  // 컴파일 에러!
        // today = 123;            // 컴파일 에러!
    }
}
```

**비교 정리:**

| 항목 | JavaScript | TypeScript | Java |
|------|-----------|-----------|------|
| 타입 안정성 | ❌ 없음 | ✅ 컴파일 시 | ✅ 컴파일 시 |
| 문법 지원 | ❌ 없음 (객체로 구현) | ✅ enum 키워드 | ✅ enum 키워드 |
| 메서드 추가 | ✅ 가능 | ⚠️ 제한적 | ✅ 완전 지원 |
| 생성자 | ❌ 없음 | ❌ 없음 | ✅ 있음 |
| 런타임 타입 체크 | ❌ 어려움 | ⚠️ 부분 지원 | ✅ 완전 지원 |

---

## 2. Enum 기본 사용법

### 2.1. Enum 선언과 사용

```java
public enum Day {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY;
}
```

**선언 규칙:**
- 상수는 쉼표(`,`)로 구분
- 마지막 상수 뒤에 세미콜론(`;`) (선택사항이지만 권장)
- 상수는 모두 **대문자**로 표기
- 띄어쓰기가 필요한 경우 **언더바(`_`)**로 대체

```java
public enum OrderStatus {
    ORDER_PLACED,
    PAYMENT_COMPLETED,
    IN_DELIVERY,
    DELIVERED;
}
```

### 2.2. Enum 사용

```java
public class Main {
    public static void main(String[] args) {
        // Enum 상수 사용
        Day today = Day.MONDAY;
        Day tomorrow = Day.TUESDAY;

        // 출력
        System.out.println("오늘: " + today);        // 오늘: MONDAY
        System.out.println("내일: " + tomorrow);      // 내일: TUESDAY

        // 비교 (== 연산자 사용 가능)
        if (today == Day.MONDAY) {
            System.out.println("월요일입니다!");
        }

        // equals() 메서드도 사용 가능 (하지만 == 권장)
        if (today.equals(Day.MONDAY)) {
            System.out.println("월요일입니다!");
        }
    }
}
```

**출력:**
```
오늘: MONDAY
내일: TUESDAY
월요일입니다!
월요일입니다!
```

---

## 3. Enum의 주요 메서드

### 3.1. values() - 모든 상수 배열로 반환

```java
public class Main {
    public static void main(String[] args) {
        Day[] days = Day.values();

        System.out.println("모든 요일:");
        for (Day day : days) {
            System.out.println(day);
        }
    }
}
```

**출력:**
```
모든 요일:
MONDAY
TUESDAY
WEDNESDAY
THURSDAY
FRIDAY
SATURDAY
SUNDAY
```

⚠️ **주의:** `values()`는 호출될 때마다 **새로운 배열**을 생성하여 반환합니다.

### 3.2. valueOf(String) - 문자열로 상수 찾기

```java
public class Main {
    public static void main(String[] args) {
        // 문자열로 Enum 상수 찾기
        Day tuesday = Day.valueOf("TUESDAY");
        System.out.println(tuesday);  // TUESDAY

        // 존재하지 않는 상수 찾기 (예외 발생)
        try {
            Day invalid = Day.valueOf("INVALID");
        } catch (IllegalArgumentException e) {
            System.out.println("존재하지 않는 요일입니다.");
        }
    }
}
```

**출력:**
```
TUESDAY
존재하지 않는 요일입니다.
```

### 3.3. name() - 상수 이름 반환

```java
public class Main {
    public static void main(String[] args) {
        Day friday = Day.FRIDAY;
        String name = friday.name();

        System.out.println("상수 이름: " + name);  // 상수 이름: FRIDAY
    }
}
```

### 3.4. ordinal() - 상수 순서 반환

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("MONDAY의 순서: " + Day.MONDAY.ordinal());      // 0
        System.out.println("WEDNESDAY의 순서: " + Day.WEDNESDAY.ordinal()); // 2
        System.out.println("SUNDAY의 순서: " + Day.SUNDAY.ordinal());       // 6
    }
}
```

⚠️ **주의:** `ordinal()`은 상수의 선언 순서에 의존하므로, 순서가 변경되면 값이 달라집니다. **비즈니스 로직에는 사용하지 않는 것을 권장**합니다.

---

## 4. switch문과 함께 사용하기

```java
public class Main {
    public static void main(String[] args) {
        Day day = Day.FRIDAY;

        switch (day) {
            case MONDAY:
                System.out.println("월요일입니다. 힘내세요!");
                break;
            case TUESDAY:
            case WEDNESDAY:
            case THURSDAY:
                System.out.println("평일입니다. 조금만 더 힘내세요!");
                break;
            case FRIDAY:
                System.out.println("금요일입니다. 거의 다 왔어요!");
                break;
            case SATURDAY:
            case SUNDAY:
                System.out.println("주말입니다. 푹 쉬세요!");
                break;
            default:
                System.out.println("알 수 없는 요일입니다.");
        }
    }
}
```

**출력:**
```
금요일입니다. 거의 다 왔어요!
```

**JavaScript 비교:**

```javascript
const Day = {
    MONDAY: 'MONDAY',
    FRIDAY: 'FRIDAY',
    SATURDAY: 'SATURDAY',
    SUNDAY: 'SUNDAY'
};

let day = Day.FRIDAY;

switch (day) {
    case Day.MONDAY:
        console.log("월요일입니다. 힘내세요!");
        break;
    case Day.FRIDAY:
        console.log("금요일입니다. 거의 다 왔어요!");
        break;
    case Day.SATURDAY:
    case Day.SUNDAY:
        console.log("주말입니다. 푹 쉬세요!");
        break;
    default:
        console.log("알 수 없는 요일입니다.");
}
```

---

## 5. Enum에 필드와 메서드 추가하기

### 5.1. 기본 예제

Enum도 **클래스**이므로 필드, 생성자, 메서드를 가질 수 있습니다.

```java
public enum Day {
    MONDAY(1, "월", "MON"),
    TUESDAY(2, "화", "TUE"),
    WEDNESDAY(3, "수", "WED"),
    THURSDAY(4, "목", "THU"),
    FRIDAY(5, "금", "FRI"),
    SATURDAY(6, "토", "SAT"),
    SUNDAY(7, "일", "SUN");

    // 필드 (각 상수의 인스턴스 변수)
    private final int order;
    private final String koreanName;
    private final String shortName;

    // 생성자 (private만 가능)
    Day(int order, String koreanName, String shortName) {
        this.order = order;
        this.koreanName = koreanName;
        this.shortName = shortName;
    }

    // 메서드
    public int getOrder() {
        return order;
    }

    public String getKoreanName() {
        return koreanName;
    }

    public String getShortName() {
        return shortName;
    }

    public boolean isWeekend() {
        return this == SATURDAY || this == SUNDAY;
    }
}
```

**사용 예:**

```java
public class Main {
    public static void main(String[] args) {
        Day monday = Day.MONDAY;

        System.out.println("영문: " + monday);                      // 영문: MONDAY
        System.out.println("한글: " + monday.getKoreanName());       // 한글: 월
        System.out.println("약자: " + monday.getShortName());        // 약자: MON
        System.out.println("순서: " + monday.getOrder());            // 순서: 1
        System.out.println("주말? " + monday.isWeekend());           // 주말? false

        System.out.println();

        Day saturday = Day.SATURDAY;
        System.out.println("영문: " + saturday);                    // 영문: SATURDAY
        System.out.println("한글: " + saturday.getKoreanName());     // 한글: 토
        System.out.println("주말? " + saturday.isWeekend());         // 주말? true
    }
}
```

### 5.2. 실전 예제 - 주문 상태

```java
public enum OrderStatus {
    ORDER_PLACED("주문 접수", "주문이 접수되었습니다."),
    PAYMENT_COMPLETED("결제 완료", "결제가 완료되었습니다."),
    PREPARING("상품 준비중", "상품을 준비하고 있습니다."),
    IN_DELIVERY("배송중", "상품이 배송중입니다."),
    DELIVERED("배송 완료", "배송이 완료되었습니다."),
    CANCELLED("주문 취소", "주문이 취소되었습니다.");

    private final String displayName;
    private final String description;

    OrderStatus(String displayName, String description) {
        this.displayName = displayName;
        this.description = description;
    }

    public String getDisplayName() {
        return displayName;
    }

    public String getDescription() {
        return description;
    }

    // 취소 가능 여부 확인
    public boolean isCancellable() {
        return this == ORDER_PLACED || this == PAYMENT_COMPLETED;
    }

    // 다음 상태로 진행
    public OrderStatus next() {
        switch (this) {
            case ORDER_PLACED:
                return PAYMENT_COMPLETED;
            case PAYMENT_COMPLETED:
                return PREPARING;
            case PREPARING:
                return IN_DELIVERY;
            case IN_DELIVERY:
                return DELIVERED;
            default:
                throw new IllegalStateException("더 이상 진행할 수 없는 상태입니다: " + this);
        }
    }
}
```

**사용 예:**

```java
public class Order {
    private String orderId;
    private OrderStatus status;

    public Order(String orderId) {
        this.orderId = orderId;
        this.status = OrderStatus.ORDER_PLACED;
    }

    public void processNext() {
        if (status == OrderStatus.DELIVERED || status == OrderStatus.CANCELLED) {
            System.out.println("주문이 이미 완료되었거나 취소되었습니다.");
            return;
        }

        status = status.next();
        System.out.println("주문 상태 변경: " + status.getDisplayName());
        System.out.println(status.getDescription());
    }

    public void cancel() {
        if (status.isCancellable()) {
            status = OrderStatus.CANCELLED;
            System.out.println("주문이 취소되었습니다.");
        } else {
            System.out.println("이 상태에서는 주문을 취소할 수 없습니다: " + status.getDisplayName());
        }
    }

    public void printStatus() {
        System.out.println("주문번호: " + orderId);
        System.out.println("현재 상태: " + status.getDisplayName());
        System.out.println("설명: " + status.getDescription());
        System.out.println("취소 가능: " + (status.isCancellable() ? "예" : "아니오"));
    }
}

public class Main {
    public static void main(String[] args) {
        Order order = new Order("ORD-2024-001");

        order.printStatus();
        System.out.println();

        order.processNext();  // 결제 완료
        System.out.println();

        order.processNext();  // 상품 준비중
        System.out.println();

        order.cancel();       // 취소 불가
    }
}
```

**출력:**
```
주문번호: ORD-2024-001
현재 상태: 주문 접수
설명: 주문이 접수되었습니다.
취소 가능: 예

주문 상태 변경: 결제 완료
결제가 완료되었습니다.

주문 상태 변경: 상품 준비중
상품을 준비하고 있습니다.

이 상태에서는 주문을 취소할 수 없습니다: 상품 준비중
```

---

## 6. 추상 메서드를 활용한 Enum

각 상수마다 **다른 동작**을 구현해야 할 때는 추상 메서드를 사용합니다.

### 6.1. 기본 예제

```java
public enum Operation {
    PLUS("+") {
        @Override
        public double calculate(double x, double y) {
            return x + y;
        }
    },
    MINUS("-") {
        @Override
        public double calculate(double x, double y) {
            return x - y;
        }
    },
    MULTIPLY("*") {
        @Override
        public double calculate(double x, double y) {
            return x * y;
        }
    },
    DIVIDE("/") {
        @Override
        public double calculate(double x, double y) {
            if (y == 0) {
                throw new ArithmeticException("0으로 나눌 수 없습니다.");
            }
            return x / y;
        }
    };

    private final String symbol;

    Operation(String symbol) {
        this.symbol = symbol;
    }

    public String getSymbol() {
        return symbol;
    }

    // 각 상수에서 구현해야 하는 추상 메서드
    public abstract double calculate(double x, double y);
}
```

**사용 예:**

```java
public class Main {
    public static void main(String[] args) {
        double x = 10.0;
        double y = 3.0;

        for (Operation op : Operation.values()) {
            double result = op.calculate(x, y);
            System.out.printf("%.1f %s %.1f = %.2f\n", x, op.getSymbol(), y, result);
        }
    }
}
```

**출력:**
```
10.0 + 3.0 = 13.00
10.0 - 3.0 = 7.00
10.0 * 3.0 = 30.00
10.0 / 3.0 = 3.33
```

### 6.2. 실전 예제 - 할인 정책

```java
public enum DiscountPolicy {
    NONE("할인 없음") {
        @Override
        public int calculateDiscount(int originalPrice) {
            return 0;
        }
    },
    FIXED_1000("1000원 할인") {
        @Override
        public int calculateDiscount(int originalPrice) {
            return 1000;
        }
    },
    RATE_10("10% 할인") {
        @Override
        public int calculateDiscount(int originalPrice) {
            return originalPrice / 10;
        }
    },
    RATE_20("20% 할인") {
        @Override
        public int calculateDiscount(int originalPrice) {
            return originalPrice / 5;
        }
    };

    private final String description;

    DiscountPolicy(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }

    // 각 정책별로 다르게 구현
    public abstract int calculateDiscount(int originalPrice);

    // 최종 가격 계산 (공통 메서드)
    public int getFinalPrice(int originalPrice) {
        int discount = calculateDiscount(originalPrice);
        return originalPrice - discount;
    }
}
```

**사용 예:**

```java
public class Product {
    private String name;
    private int price;
    private DiscountPolicy discountPolicy;

    public Product(String name, int price, DiscountPolicy discountPolicy) {
        this.name = name;
        this.price = price;
        this.discountPolicy = discountPolicy;
    }

    public void printPriceInfo() {
        int discount = discountPolicy.calculateDiscount(price);
        int finalPrice = discountPolicy.getFinalPrice(price);

        System.out.println("상품명: " + name);
        System.out.println("정가: " + price + "원");
        System.out.println("할인 정책: " + discountPolicy.getDescription());
        System.out.println("할인액: " + discount + "원");
        System.out.println("최종 가격: " + finalPrice + "원");
        System.out.println();
    }
}

public class Main {
    public static void main(String[] args) {
        Product p1 = new Product("노트북", 1000000, DiscountPolicy.RATE_10);
        Product p2 = new Product("마우스", 30000, DiscountPolicy.FIXED_1000);
        Product p3 = new Product("키보드", 50000, DiscountPolicy.NONE);

        p1.printPriceInfo();
        p2.printPriceInfo();
        p3.printPriceInfo();
    }
}
```

**출력:**
```
상품명: 노트북
정가: 1000000원
할인 정책: 10% 할인
할인액: 100000원
최종 가격: 900000원

상품명: 마우스
정가: 30000원
할인 정책: 1000원 할인
할인액: 1000원
최종 가격: 29000원

상품명: 키보드
정가: 50000원
할인 정책: 할인 없음
할인액: 0원
최종 가격: 50000원
```

---

## 7. Enum 사용 모범 사례

### 7.1. ✅ 권장 사항

1. **상수 대신 Enum 사용**
   ```java
   // ❌ 나쁜 예
   public static final int MONDAY = 1;
   public static final int TUESDAY = 2;

   // ✅ 좋은 예
   public enum Day {
       MONDAY, TUESDAY, WEDNESDAY
   }
   ```

2. **==로 비교**
   ```java
   Day day = Day.MONDAY;

   // ✅ 권장
   if (day == Day.MONDAY) { }

   // ⚠️ 가능하지만 불필요
   if (day.equals(Day.MONDAY)) { }
   ```

3. **ordinal() 사용 지양**
   ```java
   // ❌ 나쁜 예 (순서 변경 시 문제 발생)
   if (day.ordinal() == 0) { }

   // ✅ 좋은 예
   if (day == Day.MONDAY) { }
   ```

4. **불변 필드 사용**
   ```java
   public enum Day {
       MONDAY(1);

       private final int order;  // ✅ final 사용

       Day(int order) {
           this.order = order;
       }
   }
   ```

### 7.2. ❌ 주의 사항

1. **new로 생성 불가**
   ```java
   // ❌ 컴파일 에러
   Day day = new Day();
   ```

2. **상속 불가**
   ```java
   // ❌ 컴파일 에러
   public enum MyDay extends Day { }
   ```

3. **다른 클래스 상속 불가** (java.lang.Enum 자동 상속)
   ```java
   // ❌ 컴파일 에러
   public enum Day extends SomeClass { }
   ```

4. **인터페이스 구현은 가능**
   ```java
   // ✅ 가능
   public enum Day implements Printable {
       MONDAY, TUESDAY;

       @Override
       public void print() {
           System.out.println(this);
       }
   }
   ```

---

## 8. 연습 문제

### 문제 1: 계절 Enum (기본)

다음 요구사항을 만족하는 `Season` Enum을 작성하세요.

**요구사항:**
- 네 개의 상수: SPRING, SUMMER, FALL, WINTER
- 각 계절의 한글 이름을 반환하는 `getKoreanName()` 메서드
- 각 계절의 평균 온도를 반환하는 `getAverageTemp()` 메서드

**예상 출력:**
```
봄: 평균 15도
여름: 평균 28도
가을: 평균 18도
겨울: 평균 0도
```

<details>
<summary>답안 보기</summary>

```java
public enum Season {
    SPRING("봄", 15),
    SUMMER("여름", 28),
    FALL("가을", 18),
    WINTER("겨울", 0);

    private final String koreanName;
    private final int averageTemp;

    Season(String koreanName, int averageTemp) {
        this.koreanName = koreanName;
        this.averageTemp = averageTemp;
    }

    public String getKoreanName() {
        return koreanName;
    }

    public int getAverageTemp() {
        return averageTemp;
    }
}

public class Main {
    public static void main(String[] args) {
        for (Season season : Season.values()) {
            System.out.printf("%s: 평균 %d도\n",
                season.getKoreanName(),
                season.getAverageTemp());
        }
    }
}
```

</details>

---

### 문제 2: 커피 사이즈 Enum (중급)

다음 요구사항을 만족하는 `CoffeeSize` Enum을 작성하세요.

**요구사항:**
- 세 개의 상수: SMALL, MEDIUM, LARGE
- 각 사이즈의 용량(ml)과 추가 가격을 저장
- 기본 가격(4000원)에 사이즈별 추가 가격을 더한 최종 가격을 반환하는 메서드

**예상 출력:**
```
SMALL: 355ml, 4000원
MEDIUM: 473ml, 4500원
LARGE: 591ml, 5000원
```

<details>
<summary>답안 보기</summary>

```java
public enum CoffeeSize {
    SMALL(355, 0),
    MEDIUM(473, 500),
    LARGE(591, 1000);

    private static final int BASE_PRICE = 4000;
    private final int volume;
    private final int extraCost;

    CoffeeSize(int volume, int extraCost) {
        this.volume = volume;
        this.extraCost = extraCost;
    }

    public int getVolume() {
        return volume;
    }

    public int getTotalPrice() {
        return BASE_PRICE + extraCost;
    }
}

public class Main {
    public static void main(String[] args) {
        for (CoffeeSize size : CoffeeSize.values()) {
            System.out.printf("%s: %dml, %d원\n",
                size,
                size.getVolume(),
                size.getTotalPrice());
        }
    }
}
```

</details>

---

### 문제 3: 결제 방법 Enum (고급)

다음 요구사항을 만족하는 `PaymentMethod` Enum을 작성하세요.

**요구사항:**
- 네 개의 상수: CASH, CARD, MOBILE, POINTS
- 각 결제 방법마다 다른 수수료율 적용 (추상 메서드 활용)
  - CASH: 수수료 없음
  - CARD: 3% 수수료
  - MOBILE: 2.5% 수수료
  - POINTS: 수수료 없음
- 최종 결제 금액을 계산하는 메서드

**예상 출력:**
```
현금 결제: 10000원 -> 최종 10000원
카드 결제: 10000원 -> 최종 10300원
모바일 결제: 10000원 -> 최종 10250원
포인트 결제: 10000원 -> 최종 10000원
```

<details>
<summary>답안 보기</summary>

```java
public enum PaymentMethod {
    CASH("현금") {
        @Override
        public int calculateFee(int amount) {
            return 0;
        }
    },
    CARD("카드") {
        @Override
        public int calculateFee(int amount) {
            return (int)(amount * 0.03);
        }
    },
    MOBILE("모바일") {
        @Override
        public int calculateFee(int amount) {
            return (int)(amount * 0.025);
        }
    },
    POINTS("포인트") {
        @Override
        public int calculateFee(int amount) {
            return 0;
        }
    };

    private final String displayName;

    PaymentMethod(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() {
        return displayName;
    }

    // 추상 메서드: 각 결제 방법별로 구현
    public abstract int calculateFee(int amount);

    // 최종 결제 금액 계산
    public int getTotalAmount(int amount) {
        return amount + calculateFee(amount);
    }
}

public class Main {
    public static void main(String[] args) {
        int amount = 10000;

        for (PaymentMethod method : PaymentMethod.values()) {
            int total = method.getTotalAmount(amount);
            System.out.printf("%s 결제: %d원 -> 최종 %d원\n",
                method.getDisplayName(),
                amount,
                total);
        }
    }
}
```

</details>

---

### 문제 4: 신호등 시뮬레이션 (종합)

신호등 시스템을 Enum으로 구현하세요.

**요구사항:**
- 세 개의 상수: RED, YELLOW, GREEN
- 각 신호의 지속 시간(초)을 저장
- 다음 신호로 변경하는 `next()` 메서드
- 현재 신호에서 허용되는 동작을 출력하는 추상 메서드 `action()`

**예상 동작:**
```
현재 신호: RED (30초)
동작: 정지하세요.

현재 신호: GREEN (45초)
동작: 진행하세요.

현재 신호: YELLOW (5초)
동작: 감속하세요.

현재 신호: RED (30초)
동작: 정지하세요.
```

<details>
<summary>답안 보기</summary>

```java
public enum TrafficLight {
    RED(30, "빨간불") {
        @Override
        public void action() {
            System.out.println("동작: 정지하세요.");
        }
    },
    YELLOW(5, "노란불") {
        @Override
        public void action() {
            System.out.println("동작: 감속하세요.");
        }
    },
    GREEN(45, "초록불") {
        @Override
        public void action() {
            System.out.println("동작: 진행하세요.");
        }
    };

    private final int duration;
    private final String displayName;

    TrafficLight(int duration, String displayName) {
        this.duration = duration;
        this.displayName = displayName;
    }

    public int getDuration() {
        return duration;
    }

    public String getDisplayName() {
        return displayName;
    }

    // 다음 신호로 변경
    public TrafficLight next() {
        switch (this) {
            case RED:
                return GREEN;
            case GREEN:
                return YELLOW;
            case YELLOW:
                return RED;
            default:
                throw new IllegalStateException("알 수 없는 신호입니다.");
        }
    }

    // 각 신호별 동작 (추상 메서드)
    public abstract void action();

    // 신호 정보 출력
    public void display() {
        System.out.printf("현재 신호: %s (%d초)\n", this, duration);
        action();
        System.out.println();
    }
}

public class Main {
    public static void main(String[] args) {
        TrafficLight current = TrafficLight.RED;

        // 4번 신호 변경
        for (int i = 0; i < 4; i++) {
            current.display();
            current = current.next();
        }
    }
}
```

</details>

---

## 9. 정리

### 핵심 개념

1. **Enum은 타입 안전한 상수 집합**
   - 컴파일 타임에 타입 체크
   - 잘못된 값 할당 방지

2. **Enum은 클래스**
   - 필드, 생성자, 메서드 가질 수 있음
   - 추상 메서드로 각 상수마다 다른 동작 구현 가능

3. **주요 메서드**
   - `values()`: 모든 상수 배열로 반환
   - `valueOf(String)`: 문자열로 상수 찾기
   - `name()`: 상수 이름 반환
   - `ordinal()`: 상수 순서 (사용 지양)

4. **비교는 `==` 사용**
   - Enum 상수는 싱글톤
   - `equals()` 대신 `==` 권장

### JavaScript vs Java Enum

| 특징 | JavaScript | Java |
|------|-----------|------|
| 문법 지원 | 객체로 흉내 | enum 키워드 |
| 타입 안정성 | 없음 | 강력함 |
| 메서드 추가 | 가능 | 완전 지원 |
| switch문 | 가능 | 최적화됨 |

---

**다음 섹션:** [7.4. 어노테이션 소개](./7.4_어노테이션_소개.md)
