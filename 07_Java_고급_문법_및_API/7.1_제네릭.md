# 7.1. 제네릭 (Generics)

> 제네릭을 사용하여 타입 안정성을 확보하고, 재사용 가능한 코드를 작성하는 방법을 학습합니다.

## 학습 목표
- 제네릭의 개념과 필요성 이해
- 제네릭 클래스와 메서드 작성
- 타입 제한과 와일드카드 활용
- JavaScript의 타입스크립트 제네릭과 비교

---

## 1. 제네릭이란?

### 개념

**제네릭(Generics)**은 **다양한 타입의 객체를 다루는 클래스나 메서드에 컴파일 시 타입 체크**를 해주는 기능입니다.

**핵심:**
- 타입을 파라미터화(변수화)
- 컴파일 타임에 타입 안정성 확보
- 꺾쇠 `<>` 사용

### 왜 필요한가?

**문제 상황: 제네릭 없이 사용**

```java
// Object를 사용한 범용 클래스
public class Box {
    private Object item;

    public void setItem(Object item) {
        this.item = item;
    }

    public Object getItem() {
        return item;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Box box = new Box();
        box.setItem("Hello");  // String 저장

        // 꺼낼 때 형변환 필요
        String item = (String) box.getItem();  // ✅ 정상
        System.out.println(item);
    }
}
```

**문제점 1: 런타임 에러 가능성**

```java
public class Main {
    public static void main(String[] args) {
        Box box = new Box();
        box.setItem("Hello");  // String 저장

        // ❌ 컴파일은 되지만 런타임 에러 발생!
        Integer item = (Integer) box.getItem();
    }
}
```

**에러:**
```
Exception in thread "main" java.lang.ClassCastException:
java.lang.String cannot be cast to java.lang.Integer
```

**문제점 2: 타입 안정성 부족**

```java
Box box = new Box();
box.setItem("String");
box.setItem(123);  // ❌ 다른 타입도 저장 가능 (의도하지 않은 동작)
```

### 제네릭으로 해결

```java
// 제네릭 사용
public class Box<T> {
    private T item;

    public void setItem(T item) {
        this.item = item;
    }

    public T getItem() {
        return item;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        // String 타입으로 지정
        Box<String> box = new Box<>();
        box.setItem("Hello");

        // 형변환 불필요!
        String item = box.getItem();
        System.out.println(item);

        // box.setItem(123);  // ❌ 컴파일 에러!
    }
}
```

### 제네릭의 장점

1. **타입 안정성**: 컴파일 타임에 타입 체크
2. **코드 간결성**: 형변환 코드 제거
3. **재사용성**: 하나의 코드로 여러 타입 처리

### JavaScript(TypeScript)와의 비교

```typescript
// TypeScript - 제네릭
class Box<T> {
    private item: T;

    setItem(item: T): void {
        this.item = item;
    }

    getItem(): T {
        return this.item;
    }
}

const box = new Box<string>();
box.setItem("Hello");
const item = box.getItem();  // string 타입
```

**차이점:**
- Java: 런타임에도 타입 정보 일부 유지
- TypeScript: 컴파일 후 타입 정보 제거 (타입 소거)

---

## 2. 제네릭 클래스

### 기본 문법

```java
public class ClassName<T> {
    private T field;

    public T getField() {
        return field;
    }

    public void setField(T field) {
        this.field = field;
    }
}
```

**구성 요소:**
- `<T>`: 타입 파라미터 (Type Parameter)
- `T`: 타입 변수 (Type Variable)

### 타입 변수 명명 관례

| 타입 변수 | 의미 | 사용 예시 |
|----------|------|----------|
| `T` | Type | 일반적인 타입 |
| `E` | Element | 컬렉션 요소 |
| `K` | Key | 맵의 키 |
| `V` | Value | 맵의 값 |
| `N` | Number | 숫자 타입 |
| `R` | Result | 반환 타입 |

### 실습 예시: Pair 클래스

```java
public class Pair<K, V> {
    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public K getKey() {
        return key;
    }

    public V getValue() {
        return value;
    }

    @Override
    public String toString() {
        return "Pair{key=" + key + ", value=" + value + "}";
    }
}
```

**사용:**

```java
public class Main {
    public static void main(String[] args) {
        // String, Integer 조합
        Pair<String, Integer> pair1 = new Pair<>("Age", 25);
        System.out.println(pair1);

        // String, String 조합
        Pair<String, String> pair2 = new Pair<>("Name", "홍길동");
        System.out.println(pair2);

        // Integer, Double 조합
        Pair<Integer, Double> pair3 = new Pair<>(1, 3.14);
        System.out.println(pair3);
    }
}
```

**출력:**
```
Pair{key=Age, value=25}
Pair{key=Name, value=홍길동}
Pair{key=1, value=3.14}
```

### 생성자 타입 생략 (다이아몬드 연산자)

```java
// Java 7 이전
Box<String> box1 = new Box<String>();

// Java 7 이후 - 생성자에서 타입 생략 가능
Box<String> box2 = new Box<>();  // ✅ 권장
```

### 제네릭 클래스 주의사항

#### 1. 기본 타입 사용 불가

```java
// ❌ 컴파일 에러!
Box<int> box1 = new Box<>();
Box<double> box2 = new Box<>();

// ✅ 래퍼 클래스 사용
Box<Integer> box3 = new Box<>();
Box<Double> box4 = new Box<>();
```

#### 2. 제네릭 타입 객체 직접 생성 불가

```java
public class Box<T> {
    // ❌ 컴파일 에러!
    // private T item = new T();
    // private T[] array = new T[10];
}
```

**이유:** 컴파일 시 T의 실제 타입을 알 수 없음

#### 3. static 멤버에 제네릭 타입 사용 불가

```java
public class Box<T> {
    private T item;  // ✅ 인스턴스 필드

    // ❌ 컴파일 에러!
    // private static T staticItem;

    // ❌ 컴파일 에러!
    // public static void staticMethod(T param) {
    // }
}
```

**이유:** static은 인스턴스 생성 전에 메모리에 할당되지만, T는 인스턴스 생성 시 결정됨

---

## 3. 타입 제한 (Bounded Type Parameters)

### 개념

특정 타입과 그 하위 타입만 허용하도록 제한할 수 있습니다.

**문법:**
```java
<T extends UpperBound>
```

### 예시: Number 하위 타입만 허용

```java
public class Calculator<T extends Number> {
    private T num1;
    private T num2;

    public Calculator(T num1, T num2) {
        this.num1 = num1;
        this.num2 = num2;
    }

    public double sum() {
        return num1.doubleValue() + num2.doubleValue();
    }

    public double multiply() {
        return num1.doubleValue() * num2.doubleValue();
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        // ✅ Integer는 Number의 하위 타입
        Calculator<Integer> calc1 = new Calculator<>(10, 20);
        System.out.println("합: " + calc1.sum());

        // ✅ Double도 Number의 하위 타입
        Calculator<Double> calc2 = new Calculator<>(3.5, 2.5);
        System.out.println("곱: " + calc2.multiply());

        // ❌ 컴파일 에러! String은 Number의 하위 타입 아님
        // Calculator<String> calc3 = new Calculator<>("a", "b");
    }
}
```

### 타입 제한의 장점

**Number 메서드 사용 가능:**

```java
public class Box<T extends Number> {
    private T value;

    public Box(T value) {
        this.value = value;
    }

    // Number의 메서드 사용 가능
    public int getIntValue() {
        return value.intValue();
    }

    public double getDoubleValue() {
        return value.doubleValue();
    }
}
```

### 다중 타입 제한

인터페이스를 포함한 여러 타입 제한 가능:

```java
// Number이면서 Comparable을 구현한 타입만 허용
public class SortedBox<T extends Number & Comparable<T>> {
    private T value;

    public SortedBox(T value) {
        this.value = value;
    }

    public int compareTo(T other) {
        return value.compareTo(other);
    }
}
```

**주의:** 클래스는 하나만, 인터페이스는 여러 개 가능

---

## 4. 제네릭 메서드

### 개념

메서드 레벨에서 독립적으로 제네릭 타입을 선언할 수 있습니다.

### 문법

```java
public <T> ReturnType methodName(T param) {
    // ...
}
```

**핵심:** 반환 타입 앞에 `<T>` 선언

### 예시

```java
public class GenericMethod {
    // 제네릭 메서드
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.print(element + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Integer[] intArray = {1, 2, 3, 4, 5};
        String[] strArray = {"A", "B", "C"};
        Double[] doubleArray = {1.1, 2.2, 3.3};

        printArray(intArray);    // Integer 배열
        printArray(strArray);    // String 배열
        printArray(doubleArray); // Double 배열
    }
}
```

**출력:**
```
1 2 3 4 5
A B C
1.1 2.2 3.3
```

### 클래스 제네릭 vs 메서드 제네릭

```java
public class Container<T> {
    private T item;

    // 클래스 제네릭 T 사용
    public void setItem(T item) {
        this.item = item;
    }

    // 메서드 제네릭 V 사용 (독립적)
    public <V> void print(V value) {
        System.out.println(value);
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Container<String> container = new Container<>();
        container.setItem("Hello");       // String 타입

        container.print(123);             // Integer 타입 (독립적)
        container.print(3.14);            // Double 타입 (독립적)
    }
}
```

### static 메서드에서의 제네릭

```java
public class Util {
    // ✅ static 메서드에서 제네릭 메서드 가능
    public static <T> T getFirst(T[] array) {
        if (array == null || array.length == 0) {
            return null;
        }
        return array[0];
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        String[] strArray = {"A", "B", "C"};
        String first = Util.getFirst(strArray);
        System.out.println(first);  // "A"

        Integer[] intArray = {1, 2, 3};
        Integer firstNum = Util.getFirst(intArray);
        System.out.println(firstNum);  // 1
    }
}
```

---

## 5. 와일드카드 (Wildcard)

### 개념

**와일드카드(`?`)**는 제네릭 타입을 메서드 파라미터로 받을 때 사용합니다.

### 3가지 종류

| 와일드카드 | 의미 | 예시 |
|-----------|------|------|
| `<?>` | 모든 타입 허용 | `List<?>` |
| `<? extends T>` | T와 T의 하위 타입만 | `List<? extends Number>` |
| `<? super T>` | T와 T의 상위 타입만 | `List<? super Integer>` |

### 비한정 와일드카드 `<?>`

```java
public class WildcardExample {
    // 모든 타입의 List 출력
    public static void printList(List<?> list) {
        for (Object obj : list) {
            System.out.print(obj + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        List<Integer> intList = Arrays.asList(1, 2, 3);
        List<String> strList = Arrays.asList("A", "B", "C");

        printList(intList);  // ✅
        printList(strList);  // ✅
    }
}
```

### 상한 제한 와일드카드 `<? extends T>`

```java
public class UpperBoundedExample {
    // Number와 그 하위 타입(Integer, Double 등)만 허용
    public static double sumOfList(List<? extends Number> list) {
        double sum = 0.0;
        for (Number num : list) {
            sum += num.doubleValue();
        }
        return sum;
    }

    public static void main(String[] args) {
        List<Integer> intList = Arrays.asList(1, 2, 3);
        List<Double> doubleList = Arrays.asList(1.5, 2.5, 3.5);

        System.out.println(sumOfList(intList));     // 6.0
        System.out.println(sumOfList(doubleList));  // 7.5

        // List<String> strList = Arrays.asList("A", "B");
        // sumOfList(strList);  // ❌ 컴파일 에러!
    }
}
```

### 하한 제한 와일드카드 `<? super T>`

```java
public class LowerBoundedExample {
    // Integer와 그 상위 타입(Number, Object)만 허용
    public static void addNumbers(List<? super Integer> list) {
        list.add(1);
        list.add(2);
        list.add(3);
    }

    public static void main(String[] args) {
        List<Integer> intList = new ArrayList<>();
        addNumbers(intList);
        System.out.println(intList);  // [1, 2, 3]

        List<Number> numList = new ArrayList<>();
        addNumbers(numList);
        System.out.println(numList);  // [1, 2, 3]

        List<Object> objList = new ArrayList<>();
        addNumbers(objList);
        System.out.println(objList);  // [1, 2, 3]

        // List<Double> doubleList = new ArrayList<>();
        // addNumbers(doubleList);  // ❌ 컴파일 에러!
    }
}
```

### PECS 원칙

**Producer Extends, Consumer Super**

- **읽기만**: `<? extends T>` 사용
- **쓰기만**: `<? super T>` 사용

```java
// 생산자(읽기): extends 사용
public static void copy(List<? extends Number> src, List<? super Number> dest) {
    for (Number num : src) {  // src에서 읽기
        dest.add(num);         // dest에 쓰기
    }
}
```

---

## 6. 실습 문제

### 문제 1: 제네릭 Stack 구현

배열 기반의 제네릭 Stack을 구현하세요.

**요구사항:**
- `push(T item)`: 추가
- `T pop()`: 제거 및 반환
- `T peek()`: 최상단 조회
- `boolean isEmpty()`: 비어있는지 확인
- 초기 용량 10

**테스트 코드:**
```java
public class Main {
    public static void main(String[] args) {
        Stack<String> stack = new Stack<>();
        stack.push("A");
        stack.push("B");
        stack.push("C");

        System.out.println(stack.peek());  // C
        System.out.println(stack.pop());   // C
        System.out.println(stack.pop());   // B
        System.out.println(stack.isEmpty());  // false
    }
}
```

### 문제 2: 제네릭 메서드 - 배열 뒤집기

제네릭 메서드로 배열을 뒤집는 `reverse()` 메서드를 작성하세요.

**요구사항:**
- static 제네릭 메서드
- 모든 타입의 배열 처리

**테스트 코드:**
```java
public class Main {
    public static void main(String[] args) {
        Integer[] intArray = {1, 2, 3, 4, 5};
        reverse(intArray);
        System.out.println(Arrays.toString(intArray));  // [5, 4, 3, 2, 1]

        String[] strArray = {"A", "B", "C"};
        reverse(strArray);
        System.out.println(Arrays.toString(strArray));  // [C, B, A]
    }

    // 여기에 reverse 메서드 구현
}
```

### 문제 3: 타입 제한 활용

Comparable을 구현한 타입만 받아서 최대값을 찾는 제네릭 메서드를 작성하세요.

**요구사항:**
- `<T extends Comparable<T>>`  사용
- 배열에서 최대값 반환

**테스트 코드:**
```java
public class Main {
    public static void main(String[] args) {
        Integer[] intArray = {3, 7, 2, 9, 1};
        System.out.println(findMax(intArray));  // 9

        String[] strArray = {"apple", "banana", "cherry"};
        System.out.println(findMax(strArray));  // cherry
    }

    // 여기에 findMax 메서드 구현
}
```

---

## 요약

### 제네릭 핵심 개념

| 개념 | 설명 | 예시 |
|------|------|------|
| **제네릭 클래스** | 클래스 레벨 타입 파라미터 | `class Box<T>` |
| **제네릭 메서드** | 메서드 레벨 타입 파라미터 | `<T> void method(T param)` |
| **타입 제한** | 특정 타입으로 제한 | `<T extends Number>` |
| **와일드카드** | 메서드 파라미터 유연성 | `List<?>`, `<? extends T>` |

### 장점

- ✅ **타입 안정성**: 컴파일 타임 타입 체크
- ✅ **코드 재사용**: 하나의 코드로 여러 타입 처리
- ✅ **형변환 제거**: 명시적 캐스팅 불필요

### 주의사항

- ❌ 기본 타입 사용 불가 (래퍼 클래스 사용)
- ❌ 제네릭 타입 객체 직접 생성 불가
- ❌ static 멤버에 클래스 제네릭 사용 불가

### Java vs TypeScript

| 구분 | Java | TypeScript |
|------|------|------------|
| 문법 | `class Box<T>` | `class Box<T>` |
| 타입 소거 | 부분 유지 | 완전 소거 |
| 타입 제한 | `extends` | `extends` |
| 컴파일 체크 | ✅ | ✅ |

**다음 학습:**
- 7.2장에서 제네릭을 활용한 컬렉션 프레임워크 학습
